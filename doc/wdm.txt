=== ddksynth/DDKSynth.rc ===
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.


#include <windows.h>

#include <ntverp.h>

#define VER_FILETYPE                VFT_DRV
#define VER_FILESUBTYPE             VFT2_DRV_SOUND

#define VER_FILEDESCRIPTION_STR     "Microsoft DDK Kernel DLS Synthesizer"
#define VER_ORIGINALFILENAME_STR    "DDKSynth.sys"

#define VER_INTERNALNAME_STR        VER_FILEDESCRIPTION_STR

#include "common.ver"


=== ddksynth/adapter.cpp ===
/*****************************************************************************
 * adapter.cpp - DMusic adapter implementation
 *
 *  This includes the adapter driver for the 
 *  kernel mode DirectMusic DLS 1.0 SW synthesizer
 *
 *****************************************************************************
 * Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
 *
 *  06/08/98    MartinP
 *
 */

//
// All the GUIDS for all the miniports end up in this object.
//
#define PUT_GUIDS_HERE

#define STR_MODULENAME "DDKSynth.sys:Adapter: "

#define PC_NEW_NAMES 1

#include "common.h"
#include "private.h"


/*****************************************************************************
 * Defines
 */

#define MAX_MINIPORTS 1

#if (DBG)
#define SUCCEEDS(s) ASSERT(NT_SUCCESS(s))
#else
#define SUCCEEDS(s) (s)
#endif

/*****************************************************************************
 * Referenced forward
 */
NTSTATUS
AddDevice
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
);

NTSTATUS
StartDevice
(
    IN      PDEVICE_OBJECT  pDeviceObject,  // Context for the class driver.
    IN      PIRP            pIrp,           // Context for the class driver.
    IN      PRESOURCELIST   ResourceList    // List of hardware resources.
);


#pragma code_seg("INIT")
/*****************************************************************************
 * DriverEntry()
 *****************************************************************************
 * This function is called by the operating system when the driver is loaded.
 * All adapter drivers can use this code without change.
 */
extern "C"
NTSTATUS
DriverEntry
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE, ("DriverEntry"));

    //
    // Tell the class driver to initialize the driver.
    //
    return PcInitializeAdapterDriver((PDRIVER_OBJECT)Context1,
                                     (PUNICODE_STRING)Context2, 
                                     (PDRIVER_ADD_DEVICE)AddDevice);
}


#pragma code_seg()
/*****************************************************************************
 * AddDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is added.
 * All adapter drivers can use this code without change.
 */
NTSTATUS
AddDevice
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE, ("AddDevice"));

    //
    // Tell the class driver to add the device.
    //
    return PcAddAdapterDevice((PDRIVER_OBJECT)Context1, (PDEVICE_OBJECT)Context2, StartDevice, MAX_MINIPORTS, 0);
}


/*****************************************************************************
 * StartDevice()
 *****************************************************************************
 *
 *  This function is called by the operating system when the device is started.
 *  It is responsible for starting the miniports.  This code is specific to
 *  the adapter because it calls out miniports for functions that are specific
 *  to the adapter.  A list of no resources is not the same as a NULL list ptr.
 *
 */
NTSTATUS
StartDevice
(
    IN      PDEVICE_OBJECT  pDeviceObject,  // Context for the class driver.
    IN      PIRP            pIrp,           // Context for the class driver.
    IN      PRESOURCELIST   ResourceList    // List of hardware resources.
)
{
    PAGED_CODE();
    
    _DbgPrintF(DEBUGLVL_VERBOSE, ("StartDevice"));
    
    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_INVALID_PARAMETER;
    }

    PPORT       port;
    NTSTATUS    ntStatus = PcNewPort(&port, CLSID_PortDMus);
    
    if (!NT_SUCCESS(ntStatus))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("StartDevice PcNewPort failed (0x%08x)", ntStatus));
        return ntStatus;
    }
    ASSERT(port);

    PUNKNOWN miniport;
    ntStatus = CreateMiniportDmSynth(&miniport, NULL, NonPagedPool);

    if (!NT_SUCCESS(ntStatus))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("StartDevice CreateMiniportDmSynth failed (0x%08x)", ntStatus));
        port->Release();
        return ntStatus;
    }
    ASSERT(miniport);

    ntStatus = 
        port->Init
        (
            pDeviceObject, 
            pIrp, 
            miniport, 
            NULL, 
            ResourceList
        );

    if (!NT_SUCCESS(ntStatus))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("StartDevice port Init failed (0x%08x)", ntStatus));
        port->Release();
        miniport->Release();
        return ntStatus;
    }

    ntStatus = PcRegisterSubdevice( pDeviceObject,
                                    L"DDKSynth", 
                                    port);
    if (!NT_SUCCESS(ntStatus))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("StartDevice PcRegisterSubdevice failed (0x%08x)", ntStatus));
    }
    
    //
    // We don't need the miniport any more.  Either the port has it,
    // or we've failed, and it should be deleted.
    //
    miniport->Release();
    
    //
    // Release the reference which existed when PcNewPort() gave us the
    // pointer in the first place.  This is the right thing to do
    // regardless of the outcome.
    //
    port->Release();

    return ntStatus;
}

/*****************************************************************************
 * _purecall()
 *****************************************************************************
 * The C++ compiler loves me.
 * TODO: Figure out how to put this into portcls.sys
 */
int __cdecl
_purecall( void )
{
    ASSERT( !"Pure virtual function called" );
    return 0;
}


=== ddksynth/clist.cpp ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//
//      clist.cpp
//
//

#define STR_MODULENAME "DDKSynth.sys:CList: "

#include "common.h"

#pragma code_seg()
/*****************************************************************************
 * CListItem::GetCount()
 *****************************************************************************
 * Returns number of items in the list.
 */
LONG CListItem::GetCount(void) const
{
    LONG l;
    const CListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

/*****************************************************************************
 * CListItem::IsMember()
 *****************************************************************************
 * Returns whether the given list item is a member of the list.
 */
BOOL CListItem::IsMember(CListItem *pItem)
{
    CListItem *li = this;
    for (;li != NULL; li=li->m_pNext)
    {
        if (li == pItem) return (TRUE);
    }
    return (FALSE);
}

/*****************************************************************************
 * CListItem::Cat()
 *****************************************************************************
 * Append the given list item to the list.
 */
CListItem* CListItem::Cat(CListItem *pItem)
{
    CListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

/*****************************************************************************
 * CListItem::Remove()
 *****************************************************************************
 * Remove the given list item from the list.
 */
CListItem* CListItem::Remove(CListItem *pItem)
{
    CListItem *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    ASSERT(prev != li->m_pNext); 
    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

/*****************************************************************************
 * CListItem::GetPrev()
 *****************************************************************************
 * Get the list item that precedes the given list item (if any).
 */
CListItem* CListItem::GetPrev(CListItem *pItem) const
{
    const CListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (CListItem*)prev;
}

/*****************************************************************************
 * CListItem::GetItem()
 *****************************************************************************
 * Returns nth the list item, where n is the given list index.
 */
CListItem * CListItem::GetItem(LONG index)
{
	CListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) index--;
	return (scan);
}

/*****************************************************************************
 * CList::InsertBefore()
 *****************************************************************************
 * Inserts a given list item before a second list item (which is presumed to
 * be a list member).  Inserts the given list item at the head if there is
 * no preceding list item.
 */
void CList::InsertBefore(CListItem *pItem,CListItem *pInsert)
{
	CListItem *prev = GetPrev(pItem);
	ASSERT(pInsert != pItem);
    pInsert->SetNext(pItem);
	if (prev)
    {
        ASSERT(pInsert != prev);
        prev->SetNext(pInsert);
    }
	else 
    {
        m_pHead = pInsert;
    }
}


=== ddksynth/clist.h ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//
//      clist.h
//

#ifndef __CLIST_H__
#define __CLIST_H__

/*****************************************************************************
 * class CListItem
 *****************************************************************************
 * Generic item within a CList class.
 */
class CListItem
{
public:
    CListItem() { m_pNext=NULL; };

    CListItem *GetNext() const {return m_pNext;};
    void SetNext(CListItem *pNext) {m_pNext=pNext;};
    
    LONG GetCount() const;
    BOOL IsMember(CListItem *pItem);
    
    CListItem* Cat(CListItem* pItem);
    CListItem* AddTail(CListItem* pItem) {pItem->SetNext(NULL); return Cat(pItem);};
    CListItem* Remove(CListItem* pItem);
    
    CListItem* GetPrev(CListItem *pItem) const;
    CListItem* GetItem(LONG index);

private:
    CListItem *m_pNext;
};

/*****************************************************************************
 * class CList
 *****************************************************************************
 * Generic list object (containing CListItem objects).
 */
class CList
{
public:
    CList() {m_pHead=NULL;};
    CListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    
    LONG GetCount() const {return m_pHead->GetCount();}; 
    CListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(CListItem *pItem,CListItem *pInsert);
    
    void Cat(CListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(CList *pList)
    {
        m_pHead=m_pHead->Cat(pList->GetHead());
    };
    
    void AddHead(CListItem *pItem)
    {
        ASSERT(m_pHead != pItem);
        pItem->SetNext(m_pHead);
        m_pHead=pItem;
    }
    void AddTail(CListItem *pItem) {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(CListItem *pItem) {m_pHead=m_pHead->Remove(pItem);};
    
    CListItem *GetPrev(CListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    CListItem *GetTail() const {return GetPrev(NULL);};
    
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    BOOL IsMember(CListItem *pItem) {return (m_pHead->IsMember(pItem));};

    CListItem *RemoveHead(void)
    {
        CListItem *li;
        li=m_pHead;
        if(m_pHead)
            m_pHead=m_pHead->GetNext();
        if (li)
            li->SetNext(NULL);
        return li;
    }

protected:
    CListItem *m_pHead;
};

#endif // __CLIST_H__


=== ddksynth/common.h ===
/*
    Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
*/

#ifndef _COMMON_H_
#define _COMMON_H_


#if (DBG)
#if !defined(DEBUG_LEVEL)
#define DEBUG_LEVEL DEBUGLVL_TERSE
#endif
#endif

#include <winerror.h>

/*****************************************************************************
 * Includes common to all implementation files
 *****************************************************************************/

#define PC_NEW_NAMES    1

#include <stdunk.h>
#include <portcls.h>
#include <ksdebug.h>
#include <dmusicks.h>       // Ks defines
#include <dmerror.h>        // Error codes
#include <dmdls.h>          // DLS definitions

#include "kernhelp.h"
#include "CSynth.h"
#include "synth.h"
#include "muldiv32.h"

#endif  //_COMMON_H_


=== ddksynth/control.cpp ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//      CControlLogic.cpp
//

#define STR_MODULENAME "DDKSynth.sys:Control: "

#include "common.h"

#pragma code_seg()
/*****************************************************************************
 * CControlLogic::CControlLogic()
 *****************************************************************************
 * Constructor for CControlLogic object.
 */
CControlLogic::CControlLogic()
{
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;

    m_pSynth = NULL;
	m_pInstruments = NULL;

    DWORD nIndex;
	GMReset();
	m_fGSActive = FALSE;
	m_fXGActive = FALSE;
    for (nIndex = 0;nIndex < 16;nIndex++)
    {
        m_fSustain[nIndex] = FALSE;
        m_dwProgram[nIndex] = 0;
    }
    m_fEmpty = TRUE;
}

/*****************************************************************************
 * CControlLogic::~CControlLogic()
 *****************************************************************************
 * Destructor for CControlLogic object.
 */
CControlLogic::~CControlLogic()
{
    if (m_fCSInitialized)
    {
        DeleteCriticalSection(&m_CriticalSection);
    }
}

/*****************************************************************************
 * CControlLogic::GMReset()
 *****************************************************************************
 * Performs a General MIDI reset, including resetting all the voice priorities,
 * GS, XG, master volume, etc.
 */
void CControlLogic::GMReset()
{
    static const int nPartToChannel[16] = { 
		9,0,1,2,3,4,5,6,7,8,10,11,12,13,14,15 
	};
	int nX;
	for (nX = 0; nX < 16; nX++)
	{
		int nY;
		m_nData[nX] = 0;
		m_prFineTune[nX] = 0;
		m_bDrums[nX] = 0;
		for (nY = 0; nY < 12; nY++)
		{
			m_prScaleTune[nX][nY] = 0;
		}
		m_nCurrentRPN[nX] = (short) 0x3FFF;
		m_prCoarseTune[nX] = 0;	
		m_bPartToChannel[nX] = (BYTE)nPartToChannel[nX];
		m_fMono[nX] = FALSE;
		m_dwPriority[nX] = DAUD_STANDARD_VOICE_PRIORITY + 
			((16 - nX) * DAUD_CHAN15_VOICE_PRIORITY_OFFSET);
        m_bBankH[nX] = 0;
        m_bBankL[nX] = 0;
	}
	m_bDrums[0] = 1;
	m_vrMasterVolume = 0;
	m_fGSActive = FALSE;
	m_fXGActive = FALSE;
}

/*****************************************************************************
 * CControlLogic::Init()
 *****************************************************************************
 * Initialize the CControlLogic object, and initialize all the child objects --
 * Note recorders, ModWheels, Volumes, Pan, Expression, PitchBend.
 */
HRESULT CControlLogic::Init(CInstManager *pInstruments, CSynth *pSynth)
{
	m_pSynth = pSynth;
	m_pInstruments = pInstruments;
    m_vrGainAdjust = 0;

    m_Notes.Init();

    int iRecIdx;
    for (iRecIdx = 0; iRecIdx < sizeof(m_ModWheel) / sizeof(*m_ModWheel); iRecIdx++)
    {
        m_ModWheel[iRecIdx].Init();
    }
    for (iRecIdx = 0; iRecIdx < sizeof(m_PitchBend) / sizeof(*m_PitchBend); iRecIdx++)
    {
        m_PitchBend[iRecIdx].Init();
    }
    for (iRecIdx = 0; iRecIdx < sizeof(m_Volume) / sizeof(*m_Volume); iRecIdx++)
    {
        m_Volume[iRecIdx].Init();
    }
    for (iRecIdx = 0; iRecIdx < sizeof(m_Expression) / sizeof(*m_Expression); iRecIdx++)
    {
        m_Expression[iRecIdx].Init();
    }
    for (iRecIdx = 0; iRecIdx < sizeof(m_Pan) / sizeof(*m_Pan); iRecIdx++)
    {
        m_Pan[iRecIdx].Init();
    }

	return S_OK;
}

/*****************************************************************************
 * CControlLogic::ClearMIDI()
 *****************************************************************************
 * Clears MIDI up to a certain time, and updates m_fEmpty.
 */
void CControlLogic::ClearMIDI(STIME stEndTime)
{
	DWORD dwIndex;
	::EnterCriticalSection(&m_CriticalSection);
    if (!m_fEmpty)
    {        
        m_fEmpty = TRUE;
        for (dwIndex = 0;dwIndex < 16; dwIndex++)
        {
            m_fEmpty = m_ModWheel[dwIndex].ClearMIDI(stEndTime)
                && m_PitchBend[dwIndex].ClearMIDI(stEndTime)
                && m_Volume[dwIndex].ClearMIDI(stEndTime)
                && m_Expression[dwIndex].ClearMIDI(stEndTime)
                && m_Pan[dwIndex].ClearMIDI(stEndTime);
        }
    }
	::LeaveCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CControlLogic::SetGainAdjust()
 *****************************************************************************
 * Sets the overall gain for this CControlLogic.
 */
void CControlLogic::SetGainAdjust(VREL vrGainAdjust)
{
    m_vrGainAdjust = vrGainAdjust;
}

/*****************************************************************************
 * CControlLogic::QueueNotes()
 *****************************************************************************
 * Retrieves notes from the note recorders, and dispatches them appropriately.
 * Called during the Mix.
 */
void CControlLogic::QueueNotes(STIME stEndTime)
{
    CNote note;
    
    while (m_Notes.GetNote(stEndTime,&note))
    {
		if (note.m_bKey > 0x7F)	// Special command events.
		{
			long lTemp;
			DWORD dwPart = note.m_bPart;
			DWORD dwCommand = note.m_bKey;
			BYTE bData = note.m_bVelocity;
			switch (dwCommand)
			{
            case NOTE_PROGRAMCHANGE:
                m_dwProgram[dwPart] = bData |
                    (m_bBankH[dwPart] << 16) | 
                    (m_bBankL[dwPart] << 8);
                break;
			case NOTE_CC_BANKSELECTH:
				m_bBankH[dwPart] = bData;
				break;
			case NOTE_CC_BANKSELECTL:
				m_bBankL[dwPart] = bData;
				break;
			case NOTE_CC_POLYMODE:
				m_fMono[dwPart] = FALSE;
				break;
			case NOTE_CC_MONOMODE:
				m_fMono[dwPart] = TRUE;
				break;
			case NOTE_CC_RPN_MSB:
				m_nCurrentRPN[dwPart] = (m_nCurrentRPN[dwPart] & 0x7f) + (bData << 7);
				break;
			case NOTE_CC_RPN_LSB:
				m_nCurrentRPN[dwPart] = (m_nCurrentRPN[dwPart] & 0x3f80) + bData;
				break;
			case NOTE_CC_NRPN:
				m_nCurrentRPN[dwPart] = 0x3FFF;
				break;
			case NOTE_CC_DATAENTRYLSB:
				m_nData[dwPart] &= ~0x7F;
				m_nData[dwPart] |= bData;
				switch (m_nCurrentRPN[dwPart])
				{
				case RPN_PITCHBEND: // Don't do anything, Roland ignores lsb
					break;
				case RPN_FINETUNE:
					lTemp = m_nData[dwPart];
					lTemp -= 8192;
					lTemp *= 100;
					lTemp /= 8192;
					m_prFineTune[dwPart] = lTemp;
					break;
				case RPN_COARSETUNE: // Ignore lsb
					break;            
				}
				break;
			case NOTE_CC_DATAENTRYMSB:
				m_nData[dwPart] &= ~(0x7F << 7);
				m_nData[dwPart] |= bData << 7;
				switch (m_nCurrentRPN[dwPart])
				{
				case RPN_PITCHBEND:
					m_PitchBend[dwPart].m_prRange = bData * 100;
					break;
				case RPN_FINETUNE:
					lTemp = m_nData[dwPart];
					lTemp -= 8192;
					lTemp *= 100;
					lTemp /= 8192;
					m_prFineTune[dwPart] = lTemp;
					break;
				case RPN_COARSETUNE:
					m_prCoarseTune[dwPart] = 100 * (bData - 64);
					break;        
				}
				break;
			case NOTE_SUSTAIN: // special sustain marker
	            m_fSustain[dwPart] = (BOOL) bData;
				if (bData == FALSE)
				{
					CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
					for (;pVoice != NULL;pVoice = pVoice->GetNext())
					{
						if (pVoice->m_fSustainOn &&
							(pVoice->m_nPart == dwPart) &&
							(pVoice->m_pControl == this))
						{
							pVoice->StopVoice(note.m_stTime);
						}
					}
				} 
				break;
			case NOTE_ALLOFF:
				{
					CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
					for (;pVoice != NULL; pVoice = pVoice->GetNext())
					{
						if (pVoice->m_fNoteOn && !pVoice->m_fSustainOn &&
							(pVoice->m_nPart == dwPart) &&
							(pVoice->m_pControl == this))
						{
							if (m_fSustain[dwPart])
							{
								pVoice->m_fSustainOn = TRUE;
							}
							else
							{
								pVoice->StopVoice(note.m_stTime);
							}
						}
					}
				}
				break;
			case NOTE_SOUNDSOFF:
				{
					CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
					for (;pVoice != NULL; pVoice = pVoice->GetNext())
					{
						if (pVoice->m_fNoteOn &&
							(pVoice->m_nPart == dwPart) &&
							(pVoice->m_pControl == this))
						{
							pVoice->StopVoice(note.m_stTime);
						}
					}
				}
				break;
			case NOTE_ASSIGNRECEIVE:
				m_bPartToChannel[dwPart] = (BYTE) bData;
				break;
			case NOTE_MASTERVOLUME:
				m_vrMasterVolume = CMIDIRecorder::VelocityToVolume(bData);
				break;
			}
		}
        else if (note.m_bVelocity == 0)  // Note Off.
        {
            CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
            WORD nPart = note.m_bPart;
            for (;pVoice != NULL;pVoice = pVoice->GetNext())
            {
                if (pVoice->m_fNoteOn && !pVoice->m_fSustainOn &&
                    (pVoice->m_nKey == (WORD) note.m_bKey) &&
                    (pVoice->m_nPart == nPart) &&
					(pVoice->m_pControl == this)) 
                {
                    if (m_fSustain[nPart])
                    {
                        pVoice->m_fSustainOn = TRUE;
                    }
                    else
                    {
                        pVoice->StopVoice(note.m_stTime);
                    }
                    break;
                }
            }
        }
        else   // Note On.
        {
            DWORD dwProgram = m_dwProgram[note.m_bPart];
            if (m_bDrums[note.m_bPart])
            {
                dwProgram |= F_INSTRUMENT_DRUMS;
            }
			if (m_fMono[note.m_bPart])
			{
				CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
				WORD nPart = note.m_bPart;
				for (;pVoice != NULL;pVoice = pVoice->GetNext())
				{
					if (pVoice->m_fNoteOn && (pVoice->m_nPart == nPart) &&
						(pVoice->m_pControl == this)) 
					{
						pVoice->StopVoice(note.m_stTime);
					}
				}
			}
			// While we are working with the instrument, including copying
			// the data over from the region, we have to make sure it
			// can not be removed from the instrument list.
			EnterCriticalSection(&m_pInstruments->m_CriticalSection);
            CInstrument * pInstrument = 
                m_pInstruments->GetInstrument(dwProgram,note.m_bKey);
            if (!pInstrument) 
			{
				if (dwProgram & F_INSTRUMENT_DRUMS)
				{
					dwProgram = F_INSTRUMENT_DRUMS;
					pInstrument = 
						m_pInstruments->GetInstrument(dwProgram,note.m_bKey);
				}
				else if (m_fXGActive)
				{
					if ((dwProgram & 0x7F0000) == 0x7F0000)	// Drum?
					{
						dwProgram &= 0x7F007F;				// Enforce 0 LSB
						pInstrument = 
							m_pInstruments->GetInstrument(dwProgram,note.m_bKey);
                        if (!pInstrument)
                        {
                            dwProgram = 0x7F0000;
						    pInstrument = 
							    m_pInstruments->GetInstrument(dwProgram,note.m_bKey);
                        }
					}
                    else
                    {
						dwProgram &= 0x7F;	// Fall back to GM set.
						pInstrument = 
							m_pInstruments->GetInstrument(dwProgram,note.m_bKey);
					}
				}
			}
            if (pInstrument != NULL)
            {
                CSourceRegion * pRegion = 
                    pInstrument->ScanForRegion(note.m_bKey);
                if (pRegion != NULL)
                {
                    WORD nPart = note.m_bPart;
                    CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
                    if (!pRegion->m_bAllowOverlap)
                    {
                        for (;pVoice != NULL; pVoice = pVoice->GetNext())
                        {
                            if ((pVoice->m_nPart == nPart) &&
                                (pVoice->m_nKey == note.m_bKey) &&
								(pVoice->m_pControl == this))
                            {
                                pVoice->QuickStopVoice(note.m_stTime);
                            }
                        }    
                    }

                    if (pRegion->m_bGroup != 0)
                    {
                        pVoice = m_pSynth->m_VoicesInUse.GetHead();
                        for (;pVoice != NULL;pVoice = pVoice->GetNext())
                        {
                            if ((pVoice->m_dwGroup == pRegion->m_bGroup) &&
                                (pVoice->m_nPart == nPart) &&
                                (pVoice->m_dwProgram == dwProgram) &&
								(pVoice->m_pControl == this))
                            {
                                pVoice->QuickStopVoice(note.m_stTime);
                            }
                        }
                    }
                    
                    pVoice = m_pSynth->m_VoicesFree.RemoveHead();
                    if (pVoice == NULL)
                    {
                        pVoice = m_pSynth->m_VoicesExtra.RemoveHead();
                    }

                    if (pVoice == NULL)
                    {
                        pVoice = m_pSynth->StealVoice(m_dwPriority[nPart]);
                    }

                    if (pVoice != NULL)
                    {
						PREL prPitch = m_prFineTune[nPart] + m_prScaleTune[nPart][note.m_bKey % 12];
						if (!m_bDrums[nPart]) 
						{
							if (m_fXGActive)
							{
								if ((dwProgram & 0x7F0000) != 0x7F0000)
								{
									prPitch += m_prCoarseTune[nPart];
								}
							}
							else
							{
								prPitch += m_prCoarseTune[nPart];
							}
                        }
						pVoice->m_nKey = note.m_bKey;
                        pVoice->m_nPart = nPart;
                        pVoice->m_dwProgram = dwProgram;
                        pVoice->m_dwPriority = m_dwPriority[nPart];
						pVoice->m_pControl = this;

                        if (pVoice->StartVoice( m_pSynth,
                                                pRegion, note.m_stTime, 
                                                &m_ModWheel[nPart],     
                                                &m_PitchBend[nPart],
                                                &m_Expression[nPart],   
                                                &m_Volume[nPart],
                                                &m_Pan[nPart],          
                                                (WORD)note.m_bKey,
							                    (WORD)note.m_bVelocity, 
                                                m_vrMasterVolume, 
							                    prPitch))
                        {
                            pVoice->m_fInUse = TRUE;

                            m_pSynth->QueueVoice(pVoice);
                        }
                        else
                        {
                            m_pSynth->m_VoicesFree.AddHead(pVoice);
                        }
                    } 
                    else 
                    {
                        m_pSynth->m_BuildStats.dwNotesLost++;
                    }
                } 
                else 
                {
                    m_pSynth->m_BuildStats.dwNotesLost++;
                }
            } 
            else 
            {
                Trace(1, "No instrument/region was found for patch # %lx, note %ld\n",
                          dwProgram, (long) note.m_bKey);
            }
			LeaveCriticalSection(&m_pInstruments->m_CriticalSection);
        }
    }
}

/*****************************************************************************
 * CControlLogic::Flush()
 *****************************************************************************
 * Clears events and notes up to a given time.
 */
void CControlLogic::Flush(STIME stTime)
{
    DWORD dwIndex;
    ::EnterCriticalSection(&m_CriticalSection);
    if (!m_fEmpty)
    {        
        m_fEmpty = TRUE;
        for (dwIndex = 0;dwIndex < 16; dwIndex++)
        {
            m_fEmpty = m_ModWheel[dwIndex].FlushMIDI(stTime)
                && m_PitchBend[dwIndex].FlushMIDI(stTime)
                && m_Volume[dwIndex].FlushMIDI(stTime)
                && m_Expression[dwIndex].FlushMIDI(stTime)
                && m_Pan[dwIndex].FlushMIDI(stTime);
        }
        m_Notes.FlushMIDI(stTime);
    }
    ::LeaveCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CControlLogic::RecordMIDI()
 *****************************************************************************
 * Record a MIDI short message into this channel group.  
 * This dispatches the different MIDI
 * messages to the different receptor objects.
 */
BOOL CControlLogic::RecordMIDI(STIME stTime,BYTE bStatus, BYTE bData1, BYTE bData2)
{
    WORD nPreChannel = bStatus & 0xF; 
    CNote note;
    bStatus = bStatus & 0xF0;
    BOOL bReturn = TRUE;
	WORD nPart;

    ::EnterCriticalSection(&m_CriticalSection);

    for (nPart = 0;nPart < 16; nPart++)
	{
		if (nPreChannel == m_bPartToChannel[nPart])
		{
			switch (bStatus)
			{
			case MIDI_NOTEOFF :
				bData2 = 0;
			case MIDI_NOTEON :
				note.m_bPart = (BYTE) nPart;
				note.m_bKey = bData1;
				note.m_bVelocity = bData2;
				bReturn = m_Notes.RecordNote(stTime,&note);
				break;
			case MIDI_CCHANGE :
				switch (bData1)
				{
				case CC_BANKSELECTH :
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_BANKSELECTH, bData2);
					break;
				case CC_MODWHEEL :
                    m_fEmpty = FALSE;
					bReturn = m_ModWheel[nPart].RecordMIDI(stTime,(long) bData2);
					break;
				case CC_VOLUME :
                    m_fEmpty = FALSE;
					bReturn = m_Volume[nPart].RecordMIDI(stTime,(long) bData2);
					break;
				case CC_PAN :
                    m_fEmpty = FALSE;
					bReturn = m_Pan[nPart].RecordMIDI(stTime,(long) bData2);
					break;
				case CC_EXPRESSION :
                    m_fEmpty = FALSE;
					bReturn = m_Expression[nPart].RecordMIDI(stTime,(long)bData2);
					break;
				case CC_BANKSELECTL :
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_BANKSELECTL, bData2);
					break;
				case CC_RESETALL:
                    m_fEmpty = FALSE;
					if (bData2)
					{
						bReturn = bReturn && m_Volume[nPart].RecordMIDI(stTime, 100);
						bReturn = bReturn && m_Pan[nPart].RecordMIDI(stTime, 64);
					}
					bReturn = bReturn && m_Expression[nPart].RecordMIDI(stTime, 127);
					bReturn = bReturn && m_PitchBend[nPart].RecordMIDI(stTime, 0x2000);
					bReturn = m_ModWheel[nPart].RecordMIDI(stTime, 0);
					bData2 = 0;
					// fall through into Sustain Off case....
        
				case CC_SUSTAIN :
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SUSTAIN, bData2);
					break;
				case CC_ALLSOUNDSOFF:
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
					break;
				case CC_ALLNOTESOFF:
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_ALLOFF, 0);
					break;
				case CC_DATAENTRYMSB:
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_DATAENTRYMSB, bData2);
					break;
				case CC_DATAENTRYLSB:
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_DATAENTRYLSB, bData2);
					break;
				case CC_NRPN_LSB :
				case CC_NRPN_MSB :
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_NRPN, bData2);
					break;
				case CC_RPN_LSB:
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_RPN_LSB, bData2);
					break; 
				case CC_RPN_MSB:
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_RPN_MSB, bData2);
					break;
				case CC_MONOMODE :
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_MONOMODE, bData2);
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
					break;
				case CC_POLYMODE :
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_POLYMODE, bData2);
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
					break;
				default:
					break;
				}
				break;

			case MIDI_PCHANGE :
				bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_PROGRAMCHANGE, bData1);
				break;
        
			case MIDI_PBEND :
                m_fEmpty = FALSE;
				{
					WORD nBend;
					nBend = bData2 << 7;
					nBend |= bData1;
					bReturn = m_PitchBend[nPart].RecordMIDI(stTime,(long)nBend);
				}
				break;
			}
		}
	}
    ::LeaveCriticalSection(&m_CriticalSection);

    return bReturn;
}

/*****************************************************************************
 * CControlLogic::RecordSysEx()
 *****************************************************************************
 * Record a MIDI SysEx message into this channel group.  
 * This dispatches the different MIDI
 * messages to the different receptor objects.
 */
HRESULT	CControlLogic::RecordSysEx(DWORD dwSysExLength,BYTE *pSysExData, STIME stTime)
{
	HRESULT hSuccess = S_OK;
	int nPart;
	int nTune;
	DWORD dwAddress;
	
    BOOL fClearAll = FALSE;
	BOOL fResetPatches = FALSE;
	if (dwSysExLength < 6)
    {
        return E_FAIL;
    }

	switch (pSysExData[1])	// ID number
	{
	case 0x7E :	// General purpose ID
		if (pSysExData[3] == 0x09) 
		{
			GMReset();
			fClearAll = TRUE;
			fResetPatches = TRUE;
		}
		break;
	case 0x7F : // Real time ID
		if (pSysExData[3] == 0x04)
		{
			if (pSysExData[4] == 1)	// Master Volume
			{
				m_Notes.RecordEvent(stTime, 0, NOTE_MASTERVOLUME, pSysExData[6]);
			}
		}
		break;
	case 0x41 : // Roland
		if (dwSysExLength < 11)
        {
            return E_FAIL;
        }
		if (pSysExData[3] != 0x42) break;
		if (pSysExData[4] != 0x12) break;
		nPart = pSysExData[6] & 0xF;
		dwAddress = (pSysExData[5] << 16) |
			((pSysExData[6] & 0xF0) << 8) | pSysExData[7];
		switch (dwAddress)
		{
		case 0x40007F :		// GS Reset.
			GMReset();
			m_fXGActive = FALSE;
			fClearAll = TRUE;
			m_fGSActive = TRUE;
			fResetPatches = TRUE;
			break;
		case 0x401002 :		// Set Receive Channel.
			if (m_fGSActive)
			{
				if (pSysExData[8])
				{
					m_Notes.RecordEvent(stTime, nPart, NOTE_ASSIGNRECEIVE, pSysExData[8] - 1);
				}
			}
			break;
		case 0x401015 :		// Use for Rhythm.
			if (m_fGSActive)
			{
				m_bDrums[nPart] = pSysExData[8];
				fClearAll = TRUE;
			}
			break;
		case 0x401040 :		// Scale Tuning.
			if (m_fGSActive)
			{
				for (nTune = 0;nTune < 12; nTune++)
				{
					if (pSysExData[9 + nTune] & 0x80) break;
					m_prScaleTune[nPart][nTune] = 
						(PREL) pSysExData[8 + nTune] - (PREL) 64;
				}
			}
			break;
		}
		break;
	case 0x43 : // Yamaha
		if ((pSysExData[3] == 0x4C) &&
			(pSysExData[4] == 0) &&
			(pSysExData[5] == 0) &&
			(pSysExData[6] == 0x7E) &&
			(pSysExData[7] == 0))
		{	// XG System On
			m_fXGActive = TRUE;
			m_fGSActive = FALSE;
			GMReset();
			m_fXGActive = TRUE;
			m_bDrums[0] = 0;
			m_bBankH[0] = 127;
			fClearAll = TRUE;
			fResetPatches = TRUE;
		}
		break;
	}
	if (fClearAll)
	{
		m_pSynth->AllNotesOff();
		Flush(0);
		for (nPart = 0;nPart < 16;nPart++)
		{        
			m_Notes.RecordEvent(stTime, nPart, NOTE_SUSTAIN, 0);
			m_Volume[nPart].RecordMIDI(stTime, 100);
			m_Pan[nPart].RecordMIDI(stTime, 64);
			m_Expression[nPart].RecordMIDI(stTime, 127);
			m_PitchBend[nPart].RecordMIDI(stTime, 0x2000);
			m_ModWheel[nPart].RecordMIDI(stTime, 0);
		}
	}
	if (fResetPatches)
	{
		for (nPart = 0;nPart < 16;nPart++)
		{     
			if ((nPart == 0) && (m_fXGActive))
			{
				m_Notes.RecordEvent(stTime-1, nPart, NOTE_CC_BANKSELECTH, 127);
			}
			else
			{
				m_Notes.RecordEvent(stTime-1, nPart, NOTE_CC_BANKSELECTH, 0);
			}
			m_Notes.RecordEvent(stTime-1, nPart, NOTE_CC_BANKSELECTL, 0);
			m_Notes.RecordEvent(stTime, nPart, NOTE_PROGRAMCHANGE, 0);
		}
	}

	return hSuccess;
}

/*****************************************************************************
 * CControlLogic::SetChannelPriority()
 *****************************************************************************
 * Set the priority for a given channel, within this channel group.
 */
HRESULT	CControlLogic::SetChannelPriority(DWORD dwChannel,DWORD dwPriority)
{
    DWORD dwPart;
	for (dwPart = 0;dwPart < 16; dwPart++)
	{
		if (m_bPartToChannel[dwPart] == dwChannel)
		{
        	m_dwPriority[dwPart] = dwPriority;
        }
	}
	return S_OK;
}

/*****************************************************************************
 * CControlLogic::GetChannelPriority()
 *****************************************************************************
 * Retrieve the priority for a given channel, within this channel group.
 */
HRESULT	CControlLogic::GetChannelPriority(DWORD dwChannel,LPDWORD pdwPriority)
{
    DWORD dwPart;
	for (dwPart = 0;dwPart < 16; dwPart++)
	{
		if (m_bPartToChannel[dwPart] == dwChannel)
		{
        	*pdwPriority = m_dwPriority[dwPart];
			break;
        }
	}
	return S_OK;
}


=== ddksynth/csynth.cpp ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//      CSynth.cpp
//

#include "common.h"

#define STR_MODULENAME "DDKSynth.sys:CSynth: "



#pragma code_seg()
/*****************************************************************************
 * CSynth::CSynth()
 *****************************************************************************
 * Contructor for CSynth object.  Initialize the voice list, the stereo mode,
 * sample rate, performance statistics, etc.
 */
CSynth::CSynth()
{
    DWORD nIndex;
    CVoice *pVoice;

    m_fCSInitialized = FALSE;
    ::InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;

    for (nIndex = 0;nIndex < MAX_NUM_VOICES;nIndex++)
    {
        pVoice = new CVoice;
        if (pVoice != NULL)
        {
            m_VoicesFree.AddHead(pVoice);
        }
    }
    for (nIndex = 0;nIndex < NUM_EXTRA_VOICES;nIndex++)
    {
        pVoice = new CVoice;
        if (pVoice != NULL)
        {
            m_VoicesExtra.AddHead(pVoice);
        }
    }
	m_ppControl = NULL;
	m_dwControlCount = 0;
    m_nMaxVoices = MAX_NUM_VOICES;
    m_nExtraVoices = NUM_EXTRA_VOICES; 
    m_stLastStats = 0;
    m_fAllowPanWhilePlayingNote = TRUE;
    m_fAllowVolumeChangeWhilePlayingNote = TRUE;
    ResetPerformanceStats();
    m_dwSampleRate = 22050;
    m_dwStereo = 1;
	m_stLastTime = 0;    
	SetSampleRate(SAMPLE_RATE_22);
    SetStereoMode(2);
    SetGainAdjust(600);
}

/*****************************************************************************
 * CSynth::~CSynth()
 *****************************************************************************
 * Destructor for CSynth object.  Delete the voices in the lists.
 */
CSynth::~CSynth()
{
    CVoice *pVoice;
    if (m_fCSInitialized)
    {
        // If CS never initialized, nothing else will have been set up
        //
        Close();

        while (pVoice = m_VoicesInUse.RemoveHead())
        {
            delete pVoice;
        }
        while (pVoice = m_VoicesFree.RemoveHead())
        {
            delete pVoice;
        }
        while (pVoice = m_VoicesExtra.RemoveHead())
        {
            delete pVoice;
        }
        DeleteCriticalSection(&m_CriticalSection);
    }
}

/*****************************************************************************
 * ChangeVoiceCount()
 *****************************************************************************
 * Change the number of voices in a given voice list.
 */
static short ChangeVoiceCount(CVoiceList *pList,short nOld,short nCount)
{
    if (nCount > nOld)
    {
        short nNew = nCount - nOld;
        for (;nNew != 0; nNew--)
        {
            CVoice *pVoice = new CVoice;
            if (pVoice != NULL)
            {
                pList->AddHead(pVoice);
            }
        }
    }
    else
    {
        short nNew = nOld - nCount;
        for (;nNew > 0; nNew--)
        {
            CVoice *pVoice = pList->RemoveHead();
            if (pVoice != NULL)
            {
                delete pVoice;
            }
            else 
            {
                nCount += nNew;
                break;
            }
        }
    }
    return nCount;
}

/*****************************************************************************
 * CSynth::SetMaxVoices()
 *****************************************************************************
 * Set the maximum number of voices available.
 */
HRESULT CSynth::SetMaxVoices(short nVoices,short nTempVoices)
{
    if (nVoices < 1)
    {
        nVoices = 1;
    }
    if (nTempVoices < 1)
    {
        nTempVoices = 1;
    }
    ::EnterCriticalSection(&m_CriticalSection);
    m_nMaxVoices = ChangeVoiceCount(&m_VoicesFree,m_nMaxVoices,nVoices);
    m_nExtraVoices = ChangeVoiceCount(&m_VoicesExtra,m_nExtraVoices,nTempVoices);
    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

/*****************************************************************************
 * CSynth::SetNumChannelGroups()
 *****************************************************************************
 * Set the number of channel groups (virtual MIDI cables).  For each channel 
 * group, there is a separate CControlLogic object.
 */
HRESULT CSynth::SetNumChannelGroups(DWORD dwCableCount)
{
	HRESULT hr = S_OK;
	CControlLogic **ppControl;
	if ((dwCableCount < 1) || (dwCableCount > MAX_CHANNEL_GROUPS))
	{
		return E_INVALIDARG;
	}

    ::EnterCriticalSection(&m_CriticalSection);
	if (m_dwControlCount != dwCableCount)
	{
		ppControl = new(NonPagedPool,'PSmD') CControlLogic *[dwCableCount]; //  DmSP
		if (ppControl)
		{
			DWORD dwX;
			for (dwX = 0; dwX < dwCableCount; dwX++)
			{
				ppControl[dwX] = NULL;
			}
			if (m_dwControlCount < dwCableCount)
			{
				for (dwX = 0; dwX < m_dwControlCount; dwX++)
				{
					ppControl[dwX] = m_ppControl[dwX];
				}
				for (;dwX < dwCableCount; dwX++)
				{
					ppControl[dwX] = new(NonPagedPool,'CSmD') CControlLogic;    //  DmSC
					if (ppControl[dwX])
					{
						hr = ppControl[dwX]->Init(&m_Instruments, this);
						if (FAILED(hr))
						{
							delete ppControl[dwX];
							ppControl[dwX] = NULL;
							dwCableCount = dwX;
							break;
						}

                        ppControl[dwX]->SetGainAdjust(m_vrGainAdjust);
					}
					else
					{
						dwCableCount = dwX;
						break;
					}
				}
			}
			else
			{
				AllNotesOff();
				for (dwX = 0; dwX < dwCableCount; dwX++)
				{
					ppControl[dwX] = m_ppControl[dwX];
				}
				for (; dwX < m_dwControlCount; dwX++)
				{
					if (m_ppControl[dwX])
					{
						delete m_ppControl[dwX];
					}
				}
			}
			if (m_ppControl)
			{
				delete m_ppControl;
			}
			m_ppControl = ppControl;
			m_dwControlCount = dwCableCount;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

	}
    ::LeaveCriticalSection(&m_CriticalSection);
    
	return hr;
}

/*****************************************************************************
 * CSynth::SetGainAdjust()
 *****************************************************************************
 * Set the gain for the overall synth.  Set gain on each CControlLogic object.
 */
void CSynth::SetGainAdjust(VREL vrGainAdjust)
{
    DWORD idx;

    m_vrGainAdjust = vrGainAdjust;
	::EnterCriticalSection(&m_CriticalSection);
    
    for (idx = 0; idx < m_dwControlCount; idx++)
    {
        m_ppControl[idx]->SetGainAdjust(m_vrGainAdjust);
    }

    ::LeaveCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CSynth::Open()
 *****************************************************************************
 * Open the synth with the given number of channel groups.
 */
HRESULT CSynth::Open(DWORD dwCableCount, DWORD dwVoices)
{
	HRESULT hr = S_OK;
	if ((dwCableCount < 1) || (dwCableCount > MAX_CHANNEL_GROUPS))
	{
		return E_INVALIDARG;
	}
	if (m_ppControl)
	{
		return E_FAIL;	// Already opened.
	}
    ::EnterCriticalSection(&m_CriticalSection);
	hr = SetNumChannelGroups(dwCableCount);
	if (SUCCEEDED(hr))
	{
		short nTemp = (short) dwVoices / 4;
		if (nTemp < 4) nTemp = 4;
		SetMaxVoices((short) dwVoices, nTemp);
	}


    m_vrGainAdjust = 0;
    ::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}

/*****************************************************************************
 * CSynth::Close()
 *****************************************************************************
 * Close down the synth:, silence it, delete the list of CControlLogic objects.
 */
HRESULT CSynth::Close()
{
    ::EnterCriticalSection(&m_CriticalSection);
	AllNotesOff();
	DWORD dwX;
	for (dwX = 0; dwX < m_dwControlCount; dwX++)
	{
		if (m_ppControl[dwX])
		{
			delete m_ppControl[dwX];
		}
	}
	m_dwControlCount = 0;
	if (m_ppControl)
	{
		delete [] m_ppControl;
		m_ppControl = NULL;
	}
    m_stLastStats = 0;
	m_stLastTime = 0;


    ::LeaveCriticalSection(&m_CriticalSection);
	return S_OK;
}
   
/*****************************************************************************
 * CSynth::GetMaxVoices()
 *****************************************************************************
 * Returns the maximum number of voices available.
 */
HRESULT CSynth::GetMaxVoices( 
    short * pnMaxVoices,    // Returns maximum number of allowed voices for continuous play.
    short * pnTempVoices )  // Returns number of extra voices for voice overflow.
{
    if (pnMaxVoices != NULL)
    {
        *pnMaxVoices = m_nMaxVoices;
    }
    if (pnTempVoices != NULL)
    {
        *pnTempVoices = m_nExtraVoices;
    }
    return S_OK;
}

/*****************************************************************************
 * CSynth::SetSampleRate()
 *****************************************************************************
 * Set the sample rate of the synth.  This silences the synth.  The SR is 
 * forwarded to the instrument manager.
 */
HRESULT CSynth::SetSampleRate(DWORD dwSampleRate)     
{
    HRESULT hr = S_OK;
	::EnterCriticalSection(&m_CriticalSection);
	AllNotesOff();
	m_stLastTime *= dwSampleRate;
	m_stLastTime /= m_dwSampleRate;
	// m_stLastTime = MulDiv(m_stLastTime,dwSampleRate,m_dwSampleRate);
	m_stLastStats = 0;
	m_dwSampleRate = dwSampleRate;
	m_stMinSpan = dwSampleRate / 100;   // 10 ms.
	m_stMaxSpan = (dwSampleRate + 19) / 20;    // 50 ms.
	::LeaveCriticalSection(&m_CriticalSection);
	m_Instruments.SetSampleRate(dwSampleRate);
    return hr;
}

/*****************************************************************************
 * CSynth::Activate()
 *****************************************************************************
 * Make the synth active.
 */
HRESULT CSynth::Activate(DWORD dwSampleRate, DWORD dwChannels )
{
	m_stLastTime = 0;
	SetSampleRate(dwSampleRate);
	SetStereoMode(dwChannels);
	ResetPerformanceStats();
	return S_OK;
}

/*****************************************************************************
 * CSynth::Deactivate()
 *****************************************************************************
 * Gag the synth.
 */
HRESULT CSynth::Deactivate()
{
	AllNotesOff();
	return S_OK;
}

/*****************************************************************************
 * CSynth::GetPerformanceStats()
 *****************************************************************************
 * Get the latest perf statistics.
 */
HRESULT CSynth::GetPerformanceStats(PerfStats *pStats)
{
    if (pStats == NULL)
    {
        return E_POINTER;
    }
    *pStats = m_CopyStats;
    return (S_OK);
}

/*****************************************************************************
 * CSynth::Mix()
 *****************************************************************************
 * Mix into the given buffer.  This is called by Render in the software
 * synth case, or this could be called by a request from hardware.
 */
void CSynth::Mix(short *pBuffer,DWORD dwLength,LONGLONG llPosition)
{
    PAGED_CODE();

    STIME stEndTime;
    CVoice *pVoice;
    CVoice *pNextVoice;
    long lNumVoices = 0;
    ::EnterCriticalSection(&m_CriticalSection);

    LONG    lTime = - (LONG)::GetTheCurrentTime();

    stEndTime = llPosition + dwLength;
	StealNotes(stEndTime);
	DWORD dwX;
	for (dwX = 0; dwX < m_dwControlCount; dwX++)
	{
		m_ppControl[dwX]->QueueNotes(stEndTime);
	}
    pVoice = m_VoicesInUse.GetHead();
    for (;pVoice != NULL;pVoice = pNextVoice)
    {
        pNextVoice = pVoice->GetNext();

        pVoice->Mix(pBuffer,dwLength,llPosition,stEndTime);
        lNumVoices++;

        if (pVoice->m_fInUse == FALSE) 
        {
            m_VoicesInUse.Remove(pVoice);
            m_VoicesFree.AddHead(pVoice);
           // m_BuildStats.dwTotalSamples += (pVoice->m_stStopTime - pVoice->m_stStartTime);
			if (pVoice->m_stStartTime < m_stLastStats)
			{
				m_BuildStats.dwTotalSamples += (long) (pVoice->m_stStopTime - m_stLastStats);
			}
			else
			{
				m_BuildStats.dwTotalSamples += (long) (pVoice->m_stStopTime - pVoice->m_stStartTime);
			}
        }
    }
	for (dwX = 0; dwX < m_dwControlCount; dwX++)
	{
		m_ppControl[dwX]->ClearMIDI(stEndTime);
	}
    FinishMix(pBuffer,dwLength);
    if (stEndTime > m_stLastTime)
    {
        m_stLastTime = stEndTime;
    }
    lTime += ::GetTheCurrentTime();

    m_BuildStats.dwTotalTime += lTime;

    if ((m_stLastStats + m_dwSampleRate) <= m_stLastTime)
    {
        DWORD dwElapsed = (DWORD) (m_stLastTime - m_stLastStats);
		pVoice = m_VoicesInUse.GetHead();
		for (;pVoice != NULL;pVoice = pVoice->GetNext())
		{
			if (pVoice->m_stStartTime < m_stLastStats)
			{
				m_BuildStats.dwTotalSamples += dwElapsed;
			}
			else
			{
				m_BuildStats.dwTotalSamples += (long) (m_stLastTime - pVoice->m_stStartTime);
			}
		}
        if (dwElapsed == 0) dwElapsed = 1;
        if (m_BuildStats.dwTotalSamples == 0) m_BuildStats.dwTotalSamples = 1;
        m_BuildStats.dwVoices = 
            (m_BuildStats.dwTotalSamples + (dwElapsed >> 1)) / dwElapsed;
		{
			m_BuildStats.dwCPU = MulDiv(m_BuildStats.dwTotalTime,
				m_dwSampleRate, dwElapsed);
		}
        m_CopyStats = m_BuildStats;
        RtlZeroMemory(&m_BuildStats, sizeof(m_BuildStats));
        m_stLastStats = m_stLastTime;
    }
    ::LeaveCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CSynth::OldestVoice()
 *****************************************************************************
 * Get the most likely candidate to be shut down, to support voice stealing.
 * Priority is looked at first, then age.
 */
CVoice *CSynth::OldestVoice()
{
    CVoice *pVoice;
    CVoice *pBest = NULL;
    pVoice = m_VoicesInUse.GetHead();
    pBest = pVoice;
    if (pBest)
    {
        pVoice = pVoice->GetNext();
        for (;pVoice;pVoice = pVoice->GetNext())
        {
		    if (!pVoice->m_fTag)
		    {
			    if (pBest->m_fTag)
			    {
				    pBest = pVoice;
			    }
			    else
			    {
                    if (pVoice->m_dwPriority <= pBest->m_dwPriority)
                    {
				        if (pVoice->m_fNoteOn) 
				        {
					        if (pBest->m_fNoteOn)
					        {
						        if (pBest->m_stStartTime > pVoice->m_stStartTime)
						        {
							        pBest = pVoice;
						        }
					        }
				        }
				        else
				        {
					        if (pBest->m_fNoteOn ||
						        (pBest->m_vrVolume > pVoice->m_vrVolume))
					        {
						        pBest = pVoice;
					        }
				        }
                    }
			    }
		    }
        }
        if (pBest->m_fTag)
        {
            pBest = NULL;
        }
    }
    return pBest;
}

/*****************************************************************************
 * CSynth::StealVoice()
 *****************************************************************************
 * Steal a voice, if possible.  If none are at or below this priority, then
 * return NULL, and this voice will go unheard.  If there IS a voice to be 
 * stolen, silence it first.
 */
CVoice *CSynth::StealVoice(DWORD dwPriority)
{
    CVoice *pVoice;
    CVoice *pBest = NULL;
    pVoice = m_VoicesInUse.GetHead();
    for (;pVoice != NULL;pVoice = pVoice->GetNext())
    {
        if (pVoice->m_dwPriority <= dwPriority)
        {
            if (!pBest)
            {
                pBest = pVoice;
            }
            else
            {
                if (pVoice->m_fNoteOn == FALSE) 
                {
                    if ((pBest->m_fNoteOn == TRUE) ||
                        (pBest->m_vrVolume > pVoice->m_vrVolume))
                    {
                        pBest = pVoice;
                    }
                }
                else
                {
                    if (pBest->m_stStartTime > pVoice->m_stStartTime)
                    {
                        pBest = pVoice;
                    }
                }
            }
        }
    }
    if (pBest != NULL)
    {
        pBest->ClearVoice();
        pBest->m_fInUse = FALSE; 
        m_VoicesInUse.Remove(pBest);
        pBest->SetNext(NULL);
    }
    return pBest;
}

/*****************************************************************************
 * CSynth::QueueVoice()
 *****************************************************************************
 * This method queues a voice in the list of currently 
 * synthesizing voices. It places them in the queue so that
 * the higher priority voices are later in the queue. This
 * allows the note stealing algorithm to take off the top of
 * the queue.
 * And, we want older playing notes to be later in the queue
 * so the note ons and offs overlap properly. So, the queue is
 * sorted in priority order with older notes later within one
 * priority level.
 */
void CSynth::QueueVoice(CVoice *pVoice)
{
    CVoice *pScan = m_VoicesInUse.GetHead();
    CVoice *pNext = NULL;
    if (!pScan) // Empty list?
    {
        m_VoicesInUse.AddHead(pVoice);
        return;
    }
    if (pScan->m_dwPriority > pVoice->m_dwPriority)
    {   // Are we lower priority than the head of the list?
        m_VoicesInUse.AddHead(pVoice);
        return;
    }

    pNext = pScan->GetNext();
    for (;pNext;)
    {
        if (pNext->m_dwPriority > pVoice->m_dwPriority)
        {
            // Lower priority than next in the list.
            pScan->SetNext(pVoice);
            pVoice->SetNext(pNext);
            return;
        }
        pScan = pNext;
        pNext = pNext->GetNext();
    }
    // Reached the end of the list.
    pScan->SetNext(pVoice);
    pVoice->SetNext(NULL);
}

/*****************************************************************************
 * CSynth::StealNotes()
 *****************************************************************************
 * Clear out notes at a given time.
 */
void CSynth::StealNotes(STIME stTime)
{
    CVoice *pVoice;
    long lToMove = m_nExtraVoices - m_VoicesExtra.GetCount();
    if (lToMove > 0)
    {
        for (;lToMove > 0;)
        {
            pVoice = m_VoicesFree.RemoveHead();
            if (pVoice != NULL)
            {
                m_VoicesExtra.AddHead(pVoice);
                lToMove--;
            }
            else break;
        }
        if (lToMove > 0)
        {
            pVoice = m_VoicesInUse.GetHead();
            for (;pVoice;pVoice = pVoice->GetNext())
            {
                if (pVoice->m_fTag) // Voice is already slated to be returned.
                {
                    lToMove--;
                }
            }
            for (;lToMove > 0;lToMove--)
            {
                pVoice = OldestVoice();
                if (pVoice != NULL)
                {
                    pVoice->QuickStopVoice(stTime);
				    m_BuildStats.dwNotesLost++;
                }
                else break;
            }
        }
    }
}


/*****************************************************************************
 * CSynth::FinishMix()
 *****************************************************************************
 * Cleanup after the mix.
 */
void CSynth::FinishMix(short *pBuffer,DWORD dwLength)
{
    DWORD dwIndex;
	long lMax = (long) m_BuildStats.dwMaxAmplitude;
	long lTemp;
    for (dwIndex = 0; dwIndex < (dwLength << m_dwStereo); dwIndex++)
    {
		lTemp = pBuffer[dwIndex];
		lTemp <<= 1;
		if (lTemp < -32767) lTemp = -32767;
		if (lTemp > 32767) lTemp = 32767;
		pBuffer[dwIndex] = (short) lTemp;
		if (lTemp > lMax)
		{
			lMax = lTemp;
		}
    }
	m_BuildStats.dwMaxAmplitude = lMax;
}

/*****************************************************************************
 * CSynth::Unload()
 *****************************************************************************
 * Unload a previous download.  Forward the request to the instrument manager.
 */
HRESULT CSynth::Unload(HANDLE hDownload,
					   HRESULT ( CALLBACK *lpFreeMemory)(HANDLE,HANDLE),
					   HANDLE hUserData)
{
	return m_Instruments.Unload( hDownload, lpFreeMemory, hUserData);
}

/*****************************************************************************
 * CSynth::Download()
 *****************************************************************************
 * Handle a download.  Forward the request to the instrument manager.
 */
HRESULT CSynth::Download(LPHANDLE phDownload, void * pdwData, LPBOOL bpFree) 
{
	return m_Instruments.Download( phDownload, (DWORD *) pdwData,  bpFree);
}

/*****************************************************************************
 * CSynth::PlayBuffer()
 *****************************************************************************
 * This receives one MIDI message in the form of a buffer of data and
 * ulCable, which indicates which Channel Group the message is addressed 
 * to. Each channel group is implemented with an instance of a CControlLogic
 * object, so this chooses which CControlLogic object to send the message
 * to. If ulCable is 0, this is a broadcast message and should be sent to all
 * CControlLogics.
 * 
 * PlayBuffer() analyzes the message and, depending on the size, either
 * sends to CControlLogic::RecordMIDI() or CControlLogic::RecordSysEx().
 * 
 * In order to properly associate the time stamp of the MIDI 
 * message in the buffer, the synth needs to convert from the
 * REFERENCE_TIME format to its internal sample based time. Since
 * the wave out stream is actually managed by IDirectMusicSynthSink,
 * the synth calls IDirectMusicSynthSink::RefTimeToSample
 * for each MIDI message to convert its time stamp into sample time.
 *
 * So, typically, the synthesizer pulls each MIDI message from the
 * buffer, stamps it in sample time, then places it in its own
 * internal queue. The queue is emptied later by the rendering
 * process, which is managed by CDmSynthStream::Render and
 * called by IDirectMusicSynthSink.
 */
HRESULT	CSynth::PlayBuffer(IDirectMusicSynthSink *pSynthSink,REFERENCE_TIME rt, 
                           LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable)
{
	STIME stTime;

	::EnterCriticalSection(&m_CriticalSection);

	if ( rt == 0 ) // Special case of time == 0.
	{
		stTime = m_stLastTime;
	}
	else
	{
		pSynthSink->RefTimeToSample(rt, &stTime);
	}

    if (cbBuffer <= sizeof(DWORD))
    {
		if (ulCable <= m_dwControlCount)
		{
			if (ulCable == 0) // Play all groups if 0.
			{
				for (; ulCable < m_dwControlCount; ulCable++)
				{
					m_ppControl[ulCable]->RecordMIDI(stTime,lpBuffer[0], 
						lpBuffer[1], lpBuffer[2]);
				}
			}
			else
			{
				m_ppControl[ulCable - 1]->RecordMIDI(stTime,lpBuffer[0], 
				lpBuffer[1], lpBuffer[2]);

			}
		}
        else
        {
            Trace(1,"MIDI event on channel group %ld is beyond range of %ld opened channel groups\n",
                ulCable, m_dwControlCount);
        }
    }
    else
    {
		if (ulCable <= m_dwControlCount)
		{
			if (ulCable == 0)
			{
				for (; ulCable < m_dwControlCount; ulCable++)
				{
					m_ppControl[ulCable]->RecordSysEx(cbBuffer,
						&lpBuffer[0], stTime);
				}
			}
			else
			{
				m_ppControl[ulCable-1]->RecordSysEx(cbBuffer,
					&lpBuffer[0], stTime);
			}
		}
	}

	::LeaveCriticalSection(&m_CriticalSection);
	return S_OK;
}

/*****************************************************************************
 * CSynth::SetStereoMode()
 *****************************************************************************
 * Set the stereo/mono mode for this synth.
 */
HRESULT CSynth::SetStereoMode(DWORD dwChannels)   // 1 for Mono, 2 for Stereo.
{
    HRESULT hr = S_OK;
    if ((m_dwStereo + 1) != dwChannels)
    {
		DWORD dwStereo;
		if (dwChannels > 1) dwStereo = 1;
		else dwStereo = 0;
		if (dwStereo != m_dwStereo)
		{
			m_dwStereo = dwStereo;
		}
    }
    return hr;
}

/*****************************************************************************
 * CSynth::ResetPerformanceStats()
 *****************************************************************************
 * Reset the running performance statistics.
 */
void CSynth::ResetPerformanceStats()
{
    m_BuildStats.dwNotesLost = 0;
    m_BuildStats.dwTotalTime = 0;
    m_BuildStats.dwVoices = 0;
    m_BuildStats.dwTotalSamples = 0;
    m_BuildStats.dwCPU = 0;
    m_BuildStats.dwMaxAmplitude = 0;
    m_CopyStats = m_BuildStats;
}

/*****************************************************************************
 * CSynth::AllNotesOff()
 *****************************************************************************
 * Stop all voices.
 */
HRESULT CSynth::AllNotesOff()
{
    CVoice *pVoice;
    ::EnterCriticalSection(&m_CriticalSection);
    while (pVoice = m_VoicesInUse.RemoveHead())
    {
        pVoice->ClearVoice();
        pVoice->m_fInUse = FALSE; 
        m_VoicesFree.AddHead(pVoice);

        long lSamples;

        if (pVoice->m_stStartTime < m_stLastStats)
        {
            lSamples = (long) (pVoice->m_stStopTime - m_stLastStats);
        }
        else
        {
            lSamples = (long) (pVoice->m_stStopTime - pVoice->m_stStartTime);
        }
        if (lSamples < 0) 
        {
            lSamples = 0;
        }
        m_BuildStats.dwTotalSamples += lSamples;
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return (S_OK);
}

/*****************************************************************************
 * CSynth::SetChannelPriority()
 *****************************************************************************
 * Set the priority for a given channel, to be used in voice stealing.
 */
HRESULT CSynth::SetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,
                                   DWORD dwPriority)
{
	HRESULT hr = S_OK;

	::EnterCriticalSection(&m_CriticalSection);
    
    dwChannelGroup--;
	if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
	{
		hr = E_INVALIDARG;
	}
	else
	{
		if (m_ppControl)
		{
			hr = m_ppControl[dwChannelGroup]->SetChannelPriority(dwChannel,dwPriority);
		}
	}
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

/*****************************************************************************
 * CSynth::GetChannelPriority()
 *****************************************************************************
 * Retrieve the priority of a given channel/channel group, to be used to
 * facilitate correct voice stealing.
 */
HRESULT CSynth::GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, 
                                   LPDWORD pdwPriority)
{
	HRESULT hr = S_OK;

	::EnterCriticalSection(&m_CriticalSection);

    dwChannelGroup--;
	if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
	{
		hr = E_INVALIDARG;
	}
	else
	{
		if (m_ppControl)
		{
			hr = m_ppControl[dwChannelGroup]->GetChannelPriority(dwChannel,pdwPriority);
		}
	}
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}




=== ddksynth/csynth.h ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//
//      CSynth.h
//

#ifndef __CSYNTH_H__
#define __CSYNTH_H__


#include "synth.h"

#define MAX_CHANNEL_GROUPS  1000
#define MAX_VOICES          1000

#ifndef IDirectMusicSynthSink
#define IDirectMusicSynthSink ISynthSinkDMus
#endif // IDirectMusicSynthSink



struct IDirectMusicSynthSink;

/*****************************************************************************
 * class CSynth
 *****************************************************************************
 * Class declaration for the synth object itself.
 * Manages the CControlLogic and CInstManager objects.
 */
class CSynth : public CListItem
{
friend class CControlLogic;
public: 
                    CSynth();
                    ~CSynth();
    CSynth *        GetNext() {return(CSynth *)CListItem::GetNext();};

    HRESULT         SetStereoMode(DWORD dwChannels) ;
    HRESULT         SetSampleRate(DWORD dwSampleRate) ;
    HRESULT         Activate(DWORD dwSampleRate, DWORD dwChannels);
    HRESULT         Deactivate();
    HRESULT         Download(LPHANDLE phDownload, void * pdwData, LPBOOL bpFree);
    HRESULT         Unload(HANDLE hDownload,HRESULT ( CALLBACK *lpFreeMemory)(HANDLE,HANDLE),HANDLE hUserData);
    HRESULT         PlayBuffer(IDirectMusicSynthSink *pSynthSink,REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable);
    HRESULT         SetNumChannelGroups(DWORD dwCableCount);
    void            SetGainAdjust(VREL vrGainAdjust);
    HRESULT         Open(DWORD dwCableCount, DWORD dwVoices);
    HRESULT         Close();
    void            ResetPerformanceStats();
    HRESULT         AllNotesOff();
    HRESULT         SetMaxVoices(short nMaxVoices,short nTempVoices);
    HRESULT         GetMaxVoices(short * pnMaxVoices,short * pnTempVoices);
    HRESULT         GetPerformanceStats(PerfStats *pStats);
    void            Mix(short *pBuffer,DWORD dwLength,LONGLONG llPosition);
    HRESULT         SetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,DWORD dwPriority);
    HRESULT         GetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,LPDWORD pdwPriority);

private:
    void            StealNotes(STIME stTime);
    void            FinishMix(short *pBuffer,DWORD dwlength);
    CVoice *        OldestVoice();
    void            QueueVoice(CVoice *pVoice);
    CVoice *        StealVoice(DWORD dwPriority);

    STIME           m_stLastTime;       // Sample time of last mix.
    CVoiceList      m_VoicesFree;       // List of available voices.
    CVoiceList      m_VoicesExtra;      // Extra voices for temporary overload.
    CVoiceList      m_VoicesInUse;      // List of voices currently in use.
    short           m_nMaxVoices;       // Number of allowed voices.
    short           m_nExtraVoices;     // Number of voices over the limit that can be used in a pinch.
    
    STIME           m_stLastStats;      // Last perfstats refresh.
    PerfStats       m_BuildStats;       // Performance info accumulator.
    PerfStats       m_CopyStats;        // Performance information for display.

public: 
    // DLS-1 compatibility parameters: set these off to emulate hardware
    // which can't vary volume/pan during playing of a note.
    VREL             m_vrGainAdjust;    // Final output gain adjust
    BOOL             m_fAllowPanWhilePlayingNote;
    BOOL             m_fAllowVolumeChangeWhilePlayingNote;

    STIME            m_stMinSpan;       // Minimum time allowed for mix time span.
    STIME            m_stMaxSpan;       // Maximum time allowed for mix time span.
    DWORD            m_dwSampleRate;
    DWORD            m_dwStereo;
    
    CInstManager     m_Instruments;     // Instrument manager.
    CControlLogic ** m_ppControl;       // Array of open ControlLogics.
    DWORD            m_dwControlCount;  // # of open CLs.

    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL             m_fCSInitialized;   
};

#endif// __CSYNTH_H__



=== ddksynth/ddksynth.htm ===
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>DirectMusic</TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff" leftmargin="8">
<FONT FACE="Verdana"><H2><A NAME="MYSAMPLE">DirectMusic Software Synthesizer</A> </H2>

<H3>Summary</H3></FONT><FONT FACE="Verdana" SIZE=2><P>

This sample contains working source code for a kernel-mode software synthesizer that plugs
into the Microsoft&#174; DirectMusic&#174; and WDM Audio architectures.<P>

<H3>Building a new DirectMusic Synthesizer</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
You are encouraged to use this sample code to start building your own software
synthesizer. Modify the sample to add your own features.<P>

If you ship your synthesizer to customers, be sure to use the Guidgen program to create
a Globally Unique ID (GUID) for your synthesizer so it won't interfere with other
synthesizers. Set CLSID_DDKWDMSynth at the top of private.h and ddksynth.inf to be your 
GUID. You should also set the text in miniport.cpp, ddksynth.rc and ddksynth.inf to 
describe your synthesizer.<P>

Note: this is a software synthesizer sample, but is also relevant as a hardware driver 
sample.  If you are writing a hardware driver, you should 1) not implement the wave pin,
2) not implement a synthsink nor depend on Render being called from the port (the
hardware should notify the miniport if it needs additional work done at buffer render
time), and 3) use category RENDER instead of DATATRANSFORM.


<H3>Creating a User-mode Synthesizer </H3></FONT><FONT FACE="Verdana" SIZE=2><P>
Although this sample doesn't show you how to create a user-mode synthesizer, you can start 
with the user-mode sample to feel out how synthesis and DLS downloads work. We recommend that
you try out your ideas and get things working in user-mode before moving to kernel mode. 
This approach might be easier and save a bit of debugging time.<P>

<H3>Building the Sample</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
Open a free or checked DDK build environment, go to the wdm\audio directory, and run <B>build</B>.
This creates ddksynth.sysin the Objfre or Objchk directory. Before the sample can
be used, it must be installed by executing <B>ddksynth.inf</B>.<P>

<H3>Testing the Synthesizer</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
To test the synthesizer, open DirectMusic Producer and open the Port Configuration window.
(You can do this by right-clicking the button showing a 1 or 2 with a sound wave behind it on the
Transit Controls toolbar.)  The port name dropdown will now contain the option <B>Microsoft DDK 
Synthesizer (WDM)</B> in addition to the Microsoft Synthesizer (WDM) option. Set one of the
configurations to use the Microsoft DDK Synthesizer port.<P>

Then, when you play music through that configuration, it will be played by the synthesizer
you built from the DDK sample. The sound and capabilities of the DDK sample -- Microsoft DDK
Synthesizer (WDM) -- are virtually identical to the kernel-mode DirectMusic synthesizer -- 
Microsoft Synthesizer (WDM).  One major exception is that the DDK sample synthesizer does not 
support reverb.<P>

<H3>Supported Configurations</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
The DDK sample synthesizer has been tested in checked and free builds with Microsoft Visual C++&#174;
version 6.  It has been tested on Alpha, but not on 64-bit platforms.<P>

Plug and Play as well as Power Management are supported by PortCls on behalf of the synthesizer.<P>

<H3>CODE TOUR</H3>
<H4>File Manifest</H4>
</FONT><U><PRE>File&#9;&#9;	Description
</U>
adapter.cpp&#9;	Implementation of WDM adapter
clist.cpp&#9;	Implements a simple list data structure
clist.h	&#9;	Prototypes for clist.cpp
common.h&#9;	Master header file 
control.cpp&#9;	CControlLogic implementation 
csynth.cpp&#9;	CSynth implementation
csynth.h&#9;	Prototypes for csynth.cpp
DDKSynth.rc&#9;	Resources file containng version information
instr.cpp&#9;	Implements instruments
kernhelp.cpp&#9;	Helper functions to keep code common between user and kernel modes
kernhelp.h&#9;	Prototype file for kernhelp.h
makefile&#9;	Makefile for BUILD environment
midi.cpp&#9;	Implements MIDI events
miniport.cpp&#9;	Implementation of WDM miniport
mix.cpp&#9;		CDigitalAudio mixing functions
mmx.cpp&#9;		MMX-optimized mixing functions
muldiv32.h&#9;	High-resolution multiply-divide operations
plclock.cpp&#9;	Clock implementation
plclock.h&#9;	Prototypes for plclock.cpp
private.h&#9;	Prototypes for adapter.cpp, miniport.cpp, and syslink.cpp
sources&#9;		Sources file for BUILD environment 
synth.h&#9;		Prototypes for instr.cpp, midi.cpp, voice.cpp, and control.cpp
syslink.cpp&#9;	Wave interface back into PortCls
voice.cpp&#9;	Voice implementation




</FONT><P ALIGN="CENTER"><A HREF="#top"><FONT FACE="Verdana" SIZE=2>Top of page</FONT></A><FONT FACE="Verdana" SIZE=2> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 WIDTH=624>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff" HEIGHT=2>
<P></TD>
</TR>
</TABLE>

<FONT FACE="MS Sans Serif" SIZE=1><P>&copy; 1999-2000 Microsoft Corporation. All rights reserved.</FONT><FONT FACE="Verdana" SIZE=2> </P></FONT></BODY>
</HTML>

=== ddksynth/ddksynth.inf ===


;;  Copyright (c) Microsoft Corporation 1998-2000.  All rights reserved.

[Version]
Signature="$CHICAGO$"
Class=MEDIA
ClassGUID={4d36e96c-e325-11ce-bfc1-08002be10318}
provider=%MSFT%
DriverVer =06/16/1999,5.00.2062.1

[Manufacturer]
%DDKMfgName%=Microsoft

[DefaultInstall]
AddReg = WDM_DDKSYNTH.DeviceRegistration
CopyFiles = Default.CopyFiles

[Default.CopyFiles]
ddksynth.inf



;;
;;**** GUIDGen your own and place it here.  Also put it ****
;;**** below in WDM_DDKSYNTH.DeviceId, and in private.h ****
;;
[Microsoft]
%WDM_DDKSYNTH.DeviceDesc%   = WDM_DDKSYNTH,   SW\{820DC38A-1F81-11d3-A82E-0060083316C1}

;You must specify which platform is supported by each SourceDisksNames section
;Valid platform identifiers include .x86, .ia64, .alpha, .axp64
[SourceDisksNames.x86]
222=%DiskDescription%,,,

;You must also specify which platform is supported by each SourceDisksFiles section
;Valid platform identifiers include .x86, .ia64, .alpha, .axp64
[SourceDisksFiles.x86]
ddksynth.sys=222
;;ddksynth.inf=222

;; Destination Directory List
[DestinationDirs]
WDM_DDKSYNTH.CopyFiles = 10,system32\drivers ; %SystemRoot%\system32\drivers
Default.CopyFiles = 10,inf

[WDM_DDKSYNTH.CopyFiles]
DDKSynth.sys

;;
;; DDKSynth swenum install
;;
[WDM_DDKSYNTH.DeviceRegistration]

HKLM,%RunOnce%,"WDM_DDKSYNTH0",,"rundll32.exe streamci.dll,StreamingDeviceSetup %WDM_DDKSYNTH.DeviceId%,%KSNAME_DDKSYNTH%,%KSCATEGORY_DATATRANSFORM%,%01%\ddksynth.inf,WDM_DDKSYNTH.Interface.Install"
HKLM,%RunOnce%,"WDM_DDKSYNTH1",,"rundll32.exe /N streamci.dll,StreamingDeviceSetup %WDM_DDKSYNTH.DeviceId%,%KSNAME_DDKSYNTH%,%KSCATEGORY_SYNTHESIZER%,%01%\ddksynth.inf,WDM_DDKSYNTH.Interface.Install"
HKLM,%RunOnce%,"WDM_DDKSYNTH2",,"rundll32.exe /N streamci.dll,StreamingDeviceSetup %WDM_DDKSYNTH.DeviceId%,%KSNAME_DDKSYNTH%,%KSCATEGORY_AUDIO%,%01%\ddksynth.inf,WDM_DDKSYNTH.Interface.Install"
HKLM,%MediaCategories%\%WDM_DDKSYNTH.GUID%,Name,,%WDM_DDKSYNTH.Pin%
HKLM,%MediaCategories%\%WDM_DDKSYNTH.GUID%,Display,1,00,00,00,00

[WDM_DDKSYNTH.Interface.Install]
AddReg=WDM_DDKSYNTH.Interface.AddReg

[WDM_DDKSYNTH.Interface.AddReg]
HKR,,CLSID,,%Proxy.CLSID%
HKR,,FriendlyName,,%WDM_DDKSYNTH.FriendlyName%

;;**************** 9x Specific ****************
;;
;; DDKSynth Install
;;

[WDM_DDKSYNTH]

;;AlsoInstall=KS.Registration(ks.inf), WDM.AddReg.Install(wdmaudio.inf)
AlsoInstall=KS.Registration(ks.inf)
CopyFiles = WDM_DDKSYNTH.CopyFiles
AddReg=WDM_DDKSYNTH.AddReg

[WDM_DDKSYNTH.AddReg]
HKR,,DevLoader,,*NTKERN
HKR,,NTMPDriver,,ddksynth.sys

[WDM_DDKSYNTH.Services]
AddService = DDKSynth, 0x00000002, DDKSynth_Service_Inst


[DDKSynth_Service_Inst]
DisplayName    = %WDM_DDKSYNTH.SvcDesc%
ServiceType    = 1                  ; SERVICE_KERNEL_DRIVER
StartType      = 3                  ; SERVICE_DEMAND_START
ErrorControl   = 1                  ; SERVICE_ERROR_NORMAL
ServiceBinary  = %10%\system32\drivers\DDKSynth.sys


;;**************** NT Specific ****************
;;
;; DDKSynth Install
;;
[WDM_DDKSYNTH.NT]
Include=ks.inf, wdmaudio.inf
Needs=KS.Registration, WDMAUDIO.Registration
CopyFiles = WDM_DDKSYNTH.CopyFiles
AddReg=WDM_DDKSYNTH.DeviceRegistration

[WDM_DDKSYNTH.NT.Services]
AddService = DDKSynth, 0x00000002, DDKSynth_Service_Inst



[Strings]
MSFT="Microsoft"
DDKMfgName="DDK Sample Inc."
DiskDescription="DDK Sample"

RunOnce = "SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"
Proxy.CLSID             =   "{17CCA71B-ECD7-11D0-B908-00A0C9223196}"
KSNAME_Filter           =   "{9B365890-165F-11D0-A195-0020AFD156E4}"
KSNAME_DDKSYNTH         =   "DDKSynth"

KSCATEGORY_DATATRANSFORM =  "{2EB07EA0-7E70-11D0-A5D6-28DB04C10000}"
KSCATEGORY_SYNTHESIZER   =  "{DFF220F3-F70F-11D0-B917-00A0C9223196}"
KSCATEGORY_AUDIO         =  "{6994AD04-93EF-11D0-A3CC-00A0C9223196}"

;Non-localized strings
MediaCategories="SYSTEM\CurrentControlSet\Control\MediaCategories"

;;
;;Name shows in mmsys.cpl if your synth is KSDATAFORMAT_SUBTYPE_MIDI
;;(KSCATEGORY_WDMAUD_USE_PIN_NAME forces this, otherwise name would
;;be the same as the waveOut device name)
;;
WDM_DDKSYNTH.Pin="Microsoft DDK DLS Synth"

;;
;;**** GUIDGen your own and place it here.  Also put it  ****
;;**** above in WDM_DDKSYNTH.DeviceDesc and in private.h ****
;;
WDM_DDKSYNTH.DeviceId     = "{820DC38A-1F81-11d3-A82E-0060083316C1}"

;;
;;**** GUIDGen your own.  Place it here and in private.h ****
;;
WDM_DDKSYNTH.GUID         = "{D2D37597-A312-434C-A2DD-2B4C32E6658A}"


WDM_DDKSYNTH.DeviceDesc   = " Ha1 Microsoft DDK Synthesizer"
WDM_DDKSYNTH.FriendlyName = " Friendly Name - Microsoft DDK Synthesizer"
WDM_DDKSYNTH.SvcDesc      = " Ha3 Microsoft DDK Synthesizer"


=== ddksynth/instr.cpp ===

//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//      Instrument.cpp

#include "common.h"

#define STR_MODULENAME "DDKSynth.sys:Instr: "


#include "math.h"

void MemDump(char * prompt);

#pragma code_seg()
/*****************************************************************************
 * CSourceLFO::CSourceLFO()
 *****************************************************************************
 * Constructor for CSourceLFO.
 */
CSourceLFO::CSourceLFO()
{
    m_pfFrequency = 3804; // f = (256*4096*16*5hz)/(samplerate)
    m_stDelay = 0;
    m_prMWPitchScale = 0;
    m_vrMWVolumeScale = 0;
    m_vrVolumeScale = 0;
    m_prPitchScale = 0;
}

/*****************************************************************************
 * CSourceLFO::Init()
 *****************************************************************************
 * Initialize the CSourceLFO object.
 */
void CSourceLFO::Init(DWORD dwSampleRate)
{
    m_pfFrequency = (256 * 4096 * 16 * 5) / dwSampleRate;
    m_stDelay = 0;
    m_prMWPitchScale = 0;
    m_vrMWVolumeScale = 0;
    m_vrVolumeScale = 0;
    m_prPitchScale = 0;
}

/*****************************************************************************
 * CSourceLFO::SetSampleRate()
 *****************************************************************************
 * Set the sample rate delta.
 */
void CSourceLFO::SetSampleRate(long lChange)
{
    if (lChange > 0)
    {
        m_stDelay <<= lChange;
        m_pfFrequency <<= lChange;
    }
    else
    {
        m_stDelay >>= -lChange;
        m_pfFrequency >>= -lChange;
    }
}

/*****************************************************************************
 * CSourceLFO::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CSourceLFO::Verify()
{
    FORCEBOUNDS(m_pfFrequency,64,7600);
    FORCEBOUNDS(m_stDelay,0,441000);
    FORCEBOUNDS(m_vrVolumeScale,-1200,1200);
    FORCEBOUNDS(m_vrMWVolumeScale,-1200,1200);
    FORCEBOUNDS(m_prPitchScale,-1200,1200);
    FORCEBOUNDS(m_prMWPitchScale,-1200,1200);
}

/*****************************************************************************
 * CSourceEG::CSourceEG()
 *****************************************************************************
 * Constructor for this object.
 */
CSourceEG::CSourceEG()
{
    Init();
}

/*****************************************************************************
 * CSourceEG::Init()
 *****************************************************************************
 * Initialize the CSourceEG object.
 */
void CSourceEG::Init()
{
    m_stAttack = 0;
    m_stDecay = 0;
    m_pcSustain = 1000;
    m_stRelease = 0;
    m_trVelAttackScale = 0;
    m_trKeyDecayScale = 0;
    m_sScale = 0;
}

/*****************************************************************************
 * CSourceEG::SetSampleRate()
 *****************************************************************************
 * Set the sample rate delta.
 */
void CSourceEG::SetSampleRate(long lChange)
{
    if (lChange > 0)
    {
        m_stAttack <<= lChange;
        m_stDecay <<= lChange;
        m_stRelease <<= lChange;
    }
    else
    {
        m_stAttack >>= -lChange;
        m_stDecay >>= -lChange;
        m_stRelease >>= -lChange;
    }
}

/*****************************************************************************
 * CSourceEG::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CSourceEG::Verify()
{
    FORCEBOUNDS(m_stAttack,0,1764000);
    FORCEBOUNDS(m_stDecay,0,1764000);
    FORCEBOUNDS(m_pcSustain,0,1000);
    FORCEBOUNDS(m_stRelease,0,1764000);

    FORCEBOUNDS(m_sScale,-1200,1200);
    FORCEBOUNDS(m_trKeyDecayScale,-12000,12000);
    FORCEBOUNDS(m_trVelAttackScale,-12000,12000);
}

/*****************************************************************************
 * CSourceArticulation::CSourceArticulation()
 *****************************************************************************
 * Constructor for this object.
 */
CSourceArticulation::CSourceArticulation()
{
    m_wUsageCount = 0;
    m_sDefaultPan = 0;
    m_dwSampleRate = 22050;
    m_PitchEG.m_sScale = 0; // pitch envelope defaults to off
}

/*****************************************************************************
 * CSourceArticulation::Init()
 *****************************************************************************
 * Initialize the CSourceArticulation object.
 */
void CSourceArticulation::Init(DWORD dwSampleRate)
{
    m_dwSampleRate = dwSampleRate;
    m_LFO.Init(dwSampleRate);       //  Set to default values.
    m_PitchEG.Init();
    m_VolumeEG.Init();
}

/*****************************************************************************
 * CSourceArticulation::SetSampleRate()
 *****************************************************************************
 * Set the sample rate for this articulation.
 */
void CSourceArticulation::SetSampleRate(DWORD dwSampleRate)
{
    if (dwSampleRate != m_dwSampleRate)
    {
        long lChange;
        if (dwSampleRate > (m_dwSampleRate * 2))
        {
            lChange = 2;        // going from 11 to 44.
        }
        else if (dwSampleRate > m_dwSampleRate)
        {
            lChange = 1;        // must be doubling
        }
        else if ((dwSampleRate * 2) < m_dwSampleRate)
        {
            lChange = -2;       // going from 44 to 11
        }
        else
        {
            lChange = -1;       // that leaves halving.
        }
        m_dwSampleRate = dwSampleRate;
        m_LFO.SetSampleRate(lChange);
        m_PitchEG.SetSampleRate(lChange);
        m_VolumeEG.SetSampleRate(lChange);
    }
}

/*****************************************************************************
 * CSourceArticulation::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CSourceArticulation::Verify()
{
    m_LFO.Verify();
    m_PitchEG.Verify();
    m_VolumeEG.Verify();
}

/*****************************************************************************
 * CSourceArticulation::AddRef()
 *****************************************************************************
 * Implementation of standard COM interface.
 */
void CSourceArticulation::AddRef()
{
    m_wUsageCount++;
}

/*****************************************************************************
 * CSourceArticulation::Release()
 *****************************************************************************
 * Implementation of standard COM interface.
 */
void CSourceArticulation::Release()
{
    m_wUsageCount--;
    if (m_wUsageCount == 0)
    {
        delete this;
    }
}

/*****************************************************************************
 * CSourceSample::CSourceSample()
 *****************************************************************************
 * Constructor for this object.
 */
CSourceSample::CSourceSample()
{
    m_pWave = NULL;
    m_dwLoopStart = 0;
    m_dwLoopEnd = 1;
    m_dwSampleLength = 0;
    m_prFineTune = 0;
    m_dwSampleRate = 22050;
    m_bMIDIRootKey = 60;
    m_bOneShot = TRUE;
    m_bSampleType = 0;
}

/*****************************************************************************
 * CSourceSample::~CSourceSample()
 *****************************************************************************
 * Destructor for this object.
 */
CSourceSample::~CSourceSample()
{ 
    if (m_pWave != NULL)
    {
        m_pWave->Release();
    }
}

/*****************************************************************************
 * CSourceSample::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CSourceSample::Verify()
{
    if (m_pWave != NULL)
    {
        FORCEBOUNDS(m_dwSampleLength,0,m_pWave->m_dwSampleLength);
        FORCEBOUNDS(m_dwLoopEnd,1,m_dwSampleLength);
        FORCEBOUNDS(m_dwLoopStart,0,m_dwLoopEnd);
        if ((m_dwLoopEnd - m_dwLoopStart) < 6) 
        {
            m_bOneShot = TRUE;
        }
    }
    FORCEBOUNDS(m_dwSampleRate,3000,80000);
    FORCEBOUNDS(m_bMIDIRootKey,0,127);
    FORCEBOUNDS(m_prFineTune,-1200,1200);
}

/*****************************************************************************
 * CSourceSample::CopyFromWave()
 *****************************************************************************
 * Duplicate a wave that is already referenced elsewhere.
 */
BOOL CSourceSample::CopyFromWave()
{
    if (m_pWave == NULL)
    {
        return FALSE;
    }
    m_dwSampleLength = m_pWave->m_dwSampleLength;
    m_dwSampleRate = m_pWave->m_dwSampleRate;
    m_bSampleType = m_pWave->m_bSampleType; 
    if (m_bOneShot)
    {
        m_dwSampleLength--;
        if (m_pWave->m_bSampleType & SFORMAT_16)
        {
            m_pWave->m_pnWave[m_dwSampleLength] = 0;
        }
        else
        {
            char *pBuffer = (char *) m_pWave->m_pnWave;
            pBuffer[m_dwSampleLength] = 0;
        }
    }
    else 
    {
        if (m_dwLoopStart >= m_dwSampleLength)
        {
            m_dwLoopStart = 0;
        }
        if (m_pWave->m_bSampleType & SFORMAT_16)
        {
            m_pWave->m_pnWave[m_dwSampleLength-1] =
                m_pWave->m_pnWave[m_dwLoopStart];
        }
        else
        {
            char *pBuffer = (char *) m_pWave->m_pnWave;
            pBuffer[m_dwSampleLength-1] =
                pBuffer[m_dwLoopStart];
        }
    }
    Verify();
    return (TRUE);
}


/*****************************************************************************
 * CWave::CWave()
 *****************************************************************************
 * Constructor for this object.
 */
CWave::CWave()
{
    m_hUserData = NULL;
    m_lpFreeHandle = NULL;
    m_pnWave = NULL;
    m_dwSampleRate = 22050;
    m_bSampleType = SFORMAT_16;
    m_dwSampleLength = 0;
    m_wUsageCount = 0;
    m_dwID = 0;
    m_wPlayCount = 0;
    m_pWaveMem = NULL;
}

/*****************************************************************************
 * CWave::~CWave()
 *****************************************************************************
 * Destructor for this object.
 */
CWave::~CWave()
{
    if (m_pWaveMem)
    {
        if (m_lpFreeHandle)
        {
            m_lpFreeHandle((HANDLE) this,m_hUserData);
        }
        else
        {
            delete m_pWaveMem;
        }
        m_pWaveMem = NULL;
    }
    m_pnWave = NULL;
}

/*****************************************************************************
 * CWave::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CWave::Verify()
{
    FORCEBOUNDS(m_dwSampleRate,3000,80000);
}

/*****************************************************************************
 * CWave::PlayOn()
 *****************************************************************************
 * Increment the play count.
 */
void CWave::PlayOn()
{
    m_wPlayCount++;
    AddRef();
}

/*****************************************************************************
 * CWave::PlayOff()
 *****************************************************************************
 * Decrement the play count.
 */
void CWave::PlayOff()
{
    m_wPlayCount--;
    Release();
}

/*****************************************************************************
 * CWave::IsPlaying()
 *****************************************************************************
 * Return whether the wave is currently playing.
 */
BOOL CWave::IsPlaying()
{
    return (m_wPlayCount);
}

/*****************************************************************************
 * CWave::AddRef()
 *****************************************************************************
 * Implementation of standard COM interface.
 */
void CWave::AddRef()
{
    m_wUsageCount++;
}

/*****************************************************************************
 * CWave::Release()
 *****************************************************************************
 * Implementation of standard COM interface.
 */
void CWave::Release()
{
    m_wUsageCount--;
    if (m_wUsageCount == 0)
    {
        delete this;
    }
}

/*****************************************************************************
 * CSourceRegion::CSourceRegion()
 *****************************************************************************
 * Constructor for this object.
 */
CSourceRegion::CSourceRegion()
{
    m_pArticulation = NULL;
    m_vrAttenuation = 0;
    m_prTuning = 0;
    m_bKeyHigh = 127;
    m_bKeyLow = 0;
    m_bGroup = 0;
    m_bAllowOverlap = FALSE;
}

/*****************************************************************************
 * CSourceRegion::~CSourceRegion()
 *****************************************************************************
 * Destructor for this object.
 */
CSourceRegion::~CSourceRegion()
{
    if (m_pArticulation)
    {
        m_pArticulation->Release();
    }
}

/*****************************************************************************
 * CSourceRegion::SetSampleRate()
 *****************************************************************************
 * Set the sample rate for this region.  Forward this to the articulation.
 */
void CSourceRegion::SetSampleRate(DWORD dwSampleRate)
{
    if (m_pArticulation != NULL)
    {
        m_pArticulation->SetSampleRate(dwSampleRate);
    }
}

/*****************************************************************************
 * CSourceRegion::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CSourceRegion::Verify()
{
    FORCEBOUNDS(m_bKeyHigh,0,127);
    FORCEBOUNDS(m_bKeyLow,0,127);
    FORCEBOUNDS(m_prTuning,-12000,12000);
    FORCEBOUNDS(m_vrAttenuation,-9600,0);
    m_Sample.Verify();
    if (m_pArticulation != NULL)
    {
        m_pArticulation->Verify();
    }
}

/*****************************************************************************
 * CInstrument::CInstrument()
 *****************************************************************************
 * Constructor for this object.
 */
CInstrument::CInstrument()
{
    m_dwProgram = 0;
}

/*****************************************************************************
 * CInstrument::~CInstrument()
 *****************************************************************************
 * Destructor for this object.
 */
CInstrument::~CInstrument()
{
    while (!m_RegionList.IsEmpty())
    {
        CSourceRegion *pRegion = m_RegionList.RemoveHead();
        delete pRegion;
    }
}

/*****************************************************************************
 * CInstrument::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CInstrument::Verify()
{
    CSourceRegion *pRegion = m_RegionList.GetHead();
    CSourceArticulation *pArticulation = NULL;
    for (;pRegion != NULL;pRegion = pRegion->GetNext())
    {
        if (pRegion->m_pArticulation != NULL)
        {
            pArticulation = pRegion->m_pArticulation;
        }
        pRegion->Verify();
    }
    if (pArticulation)
    {
        pRegion = m_RegionList.GetHead();
        for (;pRegion != NULL;pRegion = pRegion->GetNext())
        {
            if (pRegion->m_pArticulation == NULL)
            {
                pRegion->m_pArticulation = pArticulation;
                pArticulation->AddRef();
            }
        }
    }
}

/*****************************************************************************
 * CInstrument::SetSampleRate()
 *****************************************************************************
 * Set the sample rate for this instrument (forward to region).
 */
void CInstrument::SetSampleRate(DWORD dwSampleRate)
{
    CSourceRegion *pRegion = m_RegionList.GetHead();
    for (;pRegion;pRegion = pRegion->GetNext())
    {
        pRegion->SetSampleRate(dwSampleRate);
    }
}

/*****************************************************************************
 * CInstrument::ScanForRegion()
 *****************************************************************************
 * Retrieve the region with the given note value from the list.
 */
CSourceRegion * CInstrument::ScanForRegion(DWORD dwNoteValue)
{
    CSourceRegion *pRegion = m_RegionList.GetHead();
    for (;pRegion;pRegion = pRegion->GetNext())
    {
        if (dwNoteValue >= pRegion->m_bKeyLow &&
            dwNoteValue <= pRegion->m_bKeyHigh)
        {
            break ;
        }
    }
    return pRegion;
}

/*****************************************************************************
 * CInstManager::SetSampleRate()
 *****************************************************************************
 * Set the sample rate for this instrument manager (forward to instruments).
 */
void CInstManager::SetSampleRate(DWORD dwSampleRate)
{
    DWORD dwIndex;
    
    m_dwSampleRate = dwSampleRate;
    EnterCriticalSection(&m_CriticalSection);

    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
        {
            pInstrument->SetSampleRate(dwSampleRate);
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CInstManager::CInstManager()
 *****************************************************************************
 * Constructor for this object.
 */
CInstManager::CInstManager()
{
    m_fCSInitialized = FALSE;
    m_dwSampleRate = 22050;
    InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;
}

/*****************************************************************************
 * CInstManager::~CInstManager()
 *****************************************************************************
 * Destructor for this object.
 */
CInstManager::~CInstManager()
{
    if (m_fCSInitialized)
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
        {
            while (!m_InstrumentList[dwIndex].IsEmpty())
            {
                CInstrument *pInstrument = m_InstrumentList[dwIndex].RemoveHead();
                delete pInstrument;
            }
        }
        for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
        {
            while (!m_WavePool[dwIndex].IsEmpty()) 
            {
                CWave *pWave = m_WavePool[dwIndex].RemoveHead();
                pWave->Release();
            }
        }
        while (!m_FreeWavePool.IsEmpty()) 
        {
            CWave *pWave = m_FreeWavePool.RemoveHead();
            pWave->Release();
        }
        DeleteCriticalSection(&m_CriticalSection);
    }
}

/*****************************************************************************
 * CInstManager::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CInstManager::Verify()
{
    DWORD dwIndex;
    EnterCriticalSection(&m_CriticalSection);
    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL;pInstrument = pInstrument->GetNext())
        {
            pInstrument->Verify();
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CInstManager::GetInstrument()
 *****************************************************************************
 * Get the instrument that matches this program/key.
 */
CInstrument * CInstManager::GetInstrument(DWORD dwProgram,DWORD dwKey)
{
    EnterCriticalSection(&m_CriticalSection);
    CInstrument *pInstrument = m_InstrumentList[dwProgram % INSTRUMENT_HASH_SIZE].GetHead();
    for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
    {
        if (pInstrument->m_dwProgram == dwProgram) 
        {
            if (pInstrument->ScanForRegion(dwKey) != NULL)
            {
                break;
            }
            else
            {
                Trace(1,"No region was found in instrument 0x%lx that matched note 0x%lx\n",
                    dwProgram, dwKey);
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return (pInstrument);
}


/*****************************************************************************
 * TimeCents2Samples()
 *****************************************************************************
 * Translate from time cents to samples.
 */
DWORD TimeCents2Samples(long tcTime, DWORD dwSampleRate)
{
    if (tcTime ==  0x80000000) return (0);
    double flTemp = tcTime;
    flTemp /= (65536 * 1200);
    flTemp = pow(2.0,flTemp);
    flTemp *= dwSampleRate;
    return (DWORD) flTemp;
}

/*****************************************************************************
 * PitchCents2PitchFract()
 *****************************************************************************
 * Translate from pitch cents to fractional pitch.
 */
DWORD PitchCents2PitchFract(long pcRate,DWORD dwSampleRate)
{
    double fTemp = pcRate;
    fTemp /= 65536;
    fTemp -= 6900;
    fTemp /= 1200;
    fTemp = pow(2.0,fTemp);
    fTemp *= 7381975040.0;  // (440*256*16*4096);
    fTemp /= dwSampleRate;
    return (DWORD) (fTemp);
}

/*****************************************************************************
 * CSourceArticulation::Download()
 *****************************************************************************
 * Download an articulation to this object.
 */
HRESULT 
CSourceArticulation::Download(DMUS_DOWNLOADINFO * pInfo,void * pvOffsetTable[], 
                              DWORD dwIndex,            DWORD dwSampleRate,
                              BOOL fNewFormat)
{
    // Depending on whether this is the new DX7 format, we either are reading 
    // a fixed set of parameters or parsing an articulation chunk directly 
    // copied from the DLS file. The latter is obviously more flexible and it 
    // turns out to make much more sense once we get to DLS2.
    if (fNewFormat)
    {
        DMUS_ARTICULATION2 * pdmArtic = 
            (DMUS_ARTICULATION2 *) pvOffsetTable[dwIndex];

        while (pdmArtic)
        {
            if (pdmArtic->ulArtIdx)
            {
                if (pdmArtic->ulArtIdx >= pInfo->dwNumOffsetTableEntries)
                {
                    return DMUS_E_BADARTICULATION;
                }
                DWORD dwPosition;
                void *pData = pvOffsetTable[pdmArtic->ulArtIdx];
                CONNECTIONLIST * pConnectionList = 
                    (CONNECTIONLIST *) pData;
                CONNECTION *pConnection;
                dwPosition = sizeof(CONNECTIONLIST);
                for (dwIndex = 0; dwIndex < pConnectionList->cConnections; dwIndex++)
                {
                    pConnection = (CONNECTION *) ((BYTE *)pData + dwPosition);
                    dwPosition += sizeof(CONNECTION);
                    switch (pConnection->usSource)
                    {
                    case CONN_SRC_NONE :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_LFO_FREQUENCY :
                            m_LFO.m_pfFrequency = PitchCents2PitchFract(
                                pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_LFO_STARTDELAY :
                            m_LFO.m_stDelay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_ATTACKTIME :
                            m_VolumeEG.m_stAttack = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_DECAYTIME :
                            m_VolumeEG.m_stDecay = TimeCents2Samples(
                            (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_SUSTAINLEVEL :
                            m_VolumeEG.m_pcSustain = 
                                (SPERCENT) ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG1_RELEASETIME :
                            m_VolumeEG.m_stRelease = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_ATTACKTIME :
                            m_PitchEG.m_stAttack = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_DECAYTIME :
                            m_PitchEG.m_stDecay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_SUSTAINLEVEL :
                            m_PitchEG.m_pcSustain =
                                (SPERCENT) ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_RELEASETIME :
                            m_PitchEG.m_stRelease = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate); 
                            break;
                        case CONN_DST_PAN :
                            m_sDefaultPan = (short) 
                                ((long) ((long) pConnection->lScale >> 12) / 125);
                            break;
                        }
                        break;
                    case CONN_SRC_LFO :
                        switch (pConnection->usControl)
                        {
                        case CONN_SRC_NONE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrVolumeScale = (VRELS)
                                    ((long) ((pConnection->lScale * 10) >> 16));
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16)); 
                                break;
                            }
                            break;
                        case CONN_SRC_CC1 :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrMWVolumeScale = (VRELS)
                                    ((long) ((pConnection->lScale * 10) >> 16)); 
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prMWPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16)); 
                                break;
                            }
                            break;
                        }
                        break;
                    case CONN_SRC_KEYONVELOCITY :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_EG1_ATTACKTIME :
                            m_VolumeEG.m_trVelAttackScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_ATTACKTIME :
                            m_PitchEG.m_trVelAttackScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_ATTENUATION :
                            break;
                        }
                        break;
                    case CONN_SRC_KEYNUMBER :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_EG1_DECAYTIME :
                            m_VolumeEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_DECAYTIME :
                            m_PitchEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        }
                        break;
                    case CONN_SRC_EG2 :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_PITCH :
                            m_PitchEG.m_sScale = (short)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        }
                        break;      
                    }
                }
            }
            if (pdmArtic->ulNextArtIdx)
            {
                if (pdmArtic->ulNextArtIdx >= pInfo->dwNumOffsetTableEntries)
                {
                    return DMUS_E_BADARTICULATION;
                }
                pdmArtic = (DMUS_ARTICULATION2 *) pvOffsetTable[pdmArtic->ulNextArtIdx];
            }
            else
            {
                pdmArtic = NULL;
            }
        }
    }
    else
    {
        DMUS_ARTICULATION * pdmArtic = 
            (DMUS_ARTICULATION *) pvOffsetTable[dwIndex];

        if (pdmArtic->ulArt1Idx)
        {
            if (pdmArtic->ulArt1Idx >= pInfo->dwNumOffsetTableEntries)
            {
                return DMUS_E_BADARTICULATION;
            }
            DMUS_ARTICPARAMS * pdmArticParams = 
                (DMUS_ARTICPARAMS *) pvOffsetTable[pdmArtic->ulArt1Idx];

            m_LFO.m_pfFrequency = PitchCents2PitchFract(
                pdmArticParams->LFO.pcFrequency,dwSampleRate);
            m_LFO.m_stDelay = TimeCents2Samples(
                (TCENT) pdmArticParams->LFO.tcDelay,dwSampleRate);
            m_LFO.m_vrVolumeScale = (VRELS)
                ((long) ((pdmArticParams->LFO.gcVolumeScale * 10) >> 16));
            m_LFO.m_prPitchScale = (PRELS)
                ((long) (pdmArticParams->LFO.pcPitchScale >> 16)); 
            m_LFO.m_vrMWVolumeScale = (VRELS)
                ((long) ((pdmArticParams->LFO.gcMWToVolume * 10) >> 16)); 
            m_LFO.m_prMWPitchScale = (PRELS)
                ((long) (pdmArticParams->LFO.pcMWToPitch >> 16)); 

            m_VolumeEG.m_stAttack = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcAttack,dwSampleRate);
            m_VolumeEG.m_stDecay = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcDecay,dwSampleRate);
            m_VolumeEG.m_pcSustain = 
                (SPERCENT) ((long) (pdmArticParams->VolEG.ptSustain >> 16));
            m_VolumeEG.m_stRelease = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcRelease,dwSampleRate); 
            m_VolumeEG.m_trVelAttackScale = (TRELS)
                ((long) (pdmArticParams->VolEG.tcVel2Attack >> 16));
            m_VolumeEG.m_trKeyDecayScale = (TRELS)
                ((long) (pdmArticParams->VolEG.tcKey2Decay >> 16));

            m_PitchEG.m_trKeyDecayScale = (TRELS)
                ((long) (pdmArticParams->PitchEG.tcKey2Decay >> 16));
            m_PitchEG.m_sScale = (short)
                ((long) (pdmArticParams->PitchEG.pcRange >> 16));
            m_PitchEG.m_trVelAttackScale = (TRELS)
                ((long) (pdmArticParams->PitchEG.tcVel2Attack >> 16));
            m_PitchEG.m_stAttack = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcAttack,dwSampleRate);
            m_PitchEG.m_stDecay = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcDecay,dwSampleRate);
            m_PitchEG.m_pcSustain =
                (SPERCENT) ((long) (pdmArticParams->PitchEG.ptSustain >> 16));
            m_PitchEG.m_stRelease = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcRelease,dwSampleRate); 

            m_sDefaultPan = (short)
                            ((long) ((long) pdmArticParams->Misc.ptDefaultPan >> 12) / 125);
        }
    }

    Verify();   // Make sure all parameters are legal.
    return S_OK;
}

/*****************************************************************************
 * CSourceRegion::Download()
 *****************************************************************************
 * Download a region to this object.
 * Parse through the region chunks, including any embedded articulation.
 */
HRESULT CSourceRegion::Download(DMUS_DOWNLOADINFO * pInfo, // DMUS_DOWNLOADINFO header struct.
                                void * pvOffsetTable[],    // Offset table with embedded struct addresses.
                                DWORD *pdwRegionIX,        // Region index for first region.
                                DWORD dwSampleRate,        // Sample rate, used to convert time parameters.
                                BOOL fNewFormat)           // DMUS_DOWNLOADINFO_INSTRUMENT2 format?
{
    DMUS_REGION * pdmRegion = (DMUS_REGION *) pvOffsetTable[*pdwRegionIX];
    *pdwRegionIX = pdmRegion->ulNextRegionIdx;  // Clear to avoid loops.
    pdmRegion->ulNextRegionIdx = 0;
    // Read the Region chunk...
    m_bKeyHigh = (BYTE) pdmRegion->RangeKey.usHigh;
    m_bKeyLow = (BYTE) pdmRegion->RangeKey.usLow;
    if (pdmRegion->fusOptions & F_RGN_OPTION_SELFNONEXCLUSIVE)
    {
        m_bAllowOverlap = TRUE;
    }
    else
    {
        m_bAllowOverlap = FALSE;
    }
    m_bGroup = (BYTE) pdmRegion->usKeyGroup;
    
    // Now, the WSMP and WLOOP chunks...
    m_vrAttenuation = (short) ((long) ((pdmRegion->WSMP.lAttenuation) * 10) >> 16);
    m_Sample.m_prFineTune = pdmRegion->WSMP.sFineTune;
    m_Sample.m_bMIDIRootKey = (BYTE) pdmRegion->WSMP.usUnityNote;
    
    if (pdmRegion->WSMP.cSampleLoops == 0)
    {
        m_Sample.m_bOneShot = TRUE;
    }
    else
    {
        m_Sample.m_dwLoopStart = pdmRegion->WLOOP[0].ulStart;
        m_Sample.m_dwLoopEnd = m_Sample.m_dwLoopStart + pdmRegion->WLOOP[0].ulLength;
        m_Sample.m_bOneShot = FALSE;
    }
    m_Sample.m_dwSampleRate = dwSampleRate;
    // Then the WAVELINK...
    if (pdmRegion->WaveLink.ulChannel != WAVELINK_CHANNEL_LEFT)
    {
        return DMUS_E_NOTMONO;
    }
    m_Sample.m_dwID = (DWORD) pdmRegion->WaveLink.ulTableIndex;
    // Does it have its own articulation?
    if (pdmRegion->ulRegionArtIdx )
    {
        if (pdmRegion->ulRegionArtIdx >= pInfo->dwNumOffsetTableEntries)
        {
            return DMUS_E_BADARTICULATION;
        }
        
        CSourceArticulation *pArticulation = new CSourceArticulation;
        if (pArticulation)
        {
            pArticulation->Init(dwSampleRate);

            HRESULT hr = pArticulation->Download( pInfo, pvOffsetTable, 
                                                  pdmRegion->ulRegionArtIdx, dwSampleRate, fNewFormat);
            if (FAILED(hr))
            {
                delete pArticulation;
                return hr;
            }
            m_pArticulation = pArticulation;
            m_pArticulation->AddRef();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}



/*****************************************************************************
 * CInstManager::DownloadInstrument()
 *****************************************************************************
 * Download an instrument to this instrument manager.  This is dispatched
 * to the various appropriate objects.
 *
 * This is called by Download() when an instrument chunk is encountered. 
 * Using the offset table to resolve linkages, it scans through the instrument,
 * parsing out regions and articulations, then finally linking the regions in the
 * instrument to the waves, which should have been previously downloaded.
*/
HRESULT CInstManager::DownloadInstrument(
    LPHANDLE phDownload,        // Pointer to download handle, to be created by synth.
    DMUS_DOWNLOADINFO *pInfo,   // DMUS_DOWNLOADINFO structure from the download chunk's head.
                                // This provides the total size of data, among other things.
    void *pvOffsetTable[],      // Offset table with addresses of all embedded structures.
    void *pvData,               // Pointer to start of download data.
    BOOL fNewFormat)            // Is this DMUS_DOWNLOADINFO_INSTRUMENT2 format download?
{
    // The download data must start with the DMUS_INSTRUMENT chunk, so cast to that.
    DMUS_INSTRUMENT *pdmInstrument = (DMUS_INSTRUMENT *) pvData;

    // Create a new CInstrument structure. This stores everything that describes an instrument, including
    // the articulations and regions.
    CInstrument *pInstrument = new CInstrument;
    if (pInstrument)
    {
        // For debugging purposes, print a trace statement to show that the instrument has actually been downloaded.
        // This only occurs in debug builds.
        Trace(1,"Downloading instrument %lx\n",pdmInstrument->ulPatch);
        pInstrument->m_dwProgram = pdmInstrument->ulPatch;

        // Start by scanning through the regions.
        DWORD dwRegionIX = pdmInstrument->ulFirstRegionIdx;
        pdmInstrument->ulFirstRegionIdx = 0; // Clear to avoid loops.
        while (dwRegionIX)
        {
            // For each region, verify that the index number is actually legal.
            if (dwRegionIX >= pInfo->dwNumOffsetTableEntries)
            {
                delete pInstrument;
                return DMUS_E_BADINSTRUMENT;
            }
            CSourceRegion *pRegion = new CSourceRegion;
            if (!pRegion)
            {
                delete pInstrument;
                return E_OUTOFMEMORY;
            }
            pInstrument->m_RegionList.AddHead(pRegion);
            // Call the region's Download method to parse the region structure and optional embedded articulation.
            HRESULT hr = pRegion->Download(pInfo, pvOffsetTable, &dwRegionIX, m_dwSampleRate, fNewFormat);
            if (FAILED(hr))
            {
                delete pInstrument;
                return hr;
            }
            EnterCriticalSection(&m_CriticalSection);
            // Once the region is parsed, we need to connect it to the wave, that should have been
            // previously downloaded into the wavepool. 
            // Because of the hash table, the linked list is never very long, so the search is quick.
            CWave *pWave = m_WavePool[pRegion->m_Sample.m_dwID % WAVE_HASH_SIZE].GetHead();
            for (;pWave;pWave = pWave->GetNext())
            {
                // Each wave has a unique ID, which the regions match up with.
                if (pRegion->m_Sample.m_dwID == pWave->m_dwID)
                {
                    pRegion->m_Sample.m_pWave = pWave;
                    pWave->AddRef();
                    pRegion->m_Sample.CopyFromWave();
                    break;
                }
            }
            LeaveCriticalSection(&m_CriticalSection);
        }
        // Once all the regions are loaded, see if we have a global articulation.
        if (pdmInstrument->ulGlobalArtIdx)
        {
            // If so load it. First check that it's a valid index.
            if (pdmInstrument->ulGlobalArtIdx >= pInfo->dwNumOffsetTableEntries)
            {
                delete pInstrument;
                return DMUS_E_BADARTICULATION;
            }
            
            // Create an articulation and have it parse the data.
            CSourceArticulation *pArticulation = new CSourceArticulation;
            if (pArticulation)
            {
                // The articulation will convert all time parameters into sample times, so it needs to know the sample rate.
                pArticulation->Init(m_dwSampleRate);

                // Parse the articulation data. Note that the fNewFormat flag indicates whether this is in the DX6 fixed
                // format articulation or the DX7 dynamic format (which is actually the same as the file format.)
                HRESULT hr = pArticulation->Download( pInfo, pvOffsetTable, 
                                                      pdmInstrument->ulGlobalArtIdx, m_dwSampleRate, fNewFormat);
                if (FAILED(hr))
                {
                    delete pArticulation;
                    return hr;
                }

                // Once the global articulation is read, scan all regions and assign the articulation to all
                // regions that don't have articulations yet.
                for (CSourceRegion *pr = pInstrument->m_RegionList.GetHead();
                     pr != NULL;
                     pr = pr->GetNext())
                {
                    if (pr->m_pArticulation == NULL)
                    {
                        pr->m_pArticulation = pArticulation;
                        pArticulation->AddRef();    
                    }
                }
                if (!pArticulation->m_wUsageCount)
                {
                    delete pArticulation;
                }
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            for (CSourceRegion *pr = pInstrument->m_RegionList.GetHead();
                 pr != NULL;
                 pr = pr->GetNext())
            {
                if (pr->m_pArticulation == NULL)
                {
                    delete pInstrument;
                    return DMUS_E_NOARTICULATION;
                }
            }
        }
        EnterCriticalSection(&m_CriticalSection);
        // If this is a GM instrument, make sure that it will be searched for last by placing it at
        // the end of the list. The DLS spec states that
        // a DLS collection with the same patch as a GM instrument will always override the GM instrument.
        if (pdmInstrument->ulFlags & DMUS_INSTRUMENT_GM_INSTRUMENT)
        {
            pInstrument->SetNext(NULL);
            m_InstrumentList[pInstrument->m_dwProgram % INSTRUMENT_HASH_SIZE].AddTail(pInstrument);
        }
        else
        {
            m_InstrumentList[pInstrument->m_dwProgram % INSTRUMENT_HASH_SIZE].AddHead(pInstrument);
        }
        LeaveCriticalSection(&m_CriticalSection);
        *phDownload = (HANDLE) pInstrument;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

/*****************************************************************************
 * CInstManager::DownloadWave()
 *****************************************************************************
 * Download a wave to this instrument manager.  It is put in the pool.
 *
 * This is called by Download when it receives a wave download chunk.
 * DownloadWave parses the wave, converts the wave data if necessary, and
 * places the wave in the wave pool, where it can subsequentley be 
 * connected to instruments. (All the waves referenced by an instrument
 * are downloaded prior to downloading the instrument itself. This makes the
 * whole process simpler and more reliable. Conversely, on unload, all 
 * waves are unloaded after the instruments that reference them.)
 */
HRESULT CInstManager::DownloadWave(
    LPHANDLE phDownload,        // Download handle, to be returned.  This will be 
                                // used by a later Unload call to reference the wave.
    DMUS_DOWNLOADINFO *pInfo,   // DMUS_DOWNLOADINFO structure from the download chunk's head. 
                                // This provides the total size of data, among other things.
    void *pvOffsetTable[],      // The table of offsets in the download data.
    void *pvData)               // Finally, the data itself.
{
    // The start of the data should align with a DMUS_WAVE header.
    DMUS_WAVE *pdmWave = (DMUS_WAVE *) pvData; 

    // Make sure that the wave data is properly uncompressed PCM data.
    if (pdmWave->WaveformatEx.wFormatTag != WAVE_FORMAT_PCM)
    {
        return DMUS_E_NOTPCM;
    }
    
    // The data can only be mono format.
    if (pdmWave->WaveformatEx.nChannels != 1)
    {
        return DMUS_E_NOTMONO;
    }

    // Ensure that the index to the wave data is a legal value in the offset table. 
    if (pdmWave->ulWaveDataIdx >= pInfo->dwNumOffsetTableEntries)
    {
        return DMUS_E_BADWAVE;
    }

    // Create a wave object and parse the data into it.
    CWave *pWave = new CWave;
    if (pWave)
    {   
        // We've already verified that the wave data index is a valid index, so go ahead
        // and use the offset table to convert that into a valid DMUS_WAVEDATA structure pointer. 
        DMUS_WAVEDATA *pdmWaveData= (DMUS_WAVEDATA *) 
            pvOffsetTable[pdmWave->ulWaveDataIdx];
        Trace(3,"Downloading wave %ld\n",pInfo->dwDLId);
        // Now initialize the CWave structure.
        pWave->m_dwID = pInfo->dwDLId;
        pWave->m_pWaveMem = pInfo;
        pWave->m_hUserData = NULL;
        pWave->m_lpFreeHandle = NULL;
        pWave->m_dwSampleLength = pdmWaveData->cbSize;
        pWave->m_pnWave = (short *) &pdmWaveData->byData[0];
        pWave->m_dwSampleRate = pdmWave->WaveformatEx.nSamplesPerSec;

        // If the wave data is 8 bit, the data needs to be converted to
        // two's complement representation.
        if (pdmWave->WaveformatEx.wBitsPerSample == 8)
        {
            pWave->m_bSampleType = SFORMAT_8;
            DWORD dwX;
            char *pData = (char *) &pdmWaveData->byData[0];
            for (dwX = 0; dwX < pWave->m_dwSampleLength; dwX++)
            {
                pData[dwX] -= (char) 128;
            }
        }
        else if (pdmWave->WaveformatEx.wBitsPerSample == 16)
        {
            pWave->m_dwSampleLength >>= 1;
            pWave->m_bSampleType = SFORMAT_16;
        }
        else
        {
            delete pWave;
            return DMUS_E_BADWAVE;
        }
        pWave->m_dwSampleLength++;  // We always add one sample to the end for interpolation.
        EnterCriticalSection(&m_CriticalSection);

        // Place the wave in a hash table of wave lists to increase access speed.
        m_WavePool[pWave->m_dwID % WAVE_HASH_SIZE].AddHead(pWave);
        LeaveCriticalSection(&m_CriticalSection);

        // Return the pointer to the internal CWave object as the handle. This will
        // be used in a subsequant call to unload the wave object.
        *phDownload = (HANDLE) pWave;
        pWave->AddRef();
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

/*****************************************************************************
 * CInstManager::Download()
 *****************************************************************************
 * Download to this instrument manager.
 *
 * This is the heart of the DLS download mechanism, and is called from CSynth::Download().
 * It verifies the offset table and converts it into physical addresses. Then, 
 * depending on whether this is a wave or instrument download, it calls the 
 * appropriate method.
 * 
 * The data is stored in a continuous chunk of memory,
 * pointed to by pvData. However, at the head of the chunk are two data 
 * structures, which define the nature of the data to follow. These are 
 * the DMUS_DOWNLOADINFO and DMUS_OFFSETTABLE structures. DMUS_DOWNLOADINFO
 * is a header which describes how to parse the data, including
 * its size and intention (wave or instrument.) DMUS_OFFSETTABLE provides 
 * a set of indexes into the data segment which follows. All parsing through the data
 * is managed through this table. Whenever a structure in the data references 
 * another structure, it describes it by an index into the offset table. 
 * The offset table then converts it into a physical address in the memory. 
 * This allows the synthesizer to do bounds checking on all
 * references, making the implementation more robust. In kernel mode 
 * implementations, the driver can make its own private copy of the offset 
 * table, and so ensure that an application in user mode can not mess with 
 * its referencing and cause a crash. This implementation also makes a unique copy.
 * 
 * Looking closer at DMUS_DOWNLOADINFO, DMUS_DOWNLOADINFO.dwDLType 
 * determines the type of data being downloaded. It is set to 
 * DMUS_DOWNLOADINFO_INSTRUMENT or DMUS_DOWNLOADINFO_INSTRUMENT2
 * for an instrument, DMUS_DOWNLOADINFO_WAVE for a wave. As new data types emerge,
 * identifiers will be allocated for them.
 * DMUS_DOWNLOADINFO.dwDLId holds a unique 32 bit identifier for the object. 
 * This identifier is used to connect objects together. For example, it is used
 * to connect waves to instruments. 
 * DMUS_DOWNLOADINFO.dwNumOffsetTableEntries describes the number of entries in 
 * the DMUS_OFFSETTABLE structure, which follows. 
 * Finally, DMUS_DOWNLOADINFO.cbSizeData states the total size of the 
 * memory chunk, which follows the offset table.
 * 
 * Depending on the synthesizer implementation, it may decide to use the memory 
 * in the download chunk. This reduces memory allocation and freeing, since, if enough 
 * memory has been allocated to store a wave, that same memory can be used by 
 * the synthesizer to store it for playback. So, the synthesizer has the option 
 * of hanging on to the memory, returning its decision in the pbFree parameter. 
 * If it does keep the memory, then the caller must not free it. Later, the 
 * CSynth::Unload command has a callback mechanism to handle asynchronous 
 * freeing of the memory once the unload request has been made.
 */
HRESULT CInstManager::Download(LPHANDLE phDownload, // Download handle, to be returned.
                               void * pvData,       // Pointer to download data chunk.
                               LPBOOL pbFree)       // Pointer to boolean whether data can 
                                                    // be freed now or held until unload.
{
    V_INAME(IDirectMusicSynth::Download);
    V_BUFPTR_READ(pvData,sizeof(DMUS_DOWNLOADINFO));

    HRESULT hr = DMUS_E_UNKNOWNDOWNLOAD;
    
    // We need an array of pointers to reproduce the offset table, which is used to link to
    // specific structures in the download chunk. 
    void ** ppvOffsetTable;     // Array of pointers to chunks in data.

    // At the head of the download chunk is the download header, in the form of a DMUS_DOWNLOADINFO structure.
    DMUS_DOWNLOADINFO * pInfo = (DMUS_DOWNLOADINFO *) pvData;

    // It is immediately followed by the offset table, so we cast a pointer to that.
    DMUS_OFFSETTABLE* pOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvData) + sizeof(DMUS_DOWNLOADINFO));
    char *pcData = (char *) pvData;

    V_BUFPTR_READ(pvData,pInfo->cbSize);

    // Create a copy of the offset table. 
    ppvOffsetTable = new void *[pInfo->dwNumOffsetTableEntries];
    if (ppvOffsetTable) // Create the pointer array and validate.
    {
        // Each index in the offset table is an offset from the beginning of the download chunk to 
        // a position in the memory where a specific structure resides. 
        // Scan through the table and convert these offsets into actual memory 
        // addresses, and store these in the ppvOfsetTable array. These
        // will be used by the parsing code to resolve indexes to actual
        // memory addresses.
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < pInfo->dwNumOffsetTableEntries; dwIndex++)
        {
            // First, make sure the offset is not out of bounds. 
            if (pOffsetTable->ulOffsetTable[dwIndex] >= pInfo->cbSize)
            {
                delete [] ppvOffsetTable;
                return DMUS_E_BADOFFSETTABLE;   // Bad!
            }
            // Go ahead and calculate the actual memory address and store it. 
            ppvOffsetTable[dwIndex] = (void *) &pcData[pOffsetTable->ulOffsetTable[dwIndex]];
        }

        // Once the offset table is constructed, we can pass it to the appropriate parsing routine.
        // There are three types of download chunks: DMUS_DOWNLOADINFO_INSTRUMENT,
        // DMUS_DOWNLOADINFO_INSTRUMENT2, and DMUS_DOWNLOADINFO_WAVE. 
        // The two instrument formats exist because DMUS_DOWNLOADINFO_INSTRUMENT was changed to
        // support a variable articulation to support DLS2 in the DX7 timeframe. In truth,
        // only DMUS_DOWNLOADINFO_INSTRUMENT2 and DMUS_DOWNLOADINFO_WAVE need be supported, 
        // but we continue with DMUS_DOWNLOADINFO_INSTRUMENT support in this example.
        // Depending on the type of download, we call the appropriate method, which then
        // parses the data.
        // To let dmusic understand that it does support the DMUS_DOWNLOADINFO_INSTRUMENT2,
        // the synth must respond positively to the KsProperty Query GUID_DMUS_PROP_INSTRUMENT2,
        // request (please see CUserModeSynth::KsProperty() for implementation details.)
        if (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT) // Instrument.
        {
            // Instrument does not need to keep the  download chunk allocated, so indicate that
            // the caller can free it.
            *pbFree = TRUE;

            // Call the download instrument method, indicating that this is a DX6 format download.
            hr = DownloadInstrument(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0],FALSE); 
        }
        if (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT2) // New instrument format.
        {
            *pbFree = TRUE;

            // Call the download instrument method, indicating that this is a DX7 or up format download.
            hr = DownloadInstrument(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0],TRUE); 
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_WAVE) // Wave.
        {
            // Wave does need to keep the  download chunk allocated, because it includes the
            // wave data buffer, which it will play directly out of, so indicate that
            // the caller must not free it until it is unloaded.
            *pbFree = FALSE;
            hr = DownloadWave(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]); 
        }
        delete [] ppvOffsetTable;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

/*****************************************************************************
 * CInstManager::Unload()
 *****************************************************************************
 * Unload the given previous download.  Delete the instruments and waves.
 * 
 * The unload method is called when it is unloading a previously downloaded 
 * instrument or wave chunk. This instructs the synthesizer to find the object that 
 * was downloaded (identified by the handle, hDownload, that was generated by the 
 * call to Download) and remove it.
 *
 * If the object was using the original download chunk, it needs to notify the caller 
 * when it is done using it so the memory can then be freed. This is not necessarily 
 * at the time of the download call because wave data may currently be in use by a 
 * performing note. So, a pointer to a callback function is also provided and the 
 * synthesizer must call this function at the time the memory is no longer in use.
 */
HRESULT CInstManager::Unload(
    HANDLE hDownload,                                   // Handle of previously downloaded 
                                                        // wave or instrument.
    HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),   // Callback function for releasing 
                                                        // downloaded memory
    HANDLE hUserData)                                   // Parameter to pass to callback,
                                                        // to indicate which download is freed.
{
    DWORD dwIndex;
    EnterCriticalSection(&m_CriticalSection);

    // First, check to see if this is an instrument. 
    // We keep all the instruments in a hash table to speed up access.
    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
        {
            // If the instrument matches the download handle, remove it from the list
            // and delete it. There is no need to callback for releasing the memory because
            // the synthesizer did not hang on to the original downloaded instrument memory.
            if (pInstrument == (CInstrument *) hDownload) 
            {
                // To help debug, print the patch number of the unloaded instrument.
                Trace(1,"Unloading instrument %lx\n",pInstrument->m_dwProgram);
                m_InstrumentList[dwIndex].Remove(pInstrument);
                delete pInstrument;
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }

    // If it wasn't an instrument, try the wave list. 
    // Again, they are arranged in a hash table to increase access speed.
    for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
    {
        CWave *pWave = m_WavePool[dwIndex].GetHead();
        for (;pWave != NULL;pWave = pWave->GetNext())
        {
            // If the wave matches the download handle, remove it from the list.
            // Also, store the callback function, lpFreeHandle, and associated instance 
            // parameter, hUserData, in the wave. Remove the wave from the wave pool, so 
            // it can no longer be connected with another instrument.
            //
            // When the last instance of a voice that is playing the wave finishes, 
            // lpFreeHandle will be called and the caller will be able to free the memory.
            // Usually, the wave is not currently being played and this happens instantly.
            if (pWave == (CWave *) hDownload)
            {
                Trace(3,"Unloading wave %ld\n",pWave->m_dwID);
                m_WavePool[dwIndex].Remove(pWave);
                pWave->m_hUserData = hUserData;
                pWave->m_lpFreeHandle = lpFreeHandle;
                pWave->Release();
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return E_FAIL;
}


=== ddksynth/kernhelp.cpp ===
/*
    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
*/

//
// KernHelp.cpp
//
// Wrappers for kernel functions to make synth core cross compilable
//

#define STR_MODULENAME "DDKSynth.sys:KernHelp: "

extern "C" {
#include <wdm.h>
};

#include "ksdebug.h"
#include "KernHelp.h"

#pragma code_seg()
/*****************************************************************************
 * InitializeCriticalSection()
 *****************************************************************************
 * In kernel mode, we use a KMUTEX to implement our critical section.
 * Initialize the KMUTEX.
 */
VOID InitializeCriticalSection(LPCRITICAL_SECTION CritSect)
{
    KeInitializeMutex((PKMUTEX)CritSect, 1);
}

/*****************************************************************************
 * EnterCriticalSection()
 *****************************************************************************
 * In kernel mode, we use a KMUTEX to implement our critical section.
 * Grab (wait for) the KMUTEX.
 */
VOID EnterCriticalSection(LPCRITICAL_SECTION CritSect)
{
    KeWaitForSingleObject((PKMUTEX)CritSect,
                          Executive,
                          KernelMode,
                          FALSE,
                          0);

}

/*****************************************************************************
 * LeaveCriticalSection()
 *****************************************************************************
 * In kernel mode, we use a KMUTEX to implement our critical section.
 * Release the KMUTEX.
 */
VOID LeaveCriticalSection(LPCRITICAL_SECTION CritSect)
{
    KeReleaseMutex((PKMUTEX)CritSect, FALSE);
}

/*****************************************************************************
 * DeleteCriticalSection()
 *****************************************************************************
 * In kernel mode, we use a KMUTEX to implement our critical section.
 * No need to delete anything.
 */
VOID DeleteCriticalSection(LPCRITICAL_SECTION CritSect)
{
    // NOP in kernel
    //
}

// GetRegValueDword
//
// Must be called at passive level
//
/*****************************************************************************
 * GetRegValueDword()
 *****************************************************************************
 * Convenience function to encapsulate registry reads.
 */
int GetRegValueDword(LPTSTR RegPath,LPTSTR ValueName,PULONG Value)
{
    int                             ReturnValue = 0;
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle;
    KEY_VALUE_PARTIAL_INFORMATION   *Information;
    ULONG                           InformationSize;
    UNICODE_STRING                  UnicodeRegPath;
    UNICODE_STRING                  UnicodeValueName;

    RtlInitUnicodeString(&UnicodeRegPath, RegPath);
    RtlInitUnicodeString(&UnicodeValueName, ValueName);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeRegPath,
                               0,           // Flags
                               NULL,        // Root directory
                               NULL);       // Security descriptor

    Status = ZwOpenKey(&KeyHandle,
                       KEY_QUERY_VALUE,
                       &ObjectAttributes);
    if (Status != STATUS_SUCCESS)
    {
        return 0;
    }

    InformationSize = sizeof(Information) + sizeof(ULONG);
    Information = (KEY_VALUE_PARTIAL_INFORMATION*)ExAllocatePoolWithTag(PagedPool, InformationSize,'ISmD'); //  DmSI

    if (Information == NULL)
    {
        ZwClose(KeyHandle);
        return 0;
    }

    Status = ZwQueryValueKey(KeyHandle,
                             &UnicodeValueName,
                             KeyValuePartialInformation,
                             Information,
                             sizeof(Information),
                             &InformationSize);
    if (Status == STATUS_SUCCESS)
    {
        if (Information->Type == REG_DWORD && Information->DataLength == sizeof(ULONG))
        {
            RtlCopyMemory(Value, Information->Data, sizeof(ULONG));
            ReturnValue = 1;
        }
    }                                
                                    
    ExFreePool(Information);
    ZwClose(KeyHandle);

    return ReturnValue;                                
}

/*****************************************************************************
 * GetTheCurrentTime()
 *****************************************************************************
 * Get the current time, in milliseconds (KeQuerySystemTime returns units of
 * 100ns each).
 */
ULONG GetTheCurrentTime()
{
    LARGE_INTEGER Time;

    KeQuerySystemTime(&Time);

    return (ULONG)(Time.QuadPart / (10 * 1000));
}


/*****************************************************************************
 * KernHelpGetSysAddrForMdl()
 *****************************************************************************
 * Safely map the MDL to system address space. This mapping
 * may fail "when the system runs out of system PTEs", and
 * without the flag set below, this condition causes a bugcheck
 * rather than a NULL return.
 */
PVOID KernHelpGetSysAddrForMdl(PMDL pMdl)
{
    PVOID MappedAddress;
    CSHORT LocalCopyOfMdlFlagBit;

    // Note the manipulation of the MDL flags is only done if needed.
    // The driver is responsible for ensuring that it is not simultaneously
    // modifying this field anywhere else and synchronizing if needed.
    //

    LocalCopyOfMdlFlagBit = (pMdl->MdlFlags & MDL_MAPPING_CAN_FAIL);

    if (LocalCopyOfMdlFlagBit == 0) {
        pMdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;
    }

    MappedAddress = MmGetSystemAddressForMdl(pMdl);

    //
    // Carefully restore only the single "can-fail" bit state.  This is
    // because the call above will change the state of other flag bits and
    // we don't want this restore to wipe out those changes.  Wiping out the
    // other changes will cause not-so-obvious effects like eventually
    // exhausting the system PTE pool and other resources, which will crash
    // the entire system.
    //

    if (LocalCopyOfMdlFlagBit == 0) {
        pMdl->MdlFlags &= ~MDL_MAPPING_CAN_FAIL;
    }

    return MappedAddress;
}


=== ddksynth/kernhelp.h ===
/*
    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
*/

#ifndef _KernHelp_
#define _KernHelp_

// Use kernel mutex to implement critical section
//
typedef KMUTEX CRITICAL_SECTION;
typedef CRITICAL_SECTION *LPCRITICAL_SECTION;

VOID InitializeCriticalSection( LPCRITICAL_SECTION);
VOID EnterCriticalSection(      LPCRITICAL_SECTION);
VOID LeaveCriticalSection(      LPCRITICAL_SECTION);
VOID DeleteCriticalSection(     LPCRITICAL_SECTION);

// We have very little registry work to do, so just encapsulate the
// entire process
//
int GetRegValueDword(LPTSTR RegPath,LPTSTR ValueName,PULONG Value);

ULONG GetTheCurrentTime();

PVOID KernHelpGetSysAddrForMdl(PMDL pMdl);


#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_

/*****************************************************************************
 * operator new()
 *****************************************************************************
 * Overload new to allocate from PagedPool, with our pooltag.
 */
inline void* __cdecl operator new
(
    size_t    iSize
)
{
    //  Replace 'ySkD' with a tag appropriate to your product.
    PVOID result = ExAllocatePoolWithTag(PagedPool, iSize, 'ySkD');

    if (result)
    {
        RtlZeroMemory(result, iSize);
    }
#if DBG
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("Couldn't allocate paged pool: %d bytes", iSize));
    }
#endif // DBG
    return result;
}

/*****************************************************************************
 * operator new
 *****************************************************************************
 * Overload new to allocate with our pooltag.
 * Allocates from PagedPool or NonPagedPool, as specified.
 */
inline PVOID operator new
(
    size_t    iSize,
    POOL_TYPE poolType
)
{
    //  Replace 'ySkD' with a tag appropriate to your product.
    PVOID result = ExAllocatePoolWithTag(PagedPool, iSize, 'ySkD');
    if (result)
    {
        RtlZeroMemory(result, iSize);
    }
#if DBG
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("Couldn't allocate poolType(%d): %d bytes", (ULONG)poolType, iSize));
    }
#endif // DBG

    return result;
}

/*****************************************************************************
 * operator new()
 *****************************************************************************
 * Overload new to allocate with a specified allocation tag.
 * Allocates from PagedPool or NonPagedPool, as specified.
 */
inline PVOID operator new
(
    size_t      iSize,
    POOL_TYPE   poolType,
    ULONG       tag
)
{
    PVOID result = ExAllocatePoolWithTag(poolType, iSize, tag);

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }
#if DBG
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("Couldn't allocate tagged poolType(%d): %d bytes", 
            (ULONG)poolType, iSize));
    }
#endif // DBG

    return result;
}

/*****************************************************************************
 * operator delete()
 *****************************************************************************
 * Delete function.
 */
inline void __cdecl operator delete
(
    PVOID pVoid
)
{
    ExFreePool(pVoid);
}


#endif //!_NEW_DELETE_OPERATORS_

// Debug trace facility
//
#define DM_DEBUG_CRITICAL       DEBUGLVL_ERROR   // Used to include critical messages
#define DM_DEBUG_NON_CRITICAL   DEBUGLVL_TERSE   // Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS         DEBUGLVL_VERBOSE // Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW      DEBUGLVL_BLAB    // Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL            DEBUGLVL_BLAB    // Used to include all debug messages

#if DBG
#define Trace 
#define Trace0(lvl, fstr) \
    _DbgPrintF(lvl, (fstr))
#define Trace1(lvl, fstr, arg1) \
    _DbgPrintF(lvl, (fstr, arg1))
#define Trace2(lvl, fstr, arg1, arg2) \
    _DbgPrintF(lvl, (fstr, arg1, arg2))
#define Trace3(lvl, fstr, arg1, arg2, arg3) \
    _DbgPrintF(lvl, (fstr, arg1, arg2, arg3))
#define Trace4(lvl, fstr, arg1, arg2, arg3, arg4) \
    _DbgPrintF(lvl, (fstr, arg1, arg2, arg3, arg4))
#else
#define Trace
#define Trace0
#define Trace1
#define Trace2
#define Trace3
#define Trace4
#endif

#define assert ASSERT

// Paramter validation unused
//
#define V_INAME(x)
#define V_BUFPTR_READ(p,cb)


#endif // _KernHelp_


=== ddksynth/makefile ===
#############################################################################
#
#       Copyright (c) 1991-2000 Microsoft Corporation
#       All Rights Reserved.
#
#       Makefile for wdm\audio\ddksynth
#
#############################################################################

## Define WIN95_BUILD to build in the memphis
## build enviroment

!IFDEF WIN95_BUILD

ROOT = ..\..\..\..\..

IS_32   = TRUE
IS_OEM  = TRUE
DEVICEDIR = DDKSYNTH
COMMONMKFILE = $(DEVICEDIR).mk
DEPENDTARGETS = debug

!include $(ROOT)\dev\master.mk

## NT BUILD ENVIROMENT
!ELSE

#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the driver components of the Windows NT DDK.
#
!INCLUDE $(NTMAKEENV)\makefile.def

!ENDIF


=== ddksynth/midi.cpp ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//      MIDI.cpp
//

#include "common.h"

#define STR_MODULENAME "DDKSynth.sys:Midi: "


#include "math.h"

#pragma code_seg()
#pragma data_seg()

CMIDIDataList * CMIDIRecorder::m_sFreeList = (CMIDIDataList *) NULL;
//
// Array for converting MIDI to volume.
// value = log10((index/127)^4)*1000 where index = 0..127
//
const VREL vrMIDIToVREL[] = {
//  0       1       2       3       4       5       6       7
    -9600,  -8415,  -7211,  -6506,  -6006,  -5619,  -5302,  -5034,
    -4802,  -4598,  -4415,  -4249,  -4098,  -3959,  -3830,  -3710,
    -3598,  -3493,  -3394,  -3300,  -3211,  -3126,  -3045,  -2968,
    -2894,  -2823,  -2755,  -2689,  -2626,  -2565,  -2506,  -2449,
    -2394,  -2341,  -2289,  -2238,  -2190,  -2142,  -2096,  -2050,
    -2006,  -1964,  -1922,  -1881,  -1841,  -1802,  -1764,  -1726,
    -1690,  -1654,  -1619,  -1584,  -1551,  -1518,  -1485,  -1453,
    -1422,  -1391,  -1361,  -1331,  -1302,  -1273,  -1245,  -1217,
    -1190,  -1163,  -1137,  -1110,  -1085,  -1059,  -1034,  -1010,
    -985,   -961,   -938,   -914,   -891,   -869,   -846,   -824,
    -802,   -781,   -759,   -738,   -718,   -697,   -677,   -657,
    -637,   -617,   -598,   -579,   -560,   -541,   -522,   -504,
    -486,   -468,   -450,   -432,   -415,   -397,   -380,   -363,
    -347,   -330,   -313,   -297,   -281,   -265,   -249,   -233,
    -218,   -202,   -187,   -172,   -157,   -142,   -127,   -113,
    -98,    -84,    -69,    -55,    -41,    -27,    -13,    0
};

/*****************************************************************************
 * Constructor for CMidiData object
 *****************************************************************************/
/*****************************************************************************
 * CMIDIData::CMIDIData()
 *****************************************************************************
 * Constructor for this object.
 */
CMIDIData::CMIDIData() 
{
    m_stTime = 0;
    m_lData = 0;            
}

/*****************************************************************************
 * CMIDIRecorder::CMIDIRecorder()
 *****************************************************************************
 * Constructor for this object.
 */
CMIDIRecorder::CMIDIRecorder()
{
    m_lCurrentData = 0;
    m_stCurrentTime = 0;
    KeInitializeSpinLock(&m_SpinLock);
}

static USHORT fAlreadyDone = 0;

/*****************************************************************************
 * CMIDIRecorder::~CMIDIRecorder()
 *****************************************************************************
 * Destructor for this object.
 */
CMIDIRecorder::~CMIDIRecorder()
{
    ClearMIDI(0x7FFFFFFF);

    fAlreadyDone--;
    if (fAlreadyDone == 0)
    {
        if (CMIDIRecorder::m_sFreeList)
        {
            while (!CMIDIRecorder::m_sFreeList->IsEmpty())
            {
                CMIDIData *event;
                event = CMIDIRecorder::m_sFreeList->RemoveHead();
                delete event;
            }
            delete CMIDIRecorder::m_sFreeList;
            CMIDIRecorder::m_sFreeList = NULL;
        }
    }
}

/*****************************************************************************
 * CMIDIRecorder::Init()
 *****************************************************************************
 * Initialize the CMIDIRecorder object.  Make a list of CMIDIData objects for later.
 */
void CMIDIRecorder::Init()
{
    int nIndex;
    if (!fAlreadyDone)
    {
        CMIDIRecorder::m_sFreeList = new(NonPagedPool,'LSmD') CMIDIDataList;    //  DmSL
        if (!CMIDIRecorder::m_sFreeList)
        {
            return;
        }
        CMIDIRecorder::m_sFreeList->RemoveAll();
        for (nIndex = 0; nIndex < MAX_MIDI_EVENTS; nIndex++)
        {
            CMIDIData *event;
            if (event = new(NonPagedPool,'MSmD') CMIDIData)         //  DmSM
            {
                CMIDIRecorder::m_sFreeList->AddHead(event);
            }
        }
        fAlreadyDone++;
    }
}

/*****************************************************************************
 * CMIDIRecorder::GrabSpinLock()
 *****************************************************************************
 * In kernel mode, acquire the spinlock.
 */
inline void CMIDIRecorder::GrabSpinLock()
{
    KeAcquireSpinLock(&m_SpinLock, &m_OldIrql);
}

/*****************************************************************************
 * CMIDIRecorder::ReleaseSpinLock()
 *****************************************************************************
 * In kernel mode, release the spinlock.
 */
inline void CMIDIRecorder::ReleaseSpinLock()
{
    KeReleaseSpinLock(&m_SpinLock, m_OldIrql);
}

/*****************************************************************************
 * CMIDIRecorder::FlushMIDI()
 *****************************************************************************
 * Remove all events from the event list, and put them back on the free list.
 */
BOOL CMIDIRecorder::FlushMIDI(STIME stTime)
{
    GrabSpinLock();

    CMIDIData *pMD;
    CMIDIData *pLast = NULL;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            if (pLast == NULL)
            {
                m_EventList.RemoveAll();
            }
            else
            {
                pLast->SetNext(NULL);
            }
            if (CMIDIRecorder::m_sFreeList)
            {
                CMIDIRecorder::m_sFreeList->Cat(pMD);
            }
            break;
        }
        pLast = pMD;
    }
    
    BOOL fIsEmpty = m_EventList.IsEmpty();

    ReleaseSpinLock();

    return fIsEmpty;
}

/*****************************************************************************
 * CMIDIRecorder::ClearMIDI()
 *****************************************************************************
 * Clear out any MIDI that is before the given time.
 */
BOOL CMIDIRecorder::ClearMIDI(STIME stTime)
{
    GrabSpinLock();

    CMIDIData *pMD;
    for (;pMD = m_EventList.GetHead();)
    {
        if (pMD->m_stTime < stTime)
        {
            m_EventList.RemoveHead();
            m_stCurrentTime = pMD->m_stTime;
            m_lCurrentData = pMD->m_lData;
            if (CMIDIRecorder::m_sFreeList)
            {
                CMIDIRecorder::m_sFreeList->AddHead(pMD);
            }
            else
            {
                delete pMD; 
            }
        }
        else break;
    }

    BOOL fIsEmpty = m_EventList.IsEmpty();

    ReleaseSpinLock();

    return fIsEmpty;
}

/*****************************************************************************
 * CMIDIRecorder::VelocityToVolume()
 *****************************************************************************
 * Translate from 16-bit velocity to a VREL volume (dB).
 */
VREL CMIDIRecorder::VelocityToVolume(WORD nVelocity)
{
    return (::vrMIDIToVREL[nVelocity]);
}

/*****************************************************************************
 * CMIDIRecorder::RecordMIDI()
 *****************************************************************************
 * Queue up a given note at a given time.  Use an element from the free pool,
 * or allocate a new one if the pool is exhausted.
 */
BOOL CMIDIRecorder::RecordMIDI(STIME stTime, long lData)
{
    GrabSpinLock();

    CMIDIData *pMD = NULL;
    if (CMIDIRecorder::m_sFreeList)
    {
        pMD = CMIDIRecorder::m_sFreeList->RemoveHead();
    }

    if (pMD == NULL)
    {
	    pMD = new(NonPagedPool,'MSmD') CMIDIData;   //  DmSM
    }

    if (pMD != NULL)
    {
	    CMIDIData *pScan = m_EventList.GetHead();
	    CMIDIData *pNext;

        pMD->m_stTime = stTime;
        pMD->m_lData = lData;
		if (pScan == NULL)
		{
			m_EventList.AddHead(pMD);
		}
		else
		{
			if (pScan->m_stTime > stTime)
			{
				m_EventList.AddHead(pMD);
			}
			else
			{
				for (;pScan != NULL; pScan = pNext)
				{
					pNext = pScan->GetNext();
					if (pNext == NULL)
					{
						pScan->SetNext(pMD);
					}
					else
					{
						if (pNext->m_stTime > stTime)
						{
							pMD->SetNext(pNext);
							pScan->SetNext(pMD);
							break;
						}
					}
				}
			}
		}
        ReleaseSpinLock();
        return (TRUE);
    }

    ReleaseSpinLock();
    Trace(1,"MIDI Event pool empty.\n");
    return (FALSE);
}

/*****************************************************************************
 * CMIDIRecorder::GetData()
 *****************************************************************************
 * Retrieve any data that is at or before the given time.
 */
long CMIDIRecorder::GetData(STIME stTime)
{
    GrabSpinLock();

    CMIDIData *pMD = m_EventList.GetHead();
    long lData = m_lCurrentData;
    for (;pMD;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime > stTime)
        {
            break;
        }
        lData = pMD->m_lData;
    }

    ReleaseSpinLock();

    return (lData);
}

/*****************************************************************************
 * CNoteIn::RecordNote()
 *****************************************************************************
 * Record the given note object into the NoteIn receptor.
 */
BOOL CNoteIn::RecordNote(STIME stTime, CNote * pNote)
{
	long lData = pNote->m_bPart << 16;
	lData |= pNote->m_bKey << 8;
	lData |= pNote->m_bVelocity;
	return (RecordMIDI(stTime,lData));
}

/*****************************************************************************
 * CNoteIn::RecordEvent()
 *****************************************************************************
 * Record the given note object into the NoteIn receptor.
 */
BOOL CNoteIn::RecordEvent(STIME stTime, DWORD dwPart, DWORD dwCommand, BYTE bData)
{
	long lData = dwPart;
	lData <<= 8;
	lData |= dwCommand;
	lData <<= 8;
	lData |= bData;
	return (RecordMIDI(stTime,lData));	
}

/*****************************************************************************
 * CNoteIn::GetNote()
 *****************************************************************************
 * Retrieve the first note at or before the given time.
 */
BOOL CNoteIn::GetNote(STIME stTime, CNote * pNote)
{
    GrabSpinLock();

    CMIDIData *pMD = m_EventList.GetHead();
    if (pMD != NULL)
    {
        if (pMD->m_stTime <= stTime)
        {
            pNote->m_stTime = pMD->m_stTime;
            pNote->m_bPart = (BYTE) (pMD->m_lData >> 16);
            pNote->m_bKey = (BYTE) (pMD->m_lData >> 8) & 0xFF;
            pNote->m_bVelocity = (BYTE) pMD->m_lData & 0xFF;
            m_EventList.RemoveHead();
            if (CMIDIRecorder::m_sFreeList)
            {
                CMIDIRecorder::m_sFreeList->AddHead(pMD);
            }
            else
            {
                delete pMD; 
            }
            ReleaseSpinLock();
            return (TRUE);
        }
    }

    ReleaseSpinLock();
    return (FALSE);
}

/*****************************************************************************
 * CNoteIn::FlushMIDI()
 *****************************************************************************
 * Flush out any MIDI after the given time, with attention given 
 * to special events.
 */
void CNoteIn::FlushMIDI(STIME stTime)
{
    GrabSpinLock();

    CMIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            pMD->m_stTime = stTime;     // Play now.

            BYTE command = (BYTE) ((pMD->m_lData & 0x0000FF00) >> 8);
            if (command < NOTE_PROGRAMCHANGE)
            {
                pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
            }
            //  otherwise it is a special command
            //  so don't mess with the velocity
        }
    }

    ReleaseSpinLock();
}


/*****************************************************************************
 * CNoteIn::FlushPart()
 *****************************************************************************
 * Flush the given channel, with attention given to special events.
 */
void CNoteIn::FlushPart(STIME stTime, BYTE bChannel)
{
    GrabSpinLock();

    CMIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
			if (bChannel == (BYTE) (pMD->m_lData >> 16))
			{
                pMD->m_stTime = stTime;     // Play now.

                BYTE command = (BYTE) ((pMD->m_lData & 0x0000FF00) >> 8);
                if (command < NOTE_PROGRAMCHANGE)
                {
                    pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
                }
                //  otherwise it is a special command
                //  so don't mess with the velocity
			}
		}
    }

    ReleaseSpinLock();
}

/*****************************************************************************
 * CModWheelIn::GetModulation()
 *****************************************************************************
 * Get the modulation data.
 */
DWORD CModWheelIn::GetModulation(STIME stTime)
{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}

/*****************************************************************************
 * CPitchBendIn::CPitchBendIn()
 *****************************************************************************
 * Constructor for this object.
 */
CPitchBendIn::CPitchBendIn()
{
    m_lCurrentData = 0x2000;	// initially at midpoint, no bend
    m_prRange = 200;           // whole tone range by default.
}

/*****************************************************************************
 * CPitchBendIn::GetPitch()
 *****************************************************************************
 * Get the pitch data.
 * Note: we don't keep a time-stamped range.
 * If people are changing the pitch bend range often, this won't work right,
 * but that didn't seem likely enough to warrant a new list.
 */
PREL CPitchBendIn::GetPitch(STIME stTime)
{
    PREL prResult = (PREL) CMIDIRecorder::GetData(stTime);
    prResult -= 0x2000;         // Subtract MIDI Midpoint.
    prResult *= m_prRange;	// adjust by current range
    prResult >>= 13;
    return (prResult);
}

/*****************************************************************************
 * CVolumeIn::CVolumeIn()
 *****************************************************************************
 * Constructor for this object.
 */
CVolumeIn::CVolumeIn()
{
    m_lCurrentData = 100;
}

/*****************************************************************************
 * CVolumeIn::GetVolume()
 *****************************************************************************
 * Get the volume data.
 */
VREL CVolumeIn::GetVolume(STIME stTime)
{
    long lResult = CMIDIRecorder::GetData(stTime);
    return (::vrMIDIToVREL[lResult]);
}

/*****************************************************************************
 * CExpressionIn::CExpressionIn()
 *****************************************************************************
 * Constructor for this object.
 */
CExpressionIn::CExpressionIn()
{
    m_lCurrentData = 127;
}

/*****************************************************************************
 * CExpressionIn::GetVolume()
 *****************************************************************************
 * Get the volume data.
 */
VREL CExpressionIn::GetVolume(STIME stTime)
{
    long lResult = CMIDIRecorder::GetData(stTime);
    return (::vrMIDIToVREL[lResult]);
}

/*****************************************************************************
 * CPanIn::CPanIn()
 *****************************************************************************
 * Constructor for this object.
 */
CPanIn::CPanIn()
{
    m_lCurrentData = 64;
}

/*****************************************************************************
 * CPanIn::GetPan()
 *****************************************************************************
 * Get the pan data.
 */
long CPanIn::GetPan(STIME stTime)
{
    long lResult = (long) CMIDIRecorder::GetData(stTime);
    return (lResult);
}


=== ddksynth/miniport.cpp ===
/*

    DirectMusic Software Synthesizer Miniport

    Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
*/

#include "common.h"
#include "private.h"
#include <math.h>

#define STR_MODULENAME "DDKSynth.sys:Miniport: "


/* NYI:
    more sample rates?
*/
VOID PutMessageWorker(PVOID Param);

// Property handler
//
NTSTATUS PropertyHandler_Support(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_Effects(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_Synth(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthCaps(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthDls(IN PPCPROPERTY_REQUEST);



/*****************************************************************************
 * PinDataRangesStream[]
 *****************************************************************************
 * Structures indicating range of valid format values for streaming pins.
 * If your device can also support legacy MIDI, include a second data range
 * here that supports KSDATAFORMAT_SUBTYPE_MIDI.
 */
static const
    KSDATARANGE_MUSIC
    PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_MUSIC),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
        },
        STATICGUIDOF(KSMUSIC_TECHNOLOGY_WAVETABLE),
        0,                                      // Channels
        0,                                      // Notes
        0x0000ffff                              // ChannelMask
    }
};

/*****************************************************************************
 * PinDataRangePointersStream[]
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for streaming pins.
 */
static const
    PKSDATARANGE
    PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

/*****************************************************************************
 * PinDataRangesAudio[]
 *****************************************************************************
 * Structures indicating range of valid format values for audio pins.
 *
 * Do not include this if you are building a hardware device that does not
 * output audio back into the system.
 */
static const
    KSDATARANGE_AUDIO
    PinDataRangesAudio[] =
{
    {
        {   
            sizeof(KSDATARANGE_AUDIO),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        2,
        16,
        16,
        22050,
        22050
    }
};

/*****************************************************************************
 * PinDataRangePointersAudio[]
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for audio pins.
 *
 * Do not include this if you are building a hardware device that does not
 * output audio back into the system.
 */
static const
    PKSDATARANGE
    PinDataRangePointersAudio[] =
{
    PKSDATARANGE(&PinDataRangesAudio[0])
};

/*****************************************************************************
 * SynthProperties[]
 *****************************************************************************
 * Array of properties supported.
 */
static const
    PCPROPERTY_ITEM
    SynthProperties[] =
{
    ///////////////////////////////////////////////////////////////////
    // Support items
    {
        &GUID_DMUS_PROP_GM_Hardware,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Support
    },
    {
        &GUID_DMUS_PROP_GS_Hardware,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Support
    },
    {
        &GUID_DMUS_PROP_XG_Hardware,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Support
    },
    {
        &GUID_DMUS_PROP_XG_Capable,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Support
    },
    {
        &GUID_DMUS_PROP_GS_Capable,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Support
    },
    {
        &GUID_DMUS_PROP_DLS1,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Support
    },
    {
        &GUID_DMUS_PROP_Effects,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Effects
    },

    ///////////////////////////////////////////////////////////////////
    // Configuration items
    // Global: Synth caps
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CAPS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SynthCaps
    },
    // Per Stream: Synth port parameters
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_PORTPARAMETERS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per Stream: Volume
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUME,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per Stream: Volume boost value
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUMEBOOST,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per Stream: Channel groups
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CHANNELGROUPS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per stream: Voice priority
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOICEPRIORITY,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per Stream: Running Stats
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_RUNNINGSTATS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },

    ///////////////////////////////////////////////////////////////////
    // Clock items

    // Per stream: Get current latency time
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_LATENCYCLOCK,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },

    ///////////////////////////////////////////////////////////////////
    // DLS items

    // Per stream: Download DLS sample
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DLS_DOWNLOAD,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SynthDls
    },
    // Per stream: Unload DLS sample
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DLS_UNLOAD,
        KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SynthDls
    },
    // Per stream: append
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DLS_APPEND,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SynthDls
    },
    // Per stream: format
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DLS_WAVEFORMAT,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SynthDls
    }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSynth, SynthProperties);

/*****************************************************************************
 * MiniportPins[]
 *****************************************************************************
 * List of pins.  Do not expose a wave pin if you are writing a driver for a 
 * hardware device that does not inject wave data back into the system.
 */
static const
    PCPIN_DESCRIPTOR
    MiniportPins[] =
{
    {
        1,1,1,  // InstanceCount
        NULL,
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStream),   // DataRangesCount
            PinDataRangePointersStream,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            &KSCATEGORY_WDMAUD_USE_PIN_NAME,            // Category
            &KSNODETYPE_DMDDKSYNTH,                     // Name
            0                                           // Reserved
        }
    },
    {
        1,1,1,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersAudio),    // DataRangesCount
            PinDataRangePointersAudio,                  // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_SOURCE,                 // Communication
            &KSCATEGORY_AUDIO,                          // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
};

/*****************************************************************************
 * MiniportNodes[]
 *****************************************************************************
 * List of nodes
 */
static const
    PCNODE_DESCRIPTOR
    MiniportNodes[] =
{
    { 0, &AutomationSynth, &KSNODETYPE_SYNTHESIZER, &KSNODETYPE_DMSYNTH}
};

/*****************************************************************************
 * MiniportConnections[]
 *****************************************************************************
 * List of connections.
 */
static const
    PCCONNECTION_DESCRIPTOR
    MiniportConnections[] =
{
    // From node            From pin        To node                 To pin
    //
    { PCFILTER_NODE,        0,              0,                      1},     // Stream in to synth.
    { 0,                    0,              PCFILTER_NODE,          1}      // Synth to audio out
};

/*****************************************************************************
 * TopologyCategories[]
 *****************************************************************************
 * List of categories.  If your device is a hardware device that performs
 * actual audio output (i.e. contains a DAC), use KSCATEGORY_RENDER instead 
 * of KSCATEGORY_DATATRANSFORM.
 */
static const
    GUID TopologyCategories[] =
{
    STATICGUIDOF(KSCATEGORY_DATATRANSFORM),
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_SYNTHESIZER)
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport description.
 */
static const
    PCFILTER_DESCRIPTOR
    MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    SIZEOF_ARRAY(TopologyCategories),   // CategoryCount
    TopologyCategories,                 // Categories
};

#pragma code_seg()
/*****************************************************************************
 * MapHRESULT()
 *****************************************************************************
 * Maps DMusic HRESULT to NTSTATUS
 */
NTSTATUS MapHRESULT(IN  HRESULT   hr)
{
    PAGED_CODE();

    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    // NYI: map hr to ntStatus

    return ntStatus;
}

/*****************************************************************************
 * CreateMiniportDmSynth()
 *****************************************************************************
 * Creates a DMus_Synth miniport driver for the adapter.  
 * This uses a macro from STDUNK.H to do all the work.
 */
NTSTATUS CreateMiniportDmSynth
(
    OUT PUNKNOWN *  Unknown,
    IN  PUNKNOWN    UnknownOuter OPTIONAL,
    IN  POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CreateMiniportDmSynth"));
    ASSERT(Unknown);

    STD_CREATE_BODY_WITH_TAG(CMiniportDmSynth, Unknown, UnknownOuter, PoolType,'pMmD'); //  DmMp
}

/*****************************************************************************
 * CMiniportDmSynth::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This method works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CMiniportDmSynth::NonDelegatingQueryInterface(IN  REFIID  Interface,
                                              OUT PVOID * Object)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDmSynth::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportDMus))
    {
        *Object = PVOID(PMINIPORTDMUS(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CMiniportDmSynth::~CMiniportDmSynth()
 *****************************************************************************
 * Destructor for miniport object.  Let go of the port reference.
 */
CMiniportDmSynth::~CMiniportDmSynth()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDmSynth::~CMiniportDmSynth"));

    if (m_pPort)
    {
        m_pPort->Release();
        m_pPort = NULL;
    }

    DeleteCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CMiniportDmSynth::GetDescription()
 *****************************************************************************
 * Gets the topology for this miniport.
 */
STDMETHODIMP
CMiniportDmSynth::GetDescription(OUT PPCFILTER_DESCRIPTOR * OutFilterDescriptor)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDmSynth::GetDescription"));

    *OutFilterDescriptor = PPCFILTER_DESCRIPTOR(&MiniportFilterDescriptor);
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportDmSynth::DataRangeIntersection()
 *****************************************************************************
 * No data range for this miniport.
 */
STDMETHODIMP
CMiniportDmSynth::DataRangeIntersection(IN  ULONG        PinId,
                                        IN  PKSDATARANGE DataRange,
                                        IN  PKSDATARANGE MatchingDataRange,
                                        IN  ULONG        OutputBufferLength,
                                        OUT PVOID        ResultantFormat OPTIONAL,
                                        OUT PULONG       ResultantFormatLength)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDmSynth::DataRangeIntersection"));

    return STATUS_NOT_IMPLEMENTED;
}

/*****************************************************************************
 * CMiniportDmSynth::Init()
 *****************************************************************************
 * Initializes the miniport.  
 */
STDMETHODIMP
CMiniportDmSynth::Init
(
    IN  PUNKNOWN            Unknown OPTIONAL,
    IN  PRESOURCELIST       ResourceList,
    IN  PPORTDMUS           Port,
    OUT PSERVICEGROUP*      ServiceGroup
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDmSynth::Init"));
    ASSERT(ResourceList);
    ASSERT(Port);
    ASSERT(ServiceGroup);

    m_pPort = Port;
    m_pPort->AddRef();

    *ServiceGroup = NULL;

    InitializeCriticalSection(&m_CriticalSection);

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportDmSynth::Service()
 *****************************************************************************
 * Not used.
 */
STDMETHODIMP_(void)
CMiniportDmSynth::Service()
{
}

/*****************************************************************************
 * CMiniportDmSynth::NewStream()
 *****************************************************************************
 * Create a new stream.  SchedulePreFetch tells the sequencer how far in 
 * advance to deliver events.  Allocator and master clock are required.
 */
STDMETHODIMP
CMiniportDmSynth::NewStream
(
    OUT     PMXF                  * MXF,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   PinID,
    IN      DMUS_STREAM_TYPE        StreamType,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP         * ServiceGroup,
    IN      PAllocatorMXF           AllocatorMXF,
    IN      PMASTERCLOCK            MasterClock,
    OUT     PULONGLONG              SchedulePreFetch
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDmSynth::NewStream"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    *MXF = NULL;
    *ServiceGroup = NULL;
    *SchedulePreFetch = DONT_HOLD_FOR_SEQUENCING;

    if ((StreamType != DMUS_STREAM_WAVE_SINK) && (StreamType != DMUS_STREAM_MIDI_RENDER) )
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportDmSynth::NewStream stream type not supported"));
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
    {
        EnterCriticalSection(&m_CriticalSection);

        for (CDmSynthStream* pStreamItem = (CDmSynthStream*)m_StreamList.GetHead();
            pStreamItem;
            pStreamItem = (CDmSynthStream*)pStreamItem->GetNext())
        {
            if ( (StreamType == DMUS_STREAM_WAVE_SINK && !pStreamItem->m_fWaveOutCreated)
              || (StreamType == DMUS_STREAM_MIDI_RENDER && !pStreamItem->m_fMidiInCreated) )
            {
                if (StreamType == DMUS_STREAM_MIDI_RENDER)
                {
                    ntStatus = pStreamItem->InitMidiIn(AllocatorMXF, MasterClock);
                }
                else    // DMUS_STREAM_WAVE_SINK
                {
                    ntStatus = pStreamItem->InitWaveOut(DataFormat);
                }

                if (NT_SUCCESS(ntStatus))
                {
                    pStreamItem->AddRef();
                    *MXF = PMXF(pStreamItem);
                }
                break;
            }
        }

        if (!*MXF)
        {
            CDmSynthStream* pNewStream = new(PoolType,'sSmD') CDmSynthStream(OuterUnknown); //  DmSs

            if (pNewStream)
            {
                ntStatus = pNewStream->Init(this);

                if (NT_SUCCESS(ntStatus))
                {
                    if (StreamType == DMUS_STREAM_MIDI_RENDER)
                    {
                        ntStatus = pNewStream->InitMidiIn(AllocatorMXF, MasterClock);
                    }
                    else    // DMUS_STREAM_WAVE_SINK
                    {
                        ntStatus = pNewStream->InitWaveOut(DataFormat);
                    }
                }

                if (NT_SUCCESS(ntStatus))
                {
                    m_StreamList.AddTail(pNewStream);
                    pNewStream->AddRef();
                    *MXF = PMXF(pNewStream);
                }
                else
                {
                    pNewStream->Release();
                    pNewStream = NULL;
                }
            }
            else
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        LeaveCriticalSection(&m_CriticalSection);
    }

    return ntStatus;
}


/*****************************************************************************
 *****************************************************************************
 * CDmSynthStream implementation
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * CDmSynthStream::~CDmSynthStream()
 *****************************************************************************
 * Destructor for miniport stream (MXF).  Remove the download objects, clock,
 * allocator, miniport, synth, etc.
 *
 * All instruments and waves downloaded to
 * the synth are released (though a well behaved
 * client should have unloaded them prior to now).
 */
CDmSynthStream::~CDmSynthStream()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::~CDmSynthStream"));

    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    if (m_pAllocator)
    {
        m_pAllocator->Release();
        m_pAllocator = NULL;
    }

    if (m_pMiniport)
    {
        EnterCriticalSection(&m_pMiniport->m_CriticalSection);

        for (CDmSynthStream* pStreamItem = (CDmSynthStream*)m_pMiniport->m_StreamList.GetHead();
             pStreamItem;
             pStreamItem = (CDmSynthStream*)pStreamItem->GetNext())
        {
            if (pStreamItem == this)
            {
                m_pMiniport->m_StreamList.Remove(pStreamItem);
                break;
            }
        }
        LeaveCriticalSection(&m_pMiniport->m_CriticalSection);

        m_pMiniport->Release();
    }

    if (m_pSynth)
    {
        delete m_pSynth;
    }
}

/*****************************************************************************
 * CDmSynthStream::Init()
 *****************************************************************************
 * Initialize the miniport stream (MXF).  Create a synth.
 */
NTSTATUS
CDmSynthStream::Init
(
    IN      CMiniportDmSynth *  Miniport
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::Init"));

    if (!Miniport)
    {
        return STATUS_INVALID_PARAMETER;
    }

    m_pSynth = new(NonPagedPool,'SSmD') CSynth; //  DmSS
    if (m_pSynth == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    m_pMiniport = Miniport;
    m_pMiniport->AddRef();

    m_fWaveOutCreated = FALSE;
    m_fMidiInCreated = FALSE;

    m_State = KSSTATE_STOP;
    
    m_EventList = NULL;
    KeInitializeSpinLock(&m_EventListLock);
    ExInitializeWorkItem(&m_EventListWorkItem,
                         (PWORKER_THREAD_ROUTINE)PutMessageWorker,
                         (PVOID)this);
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CDmSynthStream::InitMidiIn()
 *****************************************************************************
 * Initialize the MIDI input side.  Allocator and master clock are required.
 */
NTSTATUS
CDmSynthStream::InitMidiIn
(
    IN      PAllocatorMXF   AllocatorMXF,
    IN      PMASTERCLOCK    MasterClock
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::Init"));

    if (!AllocatorMXF || !MasterClock)
    {
        return STATUS_INVALID_PARAMETER;
    }

    m_pAllocator = AllocatorMXF;
    m_pAllocator->AddRef();

    // NOTE: master clock is set on midi pin, not wave pin
    m_pMasterClock = MasterClock;
    m_pMasterClock->AddRef();

    m_fMidiInCreated = TRUE;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CDmSynthStream::InitWaveOut()
 *****************************************************************************
 * Initialize the wave output side.
 */
NTSTATUS
CDmSynthStream::InitWaveOut
(
    IN      PKSDATAFORMAT       DataFormat
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::Init"));

    if (!DataFormat)
    {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(&m_PortParams, sizeof(m_PortParams));
    m_PortParams.SampleRate = PKSDATAFORMAT_WAVEFORMATEX(DataFormat)->WaveFormatEx.nSamplesPerSec;
    m_PortParams.AudioChannels = PKSDATAFORMAT_WAVEFORMATEX(DataFormat)->WaveFormatEx.nChannels;

    m_lVolume = 0;
    m_lBoost = 6 * 100;

    m_fWaveOutCreated = TRUE;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CDmSynthStream::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This method works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CDmSynthStream::NonDelegatingQueryInterface
(
    IN  REFIID      Interface,
    OUT PVOID*      Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_ISynthSinkDMus))
    {
        *Object = PVOID(PSYNTHSINKDMUS(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }
    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CDmSynthStream::SetState()
 *****************************************************************************
 * Set the state of the stream (RUN/PAUSE/ACQUIRE/STOP) and act accordingly.
 * Activate the synth if we are running.
 */
STDMETHODIMP
CDmSynthStream::SetState
(
    IN      KSSTATE     NewState
)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::SetState: %d", NewState));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    m_llStartPosition = 0;
    m_llLastPosition = 0;

    switch (NewState)
    {
        case KSSTATE_RUN:
        {
            if (m_PortParams.SampleRate && m_PortParams.AudioChannels)
            {
                if (NT_SUCCESS(ntStatus))
                {
                    HRESULT hr = m_pSynth->Activate(m_PortParams.SampleRate,
                                                    m_PortParams.AudioChannels);
                    if (FAILED(hr))
                    {
                        ntStatus = MapHRESULT(hr);
                    }
                }
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::SetState invalid port params"));
                ntStatus = STATUS_UNSUCCESSFUL;
            }
            break;
        }
        case KSSTATE_ACQUIRE:
        case KSSTATE_STOP:
        case KSSTATE_PAUSE:
        {
            HRESULT hr = m_pSynth->Deactivate();
            if (FAILED(hr))
            {
                ntStatus = MapHRESULT(hr);
            }
            break;
        }
    }
    m_State = NewState;
    
    return ntStatus;
}

/*****************************************************************************
 * CDmSynthStream::ConnectOutput()
 *****************************************************************************
 * MXF base function.  This MXF does not feed another, so it is not implemented.
 */
STDMETHODIMP
CDmSynthStream::ConnectOutput(PMXF ConnectionPoint)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::ConnectOutput"));

    return STATUS_SUCCESS;      // do nothing
}


/*****************************************************************************
 * CDmSynthStream::DisconnectOutput()
 *****************************************************************************
 * MXF base function.  This MXF does not feed another, so it is not implemented.
 */
STDMETHODIMP
CDmSynthStream::DisconnectOutput(PMXF ConnectionPoint)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::DisconnectOutput"));

    return STATUS_SUCCESS;      // do nothing
}


/*****************************************************************************
 * PutMessageWorker()
 *****************************************************************************
 * C function that thunks over to the stream's member function.
 */
VOID PutMessageWorker(PVOID Param)
{
    CDmSynthStream *pCDmSynthStream = (CDmSynthStream *)Param;

    pCDmSynthStream->PutMessageInternal();
}


/*****************************************************************************
 * CDmSynthStream::PutMessageInternal()
 *****************************************************************************
 * Can be called at PASSIVE_LEVEL.  Receive MIDI events and queue them.
 */
void CDmSynthStream::PutMessageInternal(void)
{
    KIRQL oldIrql;
    PDMUS_KERNEL_EVENT  pEvent,pDMKEvt;
    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::PutMessageInternal"));

    // Grab everything on the list
    KeAcquireSpinLock(&m_EventListLock,&oldIrql);
    pEvent=m_EventList;
    m_EventList=NULL;
    KeReleaseSpinLock(&m_EventListLock,oldIrql);

    pDMKEvt=pEvent;
    while (pDMKEvt)
    {
        if (!(PACKAGE_EVT(pDMKEvt)))
        {
            PBYTE pData;
            if (pDMKEvt->cbEvent <= sizeof(PBYTE))
            {
                pData = (PBYTE)&pDMKEvt->uData;
            }
            else
            {
                pData = (PBYTE)pDMKEvt->uData.pbData;
            }    

            // This is just MIDI bytes
            HRESULT hr = m_pSynth->PlayBuffer(PSYNTHSINKDMUS(this),
                                              pDMKEvt->ullPresTime100ns,
                                              pData,
                                              pDMKEvt->cbEvent,
                                              (ULONG)pDMKEvt->usChannelGroup);
            if (FAILED(hr))
            {
                ntStatus = MapHRESULT(hr);
            }
        }
        else
        {
            PutMessage(pDMKEvt->uData.pPackageEvt);
            pDMKEvt->uData.pPackageEvt = NULL;
        }
        pDMKEvt = pDMKEvt->pNextEvt;
    }
    m_pAllocator->PutMessage(pEvent);
}

/*****************************************************************************
 * CDmSynthStream::PutMessage()
 *****************************************************************************
 * Must be called at DISPATH_LEVEL (e.g. from a DPC).  We jam an event into
 * a queue and call a work item.  If the queue already exists, we just append
 * (no need to call the work item).
 */
STDMETHODIMP
CDmSynthStream::PutMessage(IN PDMUS_KERNEL_EVENT pEvent)
{
    BOOL bQueueWorkItem;

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::::PutMessage"));

    // Queue up on event list
    KeAcquireSpinLockAtDpcLevel(&m_EventListLock);

    if (!m_EventList)           // If nothing on event list
    {
        m_EventList = pEvent;   // Link to head
        bQueueWorkItem = TRUE;  // Need to queue work item
    }
    else                        // Something already pending, queue up behind them
    {
        // Find last event in queue to link to
        PDMUS_KERNEL_EVENT  pEventTail = m_EventList;
        while (pEventTail->pNextEvt)
        {
            pEventTail = pEventTail->pNextEvt;
        }
        pEventTail->pNextEvt = pEvent;
        bQueueWorkItem = FALSE; // No need to queue new work item
    }
    KeReleaseSpinLockFromDpcLevel(&m_EventListLock);

    // Queue up the work item after we release spinlock
    if (bQueueWorkItem)
    {
        ExQueueWorkItem(&m_EventListWorkItem, CriticalWorkQueue);
    }
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CDmSynthStream::HandlePropertySupport()
 *****************************************************************************
 * Handle the support property.
 */
NTSTATUS
CDmSynthStream::HandlePropertySupport(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::HandlePropertySupport"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        if ((pRequest->ValueSize < sizeof(ULONG)) || (NULL == pRequest->Value))
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            // if return buffer can hold a ULONG, return the access flags
            PULONG AccessFlags = PULONG(pRequest->Value);

            *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                           KSPROPERTY_TYPE_GET;
        }
        // set the return value size
        pRequest->ValueSize = sizeof(ULONG);
    }
    else
    {
        if (pRequest->Verb & KSPROPERTY_TYPE_SET)
        {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
        else if ((pRequest->ValueSize < sizeof(ULONG)) || (NULL == pRequest->Value))
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else if (IsEqualGUIDAligned(*pRequest->PropertyItem->Set, GUID_DMUS_PROP_GM_Hardware))
        {
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySupport GUID_DMUS_PROP_GM_Hardware"));

            *(PULONG)(pRequest->Value) = FALSE;
        }
        else if (IsEqualGUIDAligned(*pRequest->PropertyItem->Set, GUID_DMUS_PROP_GS_Hardware))
        {
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySupport GUID_DMUS_PROP_GS_Hardware"));

            *(PULONG)(pRequest->Value) = FALSE;
        }
        else if (IsEqualGUIDAligned(*pRequest->PropertyItem->Set, GUID_DMUS_PROP_XG_Hardware))
        {
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySupport GUID_DMUS_PROP_XG_Hardware"));

            *(PULONG)(pRequest->Value) = FALSE;
        }
        else if (IsEqualGUIDAligned(*pRequest->PropertyItem->Set, GUID_DMUS_PROP_XG_Capable))
        {
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySupport GUID_DMUS_PROP_XG_Capable"));

            *(PULONG)(pRequest->Value) = TRUE;
        }
        else if (IsEqualGUIDAligned(*pRequest->PropertyItem->Set, GUID_DMUS_PROP_GS_Capable))
        {
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySupport GUID_DMUS_PROP_GS_Capable"));

            *(PULONG)(pRequest->Value) = TRUE;
        }
        else if (IsEqualGUIDAligned(*pRequest->PropertyItem->Set, GUID_DMUS_PROP_DLS1))
        {
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySupport GUID_DMUS_PROP_DLS1"));

            *(PULONG)(pRequest->Value) = TRUE;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("CDmSynthStream::HandlePropertySupport unrecognized set ID"));
            ntStatus = STATUS_UNSUCCESSFUL;
        }
        // set the return value size
        pRequest->ValueSize = sizeof(ULONG);
    }
    return ntStatus;
}

/*****************************************************************************
 * CDmSynthStream::HandlePropertyEffects()
 *****************************************************************************
 * Handle the effects property.
 */
NTSTATUS 
CDmSynthStream::HandlePropertyEffects(IN  PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::HandlePropertyEffects"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        if ((pRequest->ValueSize < sizeof(ULONG)) || (NULL == pRequest->Value))
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            // if return buffer can hold a ULONG, return the access flags
            PULONG AccessFlags = PULONG(pRequest->Value);

            *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                           KSPROPERTY_TYPE_GET;
        }
    }
    else
    {
        if ((pRequest->ValueSize < sizeof(ULONG)) || (NULL == pRequest->Value))
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            if (pRequest->Verb & KSPROPERTY_TYPE_GET)
            {
                PULONG pulEffects = (PULONG)pRequest->Value;

                *pulEffects = 0;

                _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream: Get effects flags %x", *pulEffects));
            }
            else
            {
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            }
        }
    }
    // set the return value size
    pRequest->ValueSize = sizeof(ULONG);

    return ntStatus;
}

/*****************************************************************************
 * CDmSynthStream::HandlePortParams()
 *****************************************************************************
 * Handle the port parameters property.
 * Fix up the port params to include defaults. Cache the params as well
 * as passing the updated version back.
 */
NTSTATUS
CDmSynthStream::HandlePortParams(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::HandlePortParams"));

    if (pRequest->Verb & KSPROPERTY_TYPE_SET)
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    else if ( (pRequest->InstanceSize < sizeof(SYNTH_PORTPARAMS))
           || (pRequest->ValueSize < sizeof(SYNTH_PORTPARAMS))
           || (NULL == pRequest->Value) )
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandlePortParams STATUS_BUFFER_TOO_SMALL"));
        pRequest->ValueSize = sizeof(SYNTH_PORTPARAMS);
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory(pRequest->Value, pRequest->Instance, sizeof(SYNTH_PORTPARAMS));

    NTSTATUS ntStatus = STATUS_SUCCESS;
    PSYNTH_PORTPARAMS Params = (PSYNTH_PORTPARAMS)pRequest->Value;

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_VOICES))
    {
        Params->Voices = 32;
    }
    else if (Params->Voices > MAX_VOICES)
    {
        Params->Voices = MAX_VOICES;
    }
    else if (Params->Voices < 1)
    {
        Params->Voices = 1;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_CHANNELGROUPS))
    {
        Params->ChannelGroups = 32;
    }
    else if (Params->ChannelGroups > MAX_CHANNEL_GROUPS)
    {
        Params->ChannelGroups = MAX_CHANNEL_GROUPS;
    }
    else if (Params->ChannelGroups < 1)
    {
        Params->ChannelGroups = 1;
    }

    // audio channels is fixed (chosen) by SysAudio
    if (!(Params->ValidParams & SYNTH_PORTPARAMS_AUDIOCHANNELS))
    {
        Params->AudioChannels = m_PortParams.AudioChannels;
    }
    else if (Params->AudioChannels != m_PortParams.AudioChannels)
    {
        Params->AudioChannels = m_PortParams.AudioChannels;
    }

    // sample rate is fixed (chosen) by SysAudio
    if (!(Params->ValidParams & SYNTH_PORTPARAMS_SAMPLERATE))
    {
        Params->SampleRate = m_PortParams.SampleRate;
    }
    else if (Params->SampleRate != m_PortParams.SampleRate)
    {
        Params->SampleRate = m_PortParams.SampleRate;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_EFFECTS))
    {
        Params->EffectsFlags = SYNTH_EFFECT_NONE;
    }
    else
    {
        Params->EffectsFlags = SYNTH_EFFECT_NONE;
    }

    RtlCopyMemory(&m_PortParams, Params, sizeof(m_PortParams));

    // Each channel groups is represented by a ControlLogic object
    // (A channel groups is a set of sixteen MIDI channels)
    HRESULT hr = m_pSynth->Open(m_PortParams.ChannelGroups,
                                m_PortParams.Voices
                                );
    if (SUCCEEDED(hr))
    {
        m_pSynth->SetGainAdjust(m_lVolume + m_lBoost);
    }
    else
    {
        ntStatus = MapHRESULT(hr);
    }
    pRequest->ValueSize = sizeof(SYNTH_PORTPARAMS);

    return ntStatus;
}

/*****************************************************************************
 * CDmSynthStream::HandleRunningStats()
 *****************************************************************************
 * Handle the property for running statistics.
 */
NTSTATUS
CDmSynthStream::HandleRunningStats(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::HandleRunningStats"));

    if (pRequest->Verb & KSPROPERTY_TYPE_SET)
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    else if ((pRequest->ValueSize < sizeof(SYNTH_STATS)) || (NULL == pRequest->Value))
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleRunningStats STATUS_BUFFER_TOO_SMALL"));
        pRequest->ValueSize = sizeof(SYNTH_STATS);
        return STATUS_BUFFER_TOO_SMALL;
    }

    NTSTATUS ntStatus;
    KFLOATING_SAVE FloatingPointState;

    PSYNTH_STATS StatsOut = (PSYNTH_STATS)pRequest->Value;

    PerfStats Stats;
    m_pSynth->GetPerformanceStats(&Stats);

   long lCPU = Stats.dwCPU;

    if (Stats.dwVoices)
    {
        lCPU /= Stats.dwVoices;
    }
    else
    {
        lCPU = 0;
    }

    StatsOut->Voices = Stats.dwVoices;
    StatsOut->CPUPerVoice = lCPU * 10;
    StatsOut->TotalCPU = Stats.dwCPU * 10;
    StatsOut->LostNotes = Stats.dwNotesLost;
    long ldB = 6;

    StatsOut->ValidStats =
        SYNTH_STATS_VOICES |
        SYNTH_STATS_TOTAL_CPU |
        SYNTH_STATS_CPU_PER_VOICE |
        SYNTH_STATS_LOST_NOTES;

    ntStatus = KeSaveFloatingPointState(&FloatingPointState);
    if (NT_SUCCESS(ntStatus))
    {
        double fLevel = Stats.dwMaxAmplitude;
        if (Stats.dwMaxAmplitude < 1)
        {
            fLevel = -96.0;
        }
        else
        {
            fLevel /= 32768.0;
            fLevel = log10(fLevel);
            fLevel *= 20.0;
        }
        StatsOut->PeakVolume = (long) fLevel;
        StatsOut->ValidStats |= SYNTH_STATS_PEAK_VOLUME;

        KeRestoreFloatingPointState(&FloatingPointState);
    }
    pRequest->ValueSize = sizeof(SYNTH_STATS);

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CDmSynthStream::HandlePropertySynth()
 *****************************************************************************
 * Handle the synth property set.
 */
NTSTATUS
CDmSynthStream::HandlePropertySynth(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::HandlePropertySynth"));

    NTSTATUS ntStatus = STATUS_SUCCESS;
    HRESULT hr;

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        if ((pRequest->ValueSize < sizeof(ULONG)) || (NULL == pRequest->Value))
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            // return based on Id
            const WORD c_wMaxProps = SIZEOF_ARRAY(SynthProperties);
            WORD wPropIdx;

            for (wPropIdx = 0; wPropIdx < c_wMaxProps; wPropIdx++)
            {
                if ( (SynthProperties[wPropIdx].Set == pRequest->PropertyItem->Set)
                  && (SynthProperties[wPropIdx].Id == pRequest->PropertyItem->Id) )
                {
                    // if return buffer can hold a ULONG, return the access flags
                    PULONG AccessFlags = PULONG(pRequest->Value);

                    *AccessFlags = SynthProperties[wPropIdx].Flags;

                    // set the return value size
                    pRequest->ValueSize = sizeof(ULONG);
                    break;
                }
            }

            if (wPropIdx == c_wMaxProps)
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandlePropertySynth property ID not found"));
                ntStatus = STATUS_UNSUCCESSFUL;
            }
        }
        pRequest->ValueSize = sizeof(ULONG);
    }
    else
    {
        switch (pRequest->PropertyItem->Id)
        {
        case KSPROPERTY_SYNTH_PORTPARAMETERS:
            _DbgPrintF(DEBUGLVL_VERBOSE,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_PORTPARAMETERS"));
            ntStatus = HandlePortParams(pRequest);
            break;
        case KSPROPERTY_SYNTH_RUNNINGSTATS:
            _DbgPrintF(DEBUGLVL_VERBOSE,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_RUNNINGSTATS"));
            ntStatus = HandleRunningStats(pRequest);
            break;
        case KSPROPERTY_SYNTH_VOLUME:
            _DbgPrintF(DEBUGLVL_VERBOSE,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_VOLUME"));

            if ((pRequest->ValueSize < sizeof(m_lVolume)) || (NULL == pRequest->Value))
            {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
            else if (pRequest->Verb & KSPROPERTY_TYPE_GET)
            {
                *(PLONG)pRequest->Value = m_lVolume;
            }
            else
            {
                m_lVolume = *(PLONG)pRequest->Value;
                m_pSynth->SetGainAdjust(m_lVolume + m_lBoost);
            }
            pRequest->ValueSize = sizeof(m_lVolume);
            break;
        case KSPROPERTY_SYNTH_VOLUMEBOOST:
            _DbgPrintF(DEBUGLVL_VERBOSE,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_VOLUMEBOOST"));

            if ((pRequest->ValueSize < sizeof(m_lBoost)) || (NULL == pRequest->Value))
            {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
            else if (pRequest->Verb & KSPROPERTY_TYPE_GET)
            {
                *(PLONG)pRequest->Value = m_lBoost;
            }
            else
            {
                m_lBoost = *(PLONG)pRequest->Value;
                m_pSynth->SetGainAdjust(m_lVolume + m_lBoost);
            }
            pRequest->ValueSize = sizeof(m_lBoost);
            break;
        case KSPROPERTY_SYNTH_CHANNELGROUPS:
            _DbgPrintF(DEBUGLVL_VERBOSE,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_CHANNELGROUPS"));

            if ( (pRequest->ValueSize < sizeof(m_PortParams.ChannelGroups)) 
              || (NULL == pRequest->Value) )
            {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
            else if (pRequest->Verb & KSPROPERTY_TYPE_GET)
            {
                *(PULONG)pRequest->Value = m_PortParams.ChannelGroups;
            }
            else
            {
                hr = m_pSynth->SetNumChannelGroups(*(PULONG)pRequest->Value);

                if (FAILED(hr))
                {
                    ntStatus = MapHRESULT(hr);
                }
                else
                {
                    m_PortParams.ChannelGroups = *(PULONG)pRequest->Value;
                }
            }
            pRequest->ValueSize = sizeof(m_PortParams.ChannelGroups);
            break;
        case KSPROPERTY_SYNTH_VOICEPRIORITY:
            _DbgPrintF(DEBUGLVL_VERBOSE,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_VOICEPRIORITY"));

            if ( (pRequest->InstanceSize < sizeof(SYNTHVOICEPRIORITY_INSTANCE))
              || (pRequest->ValueSize < sizeof(DWORD)) 
              || (NULL == pRequest->Value) )
            {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
            else if (pRequest->Verb & KSPROPERTY_TYPE_GET)
            {
                PSYNTHVOICEPRIORITY_INSTANCE pVoicePriority = (PSYNTHVOICEPRIORITY_INSTANCE)pRequest->Instance;

                hr = m_pSynth->GetChannelPriority(pVoicePriority->ChannelGroup, 
                                                  pVoicePriority->Channel,
                                                  (PULONG)pRequest->Value);
                if (FAILED(hr))
                {
                    ntStatus = MapHRESULT(hr);
                }
            }
            else
            {
                PSYNTHVOICEPRIORITY_INSTANCE pVoicePriority = (PSYNTHVOICEPRIORITY_INSTANCE)pRequest->Instance;

                hr = m_pSynth->SetChannelPriority(pVoicePriority->ChannelGroup, 
                                                  pVoicePriority->Channel,
                                                  *(PULONG)pRequest->Value);
                if (FAILED(hr))
                {
                    ntStatus = MapHRESULT(hr);
                }
            }
            pRequest->ValueSize = sizeof(DWORD);
            break;
        case KSPROPERTY_SYNTH_LATENCYCLOCK:
            // This returns the latency clock created by the output audio sink object, 
            // which handles the output audio stream.
            // The latency clock returns the current render time whenever its 
            // IReferenceClock::GetTime method is called. This time is always relative 
            // to the time established by the master clock.
            // The latency time is used by clients to identify the next available time 
            // to start playing a note.
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_LATENCYCLOCK"));

            if (pRequest->Verb & KSPROPERTY_TYPE_SET)
            {
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            }
            else if ((pRequest->ValueSize < sizeof(ULONGLONG)) || (NULL == pRequest->Value))
            {
                pRequest->ValueSize = sizeof(ULONGLONG);
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                REFERENCE_TIME rtLatency;
                if (NT_SUCCESS(SampleToRefTime(m_llLastPosition, &rtLatency)))
                {
                    if (m_pMasterClock)
                    {
                        REFERENCE_TIME rtMaster;
                        if (NT_SUCCESS(m_pMasterClock->GetTime(&rtMaster)))
                        {
#if DBG
                            static DWORD g_dwIn = 0;
#endif // DBG
                            if (rtLatency < rtMaster)
                            {
#if DBG
                                if (g_dwIn++ % 25 == 0)
                                {
                                    _DbgPrintF(DEBUGLVL_VERBOSE,("Latency:%ld < Master:%ld",
                                                                 long(rtLatency / 10000),
                                                                 long(rtMaster / 10000)));
                                }
#endif // DBG
                                // REVIEW: rtLatency = rtMaster; // clamp it up
                            }
                            else if (rtLatency > rtMaster + 10000000)
                            {
#if DBG
                                if (g_dwIn++ % 25 == 0)
                                {
                                    _DbgPrintF(DEBUGLVL_VERBOSE,("Latency:%ld > Master:%ld",
                                                                 long(rtLatency / 10000),
                                                                 long(rtMaster / 10000)));
                                }
#endif // DBG
                                // REVIEW: rtLatency = rtMaster + 10000000; // clamp it down
                            }
                        }
                    }
                    *((PULONGLONG)pRequest->Value) = rtLatency;
                }
                else
                {
                    ntStatus = STATUS_UNSUCCESSFUL;
                }
                pRequest->ValueSize = sizeof(ULONGLONG);
            }
            break;
        default:
            _DbgPrintF(DEBUGLVL_TERSE,("CDmSynthStream::HandlePropertySynth unrecognized ID"));
            ntStatus = STATUS_UNSUCCESSFUL;
            break;
        }
    }

    return ntStatus;
}


/*****************************************************************************
 * CDmSynthStream::HandleDownload()
 *****************************************************************************
 * Handle a download request.  We carefully copy the data.
 * Forward to the synth and add to our list.
 */
NTSTATUS
CDmSynthStream::HandleDownload(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::HandleDownload"));

    if (pRequest->InstanceSize < sizeof(SYNTH_BUFFER))
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload InstanceSize too small"));
        return STATUS_BUFFER_TOO_SMALL;
    }
    if (pRequest->ValueSize < sizeof(SYNTHDOWNLOAD))
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload ValueSize too small"));
        return STATUS_BUFFER_TOO_SMALL;
    }
    if (pRequest->Instance == NULL)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload Instance is NULL"));
        return STATUS_BUFFER_TOO_SMALL;
    }
    if (pRequest->Value == NULL)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload Value is NULL"));
        return STATUS_BUFFER_TOO_SMALL;
    }
#if DBG
    if (pRequest->InstanceSize != sizeof(SYNTH_BUFFER) ||
        pRequest->ValueSize != sizeof(SYNTHDOWNLOAD))
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload InstanceSize:%lu, ValueSize:%lu", pRequest->InstanceSize, pRequest->ValueSize));
    }
#endif // DBG

    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PSYNTH_BUFFER pDlsBuffer = (PSYNTH_BUFFER)pRequest->Instance;

    // lock and copy user data into paged pool
    BOOL pagesLocked = FALSE;
    PVOID pvData = NULL;
    PMDL pMdl = IoAllocateMdl(pDlsBuffer->BufferAddress, pDlsBuffer->BufferSize, FALSE, FALSE, NULL);
    if (pMdl)
    {
        __try
        {
            MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
            pagesLocked = TRUE;

            PVOID pvUserData = KernHelpGetSysAddrForMdl(pMdl);

            pvData = (PVOID)new BYTE[pDlsBuffer->BufferSize];
            if (pvData && pvUserData)
            {
                RtlCopyMemory(pvData, pvUserData, pDlsBuffer->BufferSize);
                ntStatus = STATUS_SUCCESS;
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload download allocate failed"));
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload lock or copy failed"));
            ntStatus = GetExceptionCode();
        }

        // cleanup
        if (pagesLocked)
        {
            MmUnlockPages(pMdl);
        }
        IoFreeMdl(pMdl);
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload IoAllocateMdl failed"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    // download to synth
    SYNTHDOWNLOAD SynthDownload;
    if (SUCCEEDED(ntStatus))
    {
        HRESULT hr = m_pSynth->Download(&SynthDownload.DownloadHandle,
                                        pvData,
                                        &SynthDownload.Free);
        if (SUCCEEDED(hr))
        {
            if (!SynthDownload.Free)
            {
                pvData = NULL; // prevent from being freed
            }

            if (SUCCEEDED(ntStatus))
            {
                SynthDownload.Free = TRUE; // client can always free user data

                ASSERT(pRequest->ValueSize >= sizeof(SynthDownload));
                RtlCopyMemory(pRequest->Value, &SynthDownload, sizeof(SynthDownload));
                pRequest->ValueSize = sizeof(SynthDownload);
            }
        }
        else
        {
            ntStatus = MapHRESULT(hr);
        }
    }

    if (pvData)
    {
        delete [] pvData;
        pvData = NULL;
    }

    return ntStatus;
}

/*****************************************************************************
 * CDmSynthStream::HandleUnload()
 *****************************************************************************
 * Handle an unload request.  Forward to the synth and remove from our list.
 */
NTSTATUS
CDmSynthStream::HandleUnload(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::HandleUnload"));

    if ((pRequest->ValueSize < sizeof(HANDLE)) || (NULL == pRequest->Value))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    NTSTATUS ntStatus = STATUS_SUCCESS;
    HRESULT hr = m_pSynth->Unload(*(HANDLE*)pRequest->Value,NULL,NULL);

    if (FAILED(hr))
    {
        ntStatus = MapHRESULT(hr);
    }
    return ntStatus;
}


/*****************************************************************************
 * CDmSynthStream::HandlePropertySynthDls()
 *****************************************************************************
 * Handles a property in the SynthDls set.  
 */
NTSTATUS
CDmSynthStream::HandlePropertySynthDls(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::HandlePropertySynthDls"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        if ((pRequest->ValueSize < sizeof(ULONG)) || (NULL == pRequest->Value))
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            // return based on Id
            const WORD c_wMaxProps = SIZEOF_ARRAY(SynthProperties);
            WORD wPropIdx;

            for (wPropIdx = 0; wPropIdx < c_wMaxProps; wPropIdx++)
            {
                if ((SynthProperties[wPropIdx].Set == pRequest->PropertyItem->Set)
                  && (SynthProperties[wPropIdx].Id == pRequest->PropertyItem->Id) )
                {
                    // if return buffer can hold a ULONG, return the access flags
                    PULONG AccessFlags = PULONG(pRequest->Value);

                    *AccessFlags = SynthProperties[wPropIdx].Flags;
                    break;
                }
            }

            if (wPropIdx == c_wMaxProps)
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandlePropertySynthDls property ID not found"));
                ntStatus = STATUS_UNSUCCESSFUL;
            }
        }
        // set the return value size
        pRequest->ValueSize = sizeof(ULONG);
    }
    else
    {
        switch (pRequest->PropertyItem->Id)
        {
        case KSPROPERTY_SYNTH_DLS_DOWNLOAD:
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySynthDls KSPROPERTY_SYNTH_DLS_DOWNLOAD"));
            ntStatus = HandleDownload(pRequest);
            break;
        case KSPROPERTY_SYNTH_DLS_UNLOAD:
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySynthDls KSPROPERTY_SYNTH_DLS_UNLOAD"));
            ntStatus = HandleUnload(pRequest);
            break;
        case KSPROPERTY_SYNTH_DLS_APPEND:
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySynthDls KSPROPERTY_SYNTH_DLS_APPEND"));

            if (pRequest->Verb & KSPROPERTY_TYPE_SET)
            {
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            }
            else if ((pRequest->ValueSize < sizeof(ULONG)) || (NULL == pRequest->Value))
            {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                pRequest->ValueSize = sizeof(ULONG);
            }
            else
            {
                *(PULONG)(pRequest->Value) = 1;
                pRequest->ValueSize = sizeof(ULONG);
            }
            break;
        case KSPROPERTY_SYNTH_DLS_WAVEFORMAT:
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySynthDls KSPROPERTY_SYNTH_DLS_WAVEFORMAT"));

            if (pRequest->Verb & KSPROPERTY_TYPE_SET)
            {
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            }
            else if ((pRequest->ValueSize < sizeof(WAVEFORMATEX)) || (NULL == pRequest->Value))
            {
                pRequest->ValueSize = sizeof(WAVEFORMATEX);
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                WAVEFORMATEX *pwfex;
                pwfex = (WAVEFORMATEX *)pRequest->Value;

                RtlZeroMemory(pwfex, sizeof(WAVEFORMATEX));
                pwfex->wFormatTag = WAVE_FORMAT_PCM;
                pwfex->nChannels = 2;
                pwfex->nSamplesPerSec = 22050L;
                pwfex->nAvgBytesPerSec = 22050L * 2 * 2;
                pwfex->nBlockAlign = 4;
                pwfex->wBitsPerSample = 16;
                pwfex->cbSize = 0;

                pRequest->ValueSize = sizeof(WAVEFORMATEX);
            }

            break;
        default:
            _DbgPrintF(DEBUGLVL_TERSE,("CDmSynthStream::HandlePropertySynthDls unrecognized ID"));
            ntStatus = STATUS_UNSUCCESSFUL;

            break;
        }
    }
    return ntStatus;
}

/*****************************************************************************
 * PropertyHandler_Support()
 *****************************************************************************
 * Redirect to the correct CDMSynthStream member.
 */
NTSTATUS
PropertyHandler_Support(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("PropertyHandler_Support"));

    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);
    if (!pRequest || !(pRequest->MinorTarget))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->HandlePropertySupport(pRequest);
}

/*****************************************************************************
 * PropertyHandler_Effects()
 *****************************************************************************
 * Redirect to the correct CDMSynthStream member.
 */
NTSTATUS
PropertyHandler_Effects(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("PropertyHandler_Effects"));

    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);
    if (!pRequest || !(pRequest->MinorTarget))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->HandlePropertyEffects(pRequest);
}


/*****************************************************************************
 * PropertyHandler_Synth()
 *****************************************************************************
 * Redirect to the correct CDMSynthStream member.
 */
NTSTATUS
PropertyHandler_Synth(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("PropertyHandler_Synth"));
    
    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);
    if (!pRequest || !(pRequest->MinorTarget))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->HandlePropertySynth(pRequest);
}

const WCHAR wszDescription[] = L"Microsoft DDK Kernel DLS Synthesizer";

/*****************************************************************************
 * PropertyHandler_SynthCaps()
 *****************************************************************************
 * Redirect to the correct CDMSynthStream member.
 */
NTSTATUS
PropertyHandler_SynthCaps(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("PropertyHandler_SynthCaps"));
    
    ASSERT(pRequest);
    if (!pRequest)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        if ( (pRequest->ValueSize < sizeof(ULONG)) 
          || (pRequest->Value == NULL) )
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            // if return buffer can hold a ULONG, return the access flags
            PULONG AccessFlags = PULONG(pRequest->Value);

            *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                           KSPROPERTY_TYPE_GET;
        }
        // set the return value size
        pRequest->ValueSize = sizeof(ULONG);
    }
    else
    {
        SYNTHCAPS Caps;

        if (pRequest->Verb & KSPROPERTY_TYPE_SET)
        {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
        else if ( (pRequest->ValueSize < sizeof(Caps)) 
               || (pRequest->Value == NULL) )
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            RtlZeroMemory(&Caps, sizeof(Caps));

            Caps.Guid               = CLSID_DDKWDMSynth;
            Caps.Flags              = SYNTH_PC_DLS | SYNTH_PC_SOFTWARESYNTH;
            Caps.MemorySize         = SYNTH_PC_SYSTEMMEMORY;
            Caps.MaxChannelGroups   = MAX_CHANNEL_GROUPS;
            Caps.MaxVoices          = MAX_VOICES;
            Caps.MaxAudioChannels   = 2;
            RtlCopyMemory(Caps.Description, wszDescription, sizeof(wszDescription));

            RtlCopyMemory(pRequest->Value, &Caps, sizeof(Caps));
        }
        pRequest->ValueSize = sizeof(Caps);
    }
    return ntStatus;
}



/*****************************************************************************
 * PropertyHandler_SynthDls()
 *****************************************************************************
 * Redirect to the correct CDMSynthStream member.
 */
NTSTATUS
PropertyHandler_SynthDls(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("PropertyHandler_SynthDls"));
    
    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);
    if (!pRequest || !(pRequest->MinorTarget))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->HandlePropertySynthDls(pRequest);
}


=== ddksynth/mix.cpp ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//      Mix.cpp
//      Mix engines for MSSynth

#include "common.h"

#define STR_MODULENAME "DDKSynth.sys:Mix: "

#pragma warning(disable : 4101 4102 4146)  

#ifdef _ALPHA_

extern "C" {
	int __ADAWI(short, short *);
};
#pragma intrinsic(__ADAWI)

#define ALPHA_OVERFLOW 2 
#define ALPHA_NEGATIVE 8

#else // !_ALPHA_
//  TODO -- overflow detection for ia64? (+ axp64?)
#endif // !_ALPHA_

#pragma code_seg()
/*****************************************************************************
 * CDigitalAudio::Mix8()
 *****************************************************************************
 * Implement a stereo eight-bit mix.
 * Heavily optimized for x86 non-MMX, plus C code for non-x86.
 */
DWORD CDigitalAudio::Mix8(short * pBuffer,      DWORD dwLength, 
                          DWORD dwDeltaPeriod,  VFRACT vfDeltaLVolume,
                          VFRACT vfDeltaRVolume,PFRACT pfDeltaPitch, 
                          PFRACT pfSampleLength,PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM, lLM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8;  
	dwLength <<= 1;

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lLM = pcWave[dwPosition];
        lM = ((pcWave[dwPosition + 1] - lLM) * dwFract) >> 12;
        lM += lLM;
        lLM = lM;

        lLM *= vfLVolume;
        lLM >>= 5;         // Signal bumps up to 15 bits.
        lM *= vfRVolume;
        lM >>= 5;

#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lLM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else // !_ALPHA_
    // TODO -- overflow detection on ia64 (+ axp64?)
#endif // !_ALPHA_

#else // _X86_  (dead code)
      //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lLM;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif // _X86_  (dead code)

		dwI += 2;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;

// esi = b == dwIncDelta

; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = (dwLength - dwI) / 2;	// Remaining span.

	mov	edx, edi
	neg	edx
	shr	edx, 1		// edx = a

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543	

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI >> 1);
; 1094 : }

	lea	edx, [edx*2+2]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

; 1018 : 				lLM = lM;
; 1019 : 				lLM *= vfLVolume;
; 1020 : 				lLM >>= 5;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lLM;
; 1028 : 						lM *= vfRVolume;
; 1029 : 						lM >>= 5;
; 1030 : 				pBuffer[dwI+1] += (short) lM;
; 1036 : 
; 1037 : 				dwI += 2;
	sub	edx, eax

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_lx
no_oflowlx:

	imul	esi, edx

; 1038 : 			} while (--dwIncDelta);

	sar	esi, 5					; 00000005H
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	jo	overflow_rx

no_oflowrx:

	add	edi, 2
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:

; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 984  : 			{
; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaLVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfLVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfLVFract += vfDeltaLVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;
; 998  :             vfRVFract += vfDeltaRVolume;

	sar	ecx, 8
	mov	DWORD PTR vfLVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR vfDeltaRVolume

	mov	DWORD PTR vfLVolume, edx
	mov	edx, DWORD PTR vfRVFract

	add	edx, esi
	mov	DWORD PTR pfPitch, ecx

	mov	DWORD PTR vfRVFract, edx
	mov	esi, DWORD PTR dwDeltaPeriod

; 999  :             vfRVolume = vfRVFract >> 8;

	sar	edx, 8
	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	mov	DWORD PTR vfRVolume, edx
	jmp	$L30541

// Handle truncation.

overflow_l:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowl
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflowl

overflow_r:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowr
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowr

overflow_lx:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowlx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowlx

overflow_rx:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowrx
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowrx

$L30543:
; 1041 : 		}
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	add	ebx, ecx
	and	esi, 4095				; 00000fffH

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1049 :         lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

    sub	edx, eax
	
    imul	edx, esi

; 1052 :         lLM = lM;
; 1053 :         lLM *= vfLVolume;
; 1054 :         lLM >>= 5;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lLM;

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_l
no_oflowl:

; 1078 :         lM *= vfRVolume;
; 1079 : 		lM >>= 5;

	imul	esi, edx

; 1080 : 		pBuffer[dwI+1] += (short) lM;
; 1085 : no_oflowr:
; 1087 : 		dwI += 2;

	sar	esi, 5					; 00000005H
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	mov	edx, DWORD PTR pfPFract

	jo	overflow_r

no_oflowr:
; 978  : 
; 979  :     for (dwI = 0; dwI < dwLength; )

	add	edi, 2
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}

/*****************************************************************************
 * CDigitalAudio::MixMono8()
 *****************************************************************************
 * Implement a mono eight-bit mix.
 * Heavily optimized for x86 non-MMX, plus C code for non-x86.
 */
DWORD CDigitalAudio::MixMono8(short * pBuffer,    DWORD dwLength,
                              DWORD dwDeltaPeriod,VFRACT vfDeltaVolume,
                              PFRACT pfDeltaPitch,PFRACT pfSampleLength, 
                              PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around. 

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lM = pcWave[dwPosition];
	    lM += ((pcWave[dwPosition + 1] - lM) * dwFract) >> 12;
		lM *= vfVolume;
		lM >>= 5;

#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#else // !_ALPHA_
    //  TODO -- overflow code on ia64 (+ axp64?)
#endif // !_ALPHA_

#else // _X86_  (dead code)
      // Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:
#endif  // _X86_  (dead code)
		dwI++;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:

; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta

; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;

; 1009 : 	a = dwLength - dwI;	// Remaining span.

	mov	edx, edi
	neg	edx

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI);
; 1094 : }

	lea	edx, [edx+1]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
		
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

	sub	edx, eax

; 1018 : 				lLM = lM;
; 1019 : 				lLM *= vfLVolume;
; 1020 : 				lLM >>= 5;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lLM;
; 1027 : no_oflowx:	
; 1037 : 				++dwI;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	mov	ecx, DWORD PTR pfPitch
	add	edx, eax

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	jo	overflow_x

no_oflowx:

	inc	edi
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 984  : 			{
; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfVFract += vfDeltaVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;

	sar	ecx, 8
	mov	DWORD PTR vfVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR dwDeltaPeriod


	mov	DWORD PTR vfVolume, edx
	mov	DWORD PTR pfPitch, ecx


	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	jmp	$L30541

// Handle truncation.

overflow_:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflow
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflow

overflow_x:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	add	ebx, ecx
	and	esi, 4095				; 00000fffH

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1049 :         lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lLM = lM;
; 1053 :         lLM *= vfLVolume;
; 1054 :         lLM >>= 5;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lLM;

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	jo	overflow_
no_oflow:
	inc	edi
	mov	edx, DWORD PTR pfPFract

; 979  :     for (dwI = 0; dwI < dwLength; )

	mov	ecx, DWORD PTR pfPitch
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    m_vfLastLVolume = vfVolume;
    m_vfLastRVolume = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}


/*****************************************************************************
 * CDigitalAudio::Mix16()
 *****************************************************************************
 * Implement a stereo sixteen-bit mix.
 * Heavily optimized for x86 non-MMX, plus C code for non-x86.
 */
DWORD CDigitalAudio::Mix16(short * pBuffer,      DWORD dwLength, 
                           DWORD dwDeltaPeriod,  VFRACT vfDeltaLVolume, 
                           VFRACT vfDeltaRVolume,PFRACT pfDeltaPitch, 
                           PFRACT pfSampleLength,PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8; 
	dwLength <<= 1;

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
				pfSamplePos -= pfLoopLength;
			}
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = ((pcWave[dwPosition+1] - lA) * dwFract);
        lM >>= 12;
        lM += lA;
        lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;
#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lA, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else // !_ALPHA_
    //  TODO -- overflow detection on ia64 (+ axp64?)
#endif // !_ALPHA_
#else // _X86_  (dead code)
      //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lA;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:

#endif // _X86_  (dead code)
		dwI += 2;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta
; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = (dwLength - dwI) / 2;	// Remaining span.

	mov	edx, edi
	neg	edx
	shr	edx, 1		// edx = a

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI >> 1);
; 1094 : }

	lea	edx, [edx*2+2]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
		
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1014 : 				lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]
	sub	edx, eax

; 1018 : 				lA = lM;
; 1019 : 				lA *= vfLVolume;
; 1020 : 				lA >>= 13;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lA;
; 1027 : no_oflowlx:	
; 1028 : 						lM *= vfRVolume;
; 1029 : 						lM >>= 13;
; 1030 : 				pBuffer[dwI+1] += (short) lM;
; 1035 : no_oflowrx:
; 1037 : 				dwI += 2;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax
	mov	eax, DWORD PTR pBufX

	imul	esi, edx

	sar	esi, 13					; 0000000dH

	add	WORD PTR [eax+edi*2], si

	mov	esi, DWORD PTR vfRVolume
	jo	overflow_lx
no_oflowlx:

	imul	esi, edx

; 1038 : 			} while (--dwIncDelta);

	sar	esi, 13					; 0000000dH
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	jo	overflow_rx

no_oflowrx:

	add	edi, 2
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaLVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfLVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfLVFract += vfDeltaLVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;
; 998  :             vfRVFract += vfDeltaRVolume;

	sar	ecx, 8
	mov	DWORD PTR vfLVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR vfDeltaRVolume

	mov	DWORD PTR vfLVolume, edx
	mov	edx, DWORD PTR vfRVFract

	add	edx, esi
	mov	DWORD PTR pfPitch, ecx

	mov	DWORD PTR vfRVFract, edx
	mov	esi, DWORD PTR dwDeltaPeriod

; 999  :             vfRVolume = vfRVFract >> 8;

	sar	edx, 8
	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	mov	DWORD PTR vfRVolume, edx
	jmp	$L30541

// Handle truncation.
overflow_l:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowl
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflowl

overflow_r:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowr
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowr

overflow_lx:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowlx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowlx

overflow_rx:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowrx
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowrx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	and	esi, 4095				; 00000fffH
	add	ebx, ecx

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1049 :         lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lA = lM;
; 1053 :         lA *= vfLVolume;
; 1054 :         lA >>= 13;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lA;

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_l
no_oflowl:

; 1077 : no_oflowl:	
; 1078 :         lM *= vfRVolume;
; 1079 : 		lM >>= 13;

	imul	esi, edx

; 1080 : 		pBuffer[dwI+1] += (short) lM;
; 1085 : no_oflowr:
; 1086 : #endif  /* _ALPHA */
; 1087 : 		dwI += 2;

	sar	esi, 13					; 0000000dH
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	mov	edx, DWORD PTR pfPFract

	jo	overflow_r
no_oflowr:

	add	edi, 2

; 978  : 
; 979  :     for (dwI = 0; dwI < dwLength; )

	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}



/*****************************************************************************
 * CDigitalAudio::MixMono16()
 *****************************************************************************
 * Implement a mono sixteen-bit mix.
 * Heavily optimized for x86 non-MMX, plus C code for non-x86.
 */
DWORD CDigitalAudio::MixMono16(short * pBuffer,    DWORD dwLength,
                               DWORD dwDeltaPeriod,VFRACT vfDeltaVolume,
                               PFRACT pfDeltaPitch,PFRACT pfSampleLength, 
                               PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.

#ifndef _X86_
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        lM *= vfVolume; 
        lM >>= 13;         // Signal bumps up to 12 bits.

#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#else // !_ALPHA_
    // TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#else // _X86_  (dead code)
        // Keep this around so we can use it to generate new assembly code (see below...)
        pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:	
#endif // _X86  (dead code)
		dwI++;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta
; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = dwLength - dwI;	// Remaining span.

	mov	edx, edi
	neg	edx

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:
	push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI);
; 1094 : }

	lea	edx, [edx+1]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

; 1018 : 				lA = lM;
; 1019 : 				lA *= vfLVolume;
; 1020 : 				lA >>= 13;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lA;
; 1027 : no_oflowx:	
; 1037 : 				++dwI;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax
	mov	ecx, DWORD PTR pfPitch

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	jo	overflow_x
no_oflowx:

; 1038 : 			} while (--dwIncDelta);

	inc	edi
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfVFract += vfDeltaVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfVolume = vfVFract >> 8;

	sar	ecx, 8
	mov	DWORD PTR vfVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR dwDeltaPeriod

	mov	DWORD PTR vfVolume, edx
	mov	DWORD PTR pfPitch, ecx


	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	jmp	$L30541

// Handle truncation.
overflow_:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflow
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflow

overflow_x:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	and	esi, 4095				; 00000fffH
	add	ebx, ecx

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1049 :         lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lA = lM;
; 1053 :         lA *= vfVolume;
; 1054 :         lA >>= 13;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lA;

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	jo	overflow_
no_oflow:
; 1077 : no_oflowl:	
; 1087 : 		++dwI;

	inc	edi
	mov	edx, DWORD PTR pfPFract

; 979  :     for (dwI = 0; dwI < dwLength; )

	mov	ecx, DWORD PTR pfPitch
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}
	dwI += dwLength;

#endif // _X86_
    m_vfLastLVolume = vfVolume;
    m_vfLastRVolume = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}

=== ddksynth/mmx.cpp ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//      Mmx.cpp
//      MMX Mix engines for Microsoft synth

/*
Variable useage.

		Variable									register 
		pfSamplePos									eax
		pfPitch										ebx
		dwI											ecx
		dwIncDelta									edx (edx is sometimes a temporary register)
		dwPosition1									esi
		dwPostiion2									edi

		vfRvolume and vfLvolume						mm0		
		vfRVolume, vfLVolume						mm2		

		mm4 - mm7 are temporary mmx registers.
*/

// Notes about calculation.

		// Loop is unrolled once.
		// *1  shifting volumne to 15 bit values to get rid of shifts and simplify code.
		// This make the packed mulitply work better later since I keep the sound interpolated
		// wave value at 16 bit signed value.  For a PMULHW, this results in 15 bit results
		// which is the same as the original code.


		// *2 linear interpolation can be done very quickly with MMX by re-arranging the
		// way that the interpolation is done. Here is code in C that shows the difference.
		// Original C code		
        //lM1 = ((pcWave[dwPosition1 + 1] - pcWave[dwPosition1]) * dwFract1) >> 12;
		//lM2 = ((pcWave[dwPosition2 + 1] - pcWave[dwPosition2]) * dwFract2) >> 12;
        //lM1 += pcWave[dwPosition1];
		//lM2 += pcWave[dwPosition2];

		// Equivalent C Code that can be done with a pmadd
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;


#include "common.h"

#define STR_MODULENAME "DDKSynth.sys:MMX: "

typedef unsigned __int64 QWORD;

#pragma code_seg()
/*****************************************************************************
 * CDigitalAudio::MixMono8X()
 *****************************************************************************
 * Implement a mono eight-bit mix.
 * Heavily optimized for MMX.
 */
DWORD CDigitalAudio::MixMono8X(short * pBuffer,     DWORD dwLength,    
                               DWORD dwDeltaPeriod, VFRACT vfDeltaVolume, 
                               PFRACT pfDeltaPitch, PFRACT pfSampleLength,
                               PFRACT pfLoopLength)
{
    DWORD dwI,dwIncDelta = dwDeltaPeriod;
    
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfVolume
	movd	mm7, vfVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaVolume
	movd	mm6, vfDeltaVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfVFract += vfDeltaVolume;
											// vfVFract += vfDeltaVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		inc		ecx					//dwI++;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		//shl		esi, 1			// do not shift left since pcWave is array of chars
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movzx	esi, word ptr[esi]	//lLM1 = pcWave[dwPosition1];
		movd	mm3, esi

		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		//shl		edi, 1			//do not shift left since pcWave is array of chars
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;
		
		movzx	edi, word ptr[edi]	//lLM2 = pcWave[dwPoisition2];
		movd	mm6, edi

		pxor	mm7, mm7		// zero out mm7 to make 8 bit into 16 bit
					
								// low 4 bytes in mm3
		punpcklwd	mm3, mm6	// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1]											
		
		add		esi, pBuffer	//
	punpcklbw	mm7, mm3		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		

		movq	mm3, mm2		// put left and right volume levels in mm3
		add		eax, ebx		//pfSamplePos += pfPitch;

		packssdw	mm3, mm2		// words in mm7
								// vfVolume, vfVolume, vfVolume, vfVolume
									
		movd	mm5, dword ptr[esi-2]	// Load values from buffer
		inc		ecx				// dwI++;
						
		psrad	mm7, 12			// shift back down to 16 bits.

	packssdw	mm7, mm4		// only need one word in mono case.
								// low word are lm2 and lm1
										        
		// above multiplies and shifts are all done with this one pmul. Low two word are only
		// interest in mono case
		pmulhw		mm3, mm7	// lLM1 *= vfVolume;								
								// lLM2 *= vfVolume;
								
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movd	dword ptr[esi-2], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		//shl		esi, 1				// do not shift left since pcWave is array of chars
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		movzx	esi, word ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		pxor	mm7, mm7
								// low four bytes
		movd	mm4, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

								// 8 bytes after unpakc
		punpcklbw	mm7, mm4	// 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits
				
		movq		mm5, mm2	// move volume into mm5
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer

		movd	edx, mm5

		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:		
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //m_vfLastLVolume = vfVolume;
    //m_vfLastRVolume = vfVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
	movd	[edx]this.m_vfLastLVolume, mm2	
	movd	[edx]this.m_vfLastRVolume, mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI);
}


/*****************************************************************************
 * CDigitalAudio::Mix8X()
 *****************************************************************************
 * Implement a stereo eight-bit mix.
 * Heavily optimized for MMX.
 */
DWORD CDigitalAudio::Mix8X(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)

{
    DWORD dwI;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
	//long lM2, lLM2;
    DWORD dwIncDelta = dwDeltaPeriod;
    //VFRACT dwFract1, dwFract2;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;

	VFRACT vfLVolume2 = m_vfLastLVolume;
    VFRACT vfRVolume2 = m_vfLastRVolume;

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
	dwLength <<= 1;

	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfLVolume
	movd	mm7, vfRVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaLVolume
	movd	mm6, vfDeltaRVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfLVFract += vfDeltaLVolume;
											// vfRVFract += vfDeltaRVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		add		ecx, 2				//dwI += 2;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		//shl		esi, 1			// do not shift left since pcWave is array of chars
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movzx	esi, word ptr[esi]	//lLM1 = pcWave[dwPosition1];

		movd	mm3, esi

		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		//shl		edi, 1			// do not shift left since pcWave is array of chars
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		
					
		movzx	edi, word ptr[edi]	//lLM2 = pcWave[dwPosition2];
		movd	mm6, edi
	
		pxor	mm7, mm7		// zero out mm7 to make 8 bit into 16 bit

								// low 4 bytes bytes in mm3
	punpcklwd	mm3, mm6		// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
		
		add		esi, pBuffer	//
	punpcklbw	mm7, mm3		// bytes in mm7
								// pcWave[dwPos2+1], 0, pcWave[dwPos2], 0, pcWave[dwPos1+1], pcWave[dwPos1], 0 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		

		movq	mm3, mm2		// put left and right volume levels in mm3

		add		eax, ebx		//pfSamplePos += pfPitch;
	packssdw	mm3, mm2		// words in mm3
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		movq	mm5, qword ptr[esi-4]	// Load values from buffer
		add		ecx, 2			// dwI += 2;
						
		psrad	mm7, 12			// shift back down to 16 bits.

		pand	mm7, wordmask	// combine results to get ready to multiply by left and right
		movq	mm6, mm7		// volume levels.
		pslld	mm6, 16			//
		por		mm7, mm6		// words in mm7
								// lM2, lM2, lM1, lM1
										        
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm3, mm7	// lLM1 *= vfLVolume;
								// lM1 *= vfRVolume;
								// lLM2 *= vfLVolume;
								// lM2 *= vfRVolume;
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movq	qword ptr[esi-4], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		//shl		esi, 1				// do not shift left since pcWave is array of chars
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		movzx	esi, word ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

		pxor	mm7, mm7
								// byte in MMX registers
		movd	mm4, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

		punpcklbw	mm7, mm4	// 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits

		pand		mm7, wordmask	// combine results to get ready to multiply by left and right 
		movq		mm6, mm7		// volume levels.
		pslld		mm6, 16			//
		por			mm7, mm6		// words in mm7
									// lM2, lM2, lM1, lM1

		pxor		mm6, mm6

		movq		mm5, mm2	// move volume1 into mm5
								
								// use pack to get 4 volume values together for multiplication.
		packssdw	mm5, mm6    // words in mm7
								// 0, 0, vfRVolume1, vfLVolume1
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer		

/*
		add		word ptr[edi-4], si
        jno		no_oflowl1
		// pBuffer[dwI] = 0x7fff;
		mov		word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
		mov		word ptr[edi-4], 0x8000
no_oflowl1:
		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:
*/
		movd	mm7, dword ptr[edi-4]		
		paddsw	mm7, mm5
		movd	dword ptr[edi-4], mm7
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //m_vfLastLVolume = vfLVolume;
    //m_vfLastRVolume = vfRVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
	movd	[edx]this.m_vfLastLVolume, mm2
	psrlq	mm2, 32
	movd	[edx]this.m_vfLastRVolume, mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI >> 1);
}


/*****************************************************************************
 * CDigitalAudio::MixMono16X()
 *****************************************************************************
 * Implement a mono sixteen-bit mix.
 * Heavily optimized for MMX.
 */
DWORD CDigitalAudio::MixMono16X(short * pBuffer,    DWORD dwLength,
                                DWORD dwDeltaPeriod,VFRACT vfDeltaVolume,
                                PFRACT pfDeltaPitch,PFRACT pfSampleLength, 
                                PFRACT pfLoopLength)
{
    DWORD dwI,dwIncDelta = dwDeltaPeriod;
    
    short * pcWave = (short*) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfVolume
	movd	mm7, vfVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaVolume
	movd	mm6, vfDeltaVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfVFract += vfDeltaVolume;
											// vfVFract += vfDeltaVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		inc		ecx					//dwI++;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		shl		esi, 1			// shift left since pcWave is array of shorts
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movd	mm7, dword ptr[esi]	//lLM1 = pcWave[dwPosition1];
		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		shl		edi, 1			// shift left since pcWave is array of shorts
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		movq	mm3, mm2		// put left and right volume levels in mm3
		
					
		movd	mm6, dword ptr[edi]	//lLM2 = pcWave[dwPosition2];
	packssdw	mm3, mm2		// words in mm7
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		add		esi, pBuffer	//
	punpckldq	mm7, mm6		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		
		add		eax, ebx		//pfSamplePos += pfPitch;
		
		movd	mm5, dword ptr[esi-2]	// Load values from buffer
		inc		ecx				// dwI++;
						
		psrad	mm7, 12			// shift back down to 16 bits.

	packssdw	mm7, mm4		// only need one word in mono case.
								// low word are lm2 and lm1
										        
		// above multiplies and shifts are all done with this one pmul. Low two word are only
		// interest in mono case
		pmulhw		mm3, mm7	// lLM1 *= vfVolume;								
								// lLM2 *= vfVolume;
								
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movd	dword ptr[esi-2], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		shl		esi, 1				// shift left since pcWave is array of shorts
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		mov		esi, dword ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		movd	mm7, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits
				
		movq		mm5, mm2	// move volume into mm5
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer

		movd	edx, mm5

		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:		
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //m_vfLastLVolume = vfVolume;
    //m_vfLastRVolume = vfVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
	movd	[edx]this.m_vfLastLVolume, mm2	
	movd	[edx]this.m_vfLastRVolume, mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI);
}


/*****************************************************************************
 * CDigitalAudio::Mix16X()
 *****************************************************************************
 * Implement a stereo sixteen-bit mix.
 * Heavily optimized for MMX.
 */
DWORD CDigitalAudio::Mix16X(short * pBuffer,      DWORD dwLength, 
                            DWORD dwDeltaPeriod,  VFRACT vfDeltaLVolume, 
                            VFRACT vfDeltaRVolume,PFRACT pfDeltaPitch, 
                            PFRACT pfSampleLength,PFRACT pfLoopLength)
{
    DWORD dwI,dwIncDelta = dwDeltaPeriod;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
	//long lM2, lLM2;
    //VFRACT dwFract1, dwFract2;
    short * pcWave = (short *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;

	VFRACT vfLVolume2 = m_vfLastLVolume;
    VFRACT vfRVolume2 = m_vfLastRVolume;

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
	dwLength <<= 1;

	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfLVolume
	movd	mm7, vfRVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaLVolume
	movd	mm6, vfDeltaRVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfLVFract += vfDeltaLVolume;
											// vfRVFract += vfDeltaRVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		add		ecx, 2				//dwI += 2;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		shl		esi, 1			// shift left since pcWave is array of shorts
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movd	mm7, dword ptr[esi]	//lLM1 = pcWave[dwPosition1];
		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		shl		edi, 1			// shift left since pcWave is array of shorts
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		movq	mm3, mm2		// put left and right volume levels in mm3
		
					
		movd	mm6, dword ptr[edi]	//lLM2 = pcWave[dwPosition2];
	packssdw	mm3, mm2		// words in mm7
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		add		esi, pBuffer	//
	punpckldq	mm7, mm6		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		
		add		eax, ebx		//pfSamplePos += pfPitch;
		
		movq	mm5, qword ptr[esi-4]	// Load values from buffer
		add		ecx, 2			// dwI += 2;
						
		psrad	mm7, 12			// shift back down to 16 bits.

		pand	mm7, wordmask	// combine results to get ready to multiply by left and right
		movq	mm6, mm7		// volume levels.
		pslld	mm6, 16			//
		por		mm7, mm6		// words in mm7
								// lM2, lM2, lM1, lM1
										        
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm3, mm7	// lLM1 *= vfLVolume;
								// lM1 *= vfRVolume;
								// lLM2 *= vfLVolume;
								// lM2 *= vfRVolume;
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movq	qword ptr[esi-4], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		shl		esi, 1				// shift left since pcWave is array of shorts
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		mov		esi, dword ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		movd	mm7, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits

		pand		mm7, wordmask	// combine results to get ready to multiply by left and right 
		movq		mm6, mm7		// volume levels.
		pslld		mm6, 16			//
		por			mm7, mm6		// words in mm7
									// lM2, lM2, lM1, lM1

		pxor		mm6, mm6

		movq		mm5, mm2	// move volume1 into mm5
								
								// use pack to get 4 volume values together for multiplication.
		packssdw	mm5, mm6    // words in mm7
								// 0, 0, vfRVolume1, vfLVolume1
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer		

/*
		add		word ptr[edi-4], si
        jno		no_oflowl1
		// pBuffer[dwI] = 0x7fff;
		mov		word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
		mov		word ptr[edi-4], 0x8000
no_oflowl1:
		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:
*/
		movd	mm7, dword ptr[edi-4]		
		paddsw	mm7, mm5
		movd	dword ptr[edi-4], mm7
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //m_vfLastLVolume = vfLVolume;
    //m_vfLastRVolume = vfRVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
	movd	[edx]this.m_vfLastLVolume, mm2
	psrlq	mm2, 32
	movd	[edx]this.m_vfLastRVolume, mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI >> 1);
}

/*****************************************************************************
 * MMXDisabled()
 *****************************************************************************
 * Check the registry key to determine whether to ignore MMX.
 */
static BOOL MMXDisabled()
{
    ULONG ulValue;

    if (!GetRegValueDword(
            TEXT("Software\\Microsoft\\DirectMusic"),
            TEXT("MMXDisabled"),
            &ulValue))
    {
        return FALSE;
    }

    return (BOOL)ulValue;
}

#define CPU_ID _asm _emit 0x0f _asm _emit 0xa2  

/*****************************************************************************
 * MultiMediaInstructionsSupported()
 *****************************************************************************
 * Returns whether this CPU supports MMX.
 */
BOOL MultiMediaInstructionsSupported()
{
    BOOL bMultiMediaInstructionsSupported;
    
	if (!MMXDisabled())
	{
		_asm 
		{
			pushfd                      // Store original EFLAGS on stack
			pop     eax                 // Get original EFLAGS in EAX
			mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
			xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
			push    eax                 // Save new EFLAGS value on stack
			popfd                       // Replace current EFLAGS value
			pushfd                      // Store new EFLAGS on stack
			pop     eax                 // Get new EFLAGS in EAX
			xor     eax, ecx            // Can we toggle ID bit?
			jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
			mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
			push	ebx
			CPU_ID                      // Get family/model/stepping/features
			pop		ebx
            xor     eax,eax             // Assume failure
			test    edx, 0x00800000L    // Check if mmx technology available
			jz      Done                // Jump if no
                    		// Tests passed, this machine supports MMX
            inc     eax                 // Set to success
Done:
            mov     bMultiMediaInstructionsSupported, eax
		}
    } else {
        bMultiMediaInstructionsSupported = 0;
    }

    return (bMultiMediaInstructionsSupported);
}    


=== ddksynth/muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-2000 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routine for 32 bit signed and unsiged numbers.
//
//      MulDiv(a,b,c) = (a * b) / c         (round down, signed)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


//----------------------------------------------------------------------;
//
//  Win 32
//
//----------------------------------------------------------------------;

#ifdef _X86_

    //
    //  Use 32-bit x86 assembly.
    //

    #pragma warning(disable:4035 4704)

    INLINE LONG MulDiv(LONG a,LONG b,LONG c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     imul    ebx              //  imul ebx
        _asm     idiv    ecx              //  idiv ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDiv()

    #pragma warning(default:4035 4704)


#else

    //
    //  Use C9 __int64 support for Daytona RISC platforms.
    //

    INLINE LONG MulDiv( LONG a, LONG b, LONG c )
    {
        return (LONG)( Int32x32To64(a,b) / c );
    }


#endif


#endif  // _INC_MULDIV32


=== ddksynth/plclock.cpp ===

//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.

/*      CPhaseLockClock

*/

#include "common.h"

#define STR_MODULENAME "DDKSynth.sys:PLClock: "

#include "plclock.h"

#define MILS_TO_REF 10000

#pragma code_seg()
/*****************************************************************************
 * CPhaseLockClock::CPhaseLockClock()
 *****************************************************************************
 * Constructor for the CPhaseLockClock object.
 */
CPhaseLockClock::CPhaseLockClock()
{
    m_rfOffset = 0;
}

/*****************************************************************************
 * CPhaseLockClock::Start()
 *****************************************************************************
 * Start this clock.  When the clock starts, it needs to mark down the 
 * difference between the time it is given and its concept of time. 
 */
void CPhaseLockClock::Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime)
{
    m_rfOffset = rfMasterTime - rfSlaveTime;
}   

/*****************************************************************************
 * CPhaseLockClock::GetSlaveTime()
 *****************************************************************************
 * Convert the passed time to use the same base as the master clock.
 */
void CPhaseLockClock::GetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)
{
    rfSlaveTime += m_rfOffset;
    *prfTime = rfSlaveTime;
}

/*****************************************************************************
 * CPhaseLockClock::SetSlaveTime()
 *****************************************************************************
 * Reset the relationship between the two clocks.
 */
void CPhaseLockClock::SetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)
{
    rfSlaveTime -= m_rfOffset;
    *prfTime = rfSlaveTime;
}

/*****************************************************************************
 * CPhaseLockClock::SyncToMaster()
 *****************************************************************************
 * SyncToTime provides the needed magic to keep the clock
 * in sync. Since the clock uses its own clock (rfSlaveTime)
 * to increment, it can drift. This call provides a reference
 * time which the clock compares with its internal 
 * concept of time. The difference between the two is
 * considered the drift. Since the sync time may increment in
 * a lurching way, the correction has to be subtle. 
 * So, the difference between the two is divided by
 * 100 and added to the offset.
 */
void CPhaseLockClock::SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime)
{
    rfSlaveTime += m_rfOffset;
    rfSlaveTime -= rfMasterTime;    // Find difference between calculated and expected time.
    rfSlaveTime /= 100;             // Reduce in magnitude.
    m_rfOffset -= rfSlaveTime;      // Subtract that from the original offset.
}

/*****************************************************************************
 * CSampleClock::CSampleClock()
 *****************************************************************************
 * Constructor for CSampleClock object.
 */
CSampleClock::CSampleClock()
{
    m_llStart = 0;
    m_dwSampleRate = 22050;
}

/*****************************************************************************
 * CSampleClock::Start()
 *****************************************************************************
 * Start the sample clock.  Start any corresponding phase lock clock.
 */
void CSampleClock::Start(IReferenceClock *pIClock, DWORD dwSampleRate, LONGLONG llSampleTime)
{
    REFERENCE_TIME rfStart;
    m_llStart = llSampleTime;
    m_dwSampleRate = dwSampleRate;
    if (pIClock)
    {
        pIClock->GetTime(&rfStart);
        m_PLClock.Start(rfStart,0);
    }

    llSampleTime *= (MILS_TO_REF * 1000);
    llSampleTime /= m_dwSampleRate;
    m_rfStart = llSampleTime;
}

/*****************************************************************************
 * CSampleClock::SampleToRefTime()
 *****************************************************************************
 * Convert between sample time and reference time (100ns units).
 */
void CSampleClock::SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime)
{
    llSampleTime -= m_llStart;
    llSampleTime *= (MILS_TO_REF * 1000);
    llSampleTime /= m_dwSampleRate;
    m_PLClock.GetSlaveTime(llSampleTime, prfTime);
}

/*****************************************************************************
 * CSampleClock::RefTimeToSample()
 *****************************************************************************
 * Convert between sample time and reference time (100ns units).
 */
LONGLONG CSampleClock::RefTimeToSample(REFERENCE_TIME rfTime)
{
    m_PLClock.SetSlaveTime(rfTime, &rfTime);
    rfTime *= m_dwSampleRate;
    rfTime /= (MILS_TO_REF * 1000);
    return rfTime + m_llStart;
}

/*****************************************************************************
 * CSampleClock::SyncToMaster()
 *****************************************************************************
 * Sync this clock to the given sample time and the given reference clock.
 */
void CSampleClock::SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock)
{
    llSampleTime -= m_llStart;
    llSampleTime *= (MILS_TO_REF * 1000);
    llSampleTime /= m_dwSampleRate;
    if (pIClock)
    {
        REFERENCE_TIME rfMasterTime;
        pIClock->GetTime(&rfMasterTime);
        m_PLClock.SyncToMaster(llSampleTime, rfMasterTime);
    }
}

/*****************************************************************************
 * CSampleClock::SyncToMaster()
 *****************************************************************************
 * Sync the two given reference times, using our phase lock clock.
 */
void CSampleClock::SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime)
{
    rfSlaveTime -= m_rfStart;
    m_PLClock.SyncToMaster(rfSlaveTime, rfMasterTime);
}


=== ddksynth/plclock.h ===

//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.

/*      PLClock.h

*/

#ifndef __PLCLOCK_H__
#define __PLCLOCK_H__

#define IReferenceClock IMasterClock

/*****************************************************************************
 * class CPhaseLockClock
 *****************************************************************************
 * This implements a clock that phase locks two reference clocks.
 */
class CPhaseLockClock
{
public:
                    CPhaseLockClock();
    void            Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime);
    void            GetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
    void            SetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
    void            SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime);

private:
    REFERENCE_TIME  m_rfOffset;
};

/*****************************************************************************
 * class CSampleClock
 *****************************************************************************
 * This implements a clock that translates between a sample time and a 
 * reference time, doing any phase locking in a child CPhaseLockClock object.
 */
class CSampleClock
{
public:
                    CSampleClock();
    void            Start(IReferenceClock *pIClock, DWORD dwSampleRate, LONGLONG llSampleTime);
    void            SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
    void            SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock);
    void            SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime);
    LONGLONG        RefTimeToSample(REFERENCE_TIME rfTime);

private:
    CPhaseLockClock m_PLClock;
    LONGLONG        m_llStart;      // Initial sample offset.
    REFERENCE_TIME  m_rfStart;
    DWORD           m_dwSampleRate;
};


#endif  // __PLCLOCK_H__


=== ddksynth/private.h ===
/*
    Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
*/

#ifndef _PRIVATE
#define _PRIVATE_

#include "clist.h"
#include "plclock.h"


#define STATIC_CLSID_DDKWDMSynth\
    0x820DC38AL, 0x1F81, 0x11d3, 0xA8, 0x2E, 0x00, 0x60, 0x08, 0x33, 0x16, 0xC1
DEFINE_GUIDSTRUCT("820DC38A-1F81-11d3-A82E-0060083316C1", CLSID_DDKWDMSynth);
#define CLSID_DDKWDMSynth DEFINE_GUIDNAMED(CLSID_DDKWDMSynth)

#define STATIC_KSNODETYPE_DMDDKSYNTH\
    0xD2D37597L, 0xA312, 0x434C, 0xA2, 0xDD, 0x2B, 0x4C, 0x32, 0xE6, 0x65, 0x8A
DEFINE_GUIDSTRUCT("D2D37597-A312-434C-A2DD-2B4C32E6658A", KSNODETYPE_DMDDKSYNTH);
#define KSNODETYPE_DMDDKSYNTH DEFINE_GUIDNAMED(KSNODETYPE_DMDDKSYNTH)


NTSTATUS CreateMiniportDmSynth(OUT PUNKNOWN * Unknown,
                               IN  PUNKNOWN   UnknownOuter OPTIONAL,
                               IN  POOL_TYPE  PoolType);

class CDmSynthStream;

/*****************************************************************************
 * class CMiniportDmSynth
 *****************************************************************************
 * Each miniport instance corresponds to a port instance of type DMus.
 * This miniport implements the standard IMP_IMiniportDMus.
 */
class CMiniportDmSynth : public IMiniportDMus, public CUnknown
{
    friend class CDmSynthStream;

public:
    IMP_IMiniportDMus;

    // IUnknown
    //
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportDmSynth);
    ~CMiniportDmSynth();

private:
    PPORTDMUS           m_pPort;
    CList               m_StreamList;
    CRITICAL_SECTION    m_CriticalSection;
};

/*****************************************************************************
 * class CDmSynthStream
 *****************************************************************************
 * The stream implements the standard MXF functions.  This stream handles
 * DLS and running statistics on a per-stream basis.
 */
class CDmSynthStream : public ISynthSinkDMus, public CUnknown, public CListItem
{
    friend class CMiniportDmSynth;

public:
    IMP_ISynthSinkDMus;

    // IUnknown
    //
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CDmSynthStream);
    ~CDmSynthStream();

    // Class
    //
    NTSTATUS Init(CMiniportDmSynth * Miniport);
    NTSTATUS InitMidiIn(PAllocatorMXF AllocatorMXF, PMASTERCLOCK MasterClock);
    NTSTATUS InitWaveOut(PKSDATAFORMAT DataFormat);

    NTSTATUS HandlePropertySupport(PPCPROPERTY_REQUEST pRequest);
    NTSTATUS HandlePropertyEffects(PPCPROPERTY_REQUEST pRequest);

    NTSTATUS HandlePropertySynth(PPCPROPERTY_REQUEST pRequest);
    NTSTATUS HandlePortParams(PPCPROPERTY_REQUEST pRequest);
    NTSTATUS HandleRunningStats(PPCPROPERTY_REQUEST pRequest);

    NTSTATUS HandlePropertySynthDls(PPCPROPERTY_REQUEST pRequest);
    NTSTATUS HandleDownload(PPCPROPERTY_REQUEST pRequest);
    NTSTATUS HandleUnload(PPCPROPERTY_REQUEST pRequest);
    void     PutMessageInternal(void);

private:
    CMiniportDmSynth *  m_pMiniport;

    BOOL                m_fWaveOutCreated;
    BOOL                m_fMidiInCreated;

    PAllocatorMXF       m_pAllocator;
    PMASTERCLOCK        m_pMasterClock;

    CSynth *            m_pSynth;
    SYNTH_PORTPARAMS    m_PortParams;
    KSSTATE             m_State;

    LONG                m_lVolume;
    LONG                m_lBoost;

    CSampleClock        m_SampleClock;
    LONGLONG            m_llStartPosition;
    LONGLONG            m_llLastPosition;

    PDMUS_KERNEL_EVENT  m_EventList;
    KSPIN_LOCK          m_EventListLock;
    WORK_QUEUE_ITEM     m_EventListWorkItem;
};

typedef CDmSynthStream *PDMSYNTHSTREAM;


#endif // _PRIVATE_

=== ddksynth/sources ===

# Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

TARGETNAME=DDKSynth
USE_MAPSYM=1

TARGETTYPE=DRIVER
TARGETPATH=obj

TARGETLIBS= \
    $(SDK_LIB_PATH)\portcls.lib          \
    $(SDK_LIB_PATH)\ksguid.lib           \
    $(SDK_LIB_PATH)\libcntpr.lib         \
    ..\lib\*\stdunk.lib

INCLUDES= \
        ..\inc;

MSC_WARNING_LEVEL=-W3 -WX

C_DEFINES= $(C_DEFINES) -D_WIN32 -DUNICODE -D_UNICODE -DUNDER_NT

#
# Different levels of debug printage.  First is nothing but
# catastrophic errors, last is everything under the sun.
#
#C_DEFINES= $(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_ERROR
C_DEFINES= $(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_TERSE
#C_DEFINES= $(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_VERBOSE
#C_DEFINES= $(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_BLAB

LINKER_FLAGS=-map

SOURCES=            \
    adapter.cpp     \
    clist.cpp       \
    control.cpp     \
    csynth.cpp      \
    instr.cpp       \
    kernhelp.cpp    \
    midi.cpp        \
    miniport.cpp    \
    mix.cpp         \
    plclock.cpp     \
    syslink.cpp     \
    voice.cpp       \
    DDKSynth.rc

i386_SOURCES=       \
    mmx.cpp


=== ddksynth/synth.h ===
//      Synth.h
//      Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//

/*

  DLS Design Overview (DLS Level 1 Specification, MMA)

  A musical instruments defined by a sound sample is much more than a simple wave file.  
  In addition to the actual sample data and associated loop information, the instrument
  must indicate under what circumstances each sample should be used, and how to modulate,
  or articulate, the sample as it plays.

  A generic sample-playback synthesis architecture can be broken down into three distinct
  subsystems:

  Control logic

  Digital audio engine

  Articulation modules and connections




  Control Logic

  The control logic receives a MIDI note event and determines which instrument should play 
  the note, and, within that instrument, which sample and articulation combination to use.

  Choosing the instrument is little more than observing the MIDI channel number in the 
  event and selecting the proper instrument accordingly.

  Choosing the sample and articulation to use is not as simple.  Almost all samples synthesis
  architectures employ some method of organizing samples by note range across the keyboard.
  In addition, multiple samples can be used to represent different velocity randges and 
  multiple samples can be played at once to create a layered, richer sound.

  Terms such as layers, splits, blocks, and regions are commonly used in synthesizer jargon
  to refer to the management of multiple samples.  For the purposes here, we refer to them 
  as regions.

  DLS Level 1 implements a bare bones approach with no velocity cross-switching and no 
  layering.



  Digital Audio Engine

  The digital audio engine is certainly the most obvious part of the synthesizer.  It is 
  composed of a playback engine, or digital oscillator, and a digitally controlled amplifier.

  The digital oscillator plays a samples sound waveform, managing loop points within the
  waveform so the sound can play continuously if needed.  And, as the note plays, it responds 
  to changes in pitch, allowing for real time expression such as vibrato and pitch bend.

  The digitally controlled amplirier modulates the loudness of the instrument.  Importantly,
  this is used to control the amplitude shape, or envelope, of the note.  However, it is also
  used for other types of real-time expression, such as tremolo.

  Pitch and volume control of the oscillator and amplifier are critical because they define
  the shape of the sounds as it plays, and allow it to be dynamically responsive in real 
  time, giving the samples instrument much more expression than the simple digital audio 
  playback could ever provide.  Real-time control of these parameters comes from modules in 
  the Articulation section which generate a constant stream of changing pitch and volume to
  which the digital audio engine responds.

  The digital audio path represents the journey the sound takes from the oscillator to the 
  amplifier to the digital-to-analog converter (DAC).  This patch can optionally include 
  additional modules, such as filters and effects devices, that process the sound as it 
  flows from oscillator to DAC.

  The DLS Level 1 specificaion implements a simple digital audio engine composed of an 
  oscillator, amplifier, and DAC.  The oscillator supports looped as well as one-shot samples.



  Articulation Modules and Connections

  The articulation modules are a set of devices that provide additional control over the 
  pitch and volume of the sample as it plays.

  The articulation modules include low frequency oscillators (LFOs) to contribute vibrato
  and tremolo, envelope generators to defint an overall volume and pitch shape to the sample,
  and MIDI real-time controllers, such as Pitch Bend and Mod Wheel, to give the music real-time
  expression.

  Generally, these modules can be linked in different ways to provide different results.  For
  example, a LFO might generate a sine wave which modulates the pitch of the sample for vibrato
  of the volume of the sample for tremolo.  Modules can also receive as well as send control 
  signals.  An envelope generator might use the key velocity to influence the attack time of
  the envelope.

  Articulation modules can be configured in different ways, and this configuration is an 
  important part of the instrument definition.  In fact, the term patch as used for an 
  instrument preset refers to the early days when the hardware modules in an analog 
  synthesizer were "patched" together with cables, which routed signals from module to module.

  The ability to configure the modules in important because it yields a flexible approach to 
  synthesizer design.  At the same time, it is important to define the base level configuration 
  that can be supported by all hardware.

  So, the DLS Level 1 specification is relatively rigid.  It defines a preset routing 
  arrangement that is simple enough to be supportable by existing hardware.  Fortunately, it 
  is a musically logical and useful configuration.

  Importantly, the specification maps the routing on a flexible system, so it can grow into
  Level 2 and beyond.

  It is important to understand that this is purely a symbolic system that can be mapped on 
  many different hardware designs.  Do not think of it as the recipe for a specific method 
  for building synthesis architectures.  It should be flexible enough to provide a common
  language between hardware implementations.

*/





#ifndef __SYNTH_H__
#define __SYNTH_H__

#include "clist.h"
#include "dmdls.h"

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

// controller numbers
#define CC_BANKSELECTH  0x00
#define CC_BANKSELECTL  0x20

#define CC_MODWHEEL     0x01
#define CC_VOLUME       0x07
#define CC_PAN          0x0A
#define CC_EXPRESSION   0x0B
#define CC_SUSTAIN      0x40
#define CC_ALLSOUNDSOFF 0x78
#define CC_RESETALL     0x79
#define CC_ALLNOTESOFF  0x7B
#define CC_MONOMODE     0x7E
#define CC_POLYMODE     0x7F

// rpn controllers
#define CC_DATAENTRYMSB 0x06
#define CC_DATAENTRYLSB 0x26
#define CC_NRPN_LSB     0x62
#define CC_NRPN_MSB     0x63
#define CC_RPN_LSB      0x64
#define CC_RPN_MSB      0x65

// registered parameter numbers
#define RPN_PITCHBEND   0x00
#define RPN_FINETUNE    0x01
#define RPN_COARSETUNE  0x02

/*  Sample format and Sample playback flags are organized
    together because together they determine which 
    mix loop to use.
*/
#define SFORMAT_16              1       // Sixteen bit sample.
#define SFORMAT_8               2       // Eight bit sample.
#define SPLAY_MMX               0x10    // Use MMX processor (16 bit only).
#define SPLAY_STEREO            0x40    // Stereo output.


/*  For internal representation, volume is stored in Volume Cents, 
    where each increment represents 1/100 of a dB.
    Pitch is stored in Pitch Cents, where each increment
    represents 1/100 of a semitone.
*/ 
typedef long    PREL;   // Pitch cents, for relative pitch.
typedef short   PRELS;  // Pitch cents, in storage form.
typedef long    VREL;   // Volume cents, for relative volume.
typedef short   VRELS;  // Volume cents, in storage form.
typedef long    TREL;   // Time cents, for relative time
typedef short   TRELS;  // Time Cents, in storage form.
typedef LONGLONG STIME; // Time value, in samples.
typedef long    MTIME;  // Time value, in milliseconds.
typedef long    PFRACT; // Pitch increment, where upper 20 bits are
                        // the index and the lower 12 are the fractional
                        // component.
typedef long    VFRACT; // Volume, where lower 12 bits are the fraction.

typedef long    TCENT;
typedef short   SPERCENT;

#define MIN_VOLUME      -9600   // Below 96 db down is considered off.
#define PERCEIVED_MIN_VOLUME   -8000   // But, we cheat.
#define SAMPLE_RATE_22  22050   // 22 kHz is the standard rate.
#define SAMPLE_RATE_44  44100   // 44 kHz is the high quality rate.
#define SAMPLE_RATE_11  11025   // 11 kHz should not be allowed!
#define STEREO_ON       1
#define STEREO_OFF      0

#define FORCEBOUNDS(data,min,max) {if (data < min) data = min; else if (data > max) data = max;}

class Collection;
class CControlLogic;
class CInstManager;
class CSynth;

/*****************************************************************************
 * class CSourceLFO
 *****************************************************************************
 * CSourceLFO is the file format definition of the LFO in an
 * instrument. This is used to represent an LFO as part of
 * a specific articulation set within an instrument that
 * has been loaded from disk. Once the instrument is chosen
 * to play a note, this is also copied into the CVoice
 * object.
 */
class CSourceLFO
{
public:
                CSourceLFO();
    void        Init(DWORD dwSampleRate);
    void        SetSampleRate(long lDirection);
    void        Verify();           // Verifies that the data is valid.
    
    PFRACT      m_pfFrequency;      // Frequency, in increments through the sine table.
    STIME       m_stDelay;          // How long to delay in sample units.
    VRELS       m_vrMWVolumeScale;  // Scaling of volume LFO by Mod Wheel.
    PRELS       m_prMWPitchScale;   // Scaling of pitch LFO by Mod Wheel.
    VRELS       m_vrVolumeScale;    // Scaling of straight volume signal from LFO.
    PRELS       m_prPitchScale;     // Scaling of straight pitch signal from LFO.

};

/*****************************************************************************
 * class CSourceEG
 *****************************************************************************
 * CSourceEG is the file format definition of an Envelope
 * generator in an instrument.
 */
class CSourceEG
{
public:
                CSourceEG();
    void        SetSampleRate(long lDirection);
    void        Init();
    void        Verify();           // Verifies valid data.
    
    STIME       m_stAttack;         // Attack rate.
    STIME       m_stDecay;          // Decay rate.
    STIME       m_stRelease;        // Release rate.
    TRELS       m_trVelAttackScale; // Scaling of attack by note velocity.
    TRELS       m_trKeyDecayScale;  // Scaling of decay by note value.
    SPERCENT    m_pcSustain;        // Sustain level.
    short       m_sScale;           // Scaling of entire signal.
};

/*****************************************************************************
 * class CSourceArticulation
 *****************************************************************************
 * CSourceArticulation is the file format definition of
 * a complete articulation set: the LFO and two
 * envelope generators.
 *
 * Since several regions within one Instrument can 
 * share one articulation, a counter is used to keep
 * track of the usage.
 */
class CSourceArticulation
{
public:
                CSourceArticulation();
    HRESULT     Download( DMUS_DOWNLOADINFO * pInfo, 
                          void * pvOffsetTable[],   DWORD dwIndex, 
                          DWORD dwSampleRate,       BOOL fNewFormat);
    void        Init(DWORD dwSampleRate);
    void        Verify();           // Verifies valid data.
    void        AddRef();
    void        Release();
    void        SetSampleRate(DWORD dwSampleRate);
    
    CSourceEG   m_PitchEG;          // Pitch envelope.
    CSourceEG   m_VolumeEG;         // Volume envelope.
    CSourceLFO  m_LFO;              // Low frequency oscillator.
    DWORD       m_dwSampleRate;
    WORD        m_wUsageCount;      // Keeps track of how many times in use.
    short       m_sDefaultPan;      // default pan (for drums)
};

/*****************************************************************************
 * class CWave
 *****************************************************************************
 * Since multiple regions may reference
 * the same Wave, a reference count is maintained to
 * keep track of how many regions are using the sample.
 */
class CWave : public CListItem
{
public:
                    CWave();
                    ~CWave();
    void            Verify();           // Verifies that the data is valid.
    void            Release();          // Remove reference.
    void            AddRef();           // Add reference.
    void            PlayOn();           // Increment play count.
    void            PlayOff();          // Decrement play count.
    BOOL            IsPlaying();        // Is currently playing?
    CWave *         GetNext()        {return(CWave *)CListItem::GetNext();};
    
    DWORD           m_dwSampleLength;   // Length of sample.
    DWORD           m_dwSampleRate;
    HRESULT ( CALLBACK *m_lpFreeHandle)(HANDLE,HANDLE);
    HANDLE          m_hUserData;        // Used to notify app when wave released.
    short *         m_pnWave;
    DWORD           m_dwID;             // ID for matching wave with regions.
    WORD            m_wUsageCount;      // Keeps track of how many times in use.
    WORD            m_wPlayCount;       // Wave is currently being played.
    BYTE            m_bSampleType;
    DMUS_DOWNLOADINFO * m_pWaveMem;
};

/*****************************************************************************
 * class CWavePool
 *****************************************************************************
 * implements a list of wave objects.
 */
class CWavePool : public CList
{
public:
    CWave *      GetHead()           {return (CWave *)CList::GetHead();};
    CWave *      GetItem(DWORD dwID) {return (CWave *)CList::GetItem((LONG)dwID);};
    CWave *      RemoveHead()        {return (CWave *)CList::RemoveHead();};
};


/*****************************************************************************
 * class CSourceSample
 *****************************************************************************
 * The CSourceSample class describes one sample in an
 * instrument. The sample is referenced by a CSourceRegion
 * structure. 
 */
class CSourceSample
{
public:
                CSourceSample();
                ~CSourceSample();
    BOOL        CopyFromWave();
    void        Verify();           // Verifies that the data is valid.
    
    CWave *     m_pWave;            // Wave in pool.
    DWORD       m_dwLoopStart;      // Index of start of loop.
    DWORD       m_dwLoopEnd;        // Index of end of loop.
    DWORD       m_dwSampleLength;   // Length of sample.
    DWORD       m_dwSampleRate;     // Sample rate of recording.
    PRELS       m_prFineTune;       // Fine tune to correct pitch.
    DWORD       m_dwID;             // Wave pool id.
    BYTE        m_bSampleType;      // 16 or 8.
    BYTE        m_bOneShot;         // Is this a one shot sample?
    BYTE        m_bMIDIRootKey;     // MIDI note number for sample.
};

/*****************************************************************************
 * class CSourceRegion
 *****************************************************************************
 * The CSourceRegion class defines a region within an instrument.
 * The sample is managed with a pointer instead of an embedded
 * sample. This allows multiple regions to use the same sample.
 *
 * Each region also has an associated articulation. For drums, there
 * is a one to one matching. For melodic instruments, all regions
 * share the same articulation. So, to manage this, each region
 * points to the articulation.
 */
class CSourceRegion : public CListItem
{
public:
                CSourceRegion();
                ~CSourceRegion();
    CSourceRegion *GetNext() 
        {return(CSourceRegion *)CListItem::GetNext();};

    void        Verify();                   // Verifies that the data is valid.
    void        SetSampleRate(DWORD dwSampleRate);
    HRESULT     Download( DMUS_DOWNLOADINFO * pInfo, void * pvOffsetTable[], 
                          DWORD *pdwRegionIX, DWORD dwSampleRate, BOOL fNewFormat);
    
    CSourceSample m_Sample;                 // Sample structure.
    CSourceArticulation * m_pArticulation;  // Pointer to associated articulation.
    VRELS       m_vrAttenuation;            // Volume change to apply to sample.
    PRELS       m_prTuning;                 // Pitch shift to apply to sample.
    BYTE        m_bAllowOverlap;            // Allow overlapping of note.
    BYTE        m_bKeyHigh;                 // Upper note value for region.
    BYTE        m_bKeyLow;                  // Lower note value.
    BYTE        m_bGroup;                   // Logical group (for drums.)
};


/*****************************************************************************
 * class CSourceRegionList
 *****************************************************************************
 * implements a list of CSourceRegion objects.
 */
class CSourceRegionList : public CList
{
public:
    CSourceRegion *GetHead()    {return (CSourceRegion *)CList::GetHead();};
    CSourceRegion *RemoveHead() {return (CSourceRegion *)CList::RemoveHead();};
};


/*****************************************************************************
 * class CInstrument
 *****************************************************************************
 * The CInstrument class is really the file format definition
 * of an instrument.
 *
 * The CInstrument can be either a Drum or a Melodic instrument.
 * If a drum, it has up to 128 pairings of articulations and
 * regions. If melodic, all regions share the same articulation.
 * ScanForRegion is called by ControlLogic to get the region
 * that corresponds to a note.
 */
class CInstrument : public CListItem
{
public:
                    CInstrument();
                    ~CInstrument();
    void            Init(DWORD dwSampleRate);
    void            Verify();               // Verifies that the data is valid.
    CInstrument *   GetInstrument(DWORD dwProgram,DWORD dwAccept);
    CInstrument *   GetNext() 
        {return(CInstrument *)CListItem::GetNext();};

    void            SetSampleRate(DWORD dwSampleRate);
    CSourceRegion * ScanForRegion(DWORD dwNoteValue);
    HRESULT         LoadRegions( BYTE *p, BYTE *pEnd, DWORD dwSampleRate);
    HRESULT         Load( BYTE *p, BYTE *pEnd, DWORD dwSampleRate);
    
    CSourceRegionList m_RegionList;         // Linked list of regions.
    DWORD             m_dwProgram;          // Which program change it represents.
};

/*****************************************************************************
 * class CInstrumentList
 *****************************************************************************
 * Implements a list of CInstrument objects.
 */
class CInstrumentList : public CList
{
public:
    CInstrument * GetHead()    {return (CInstrument *)CList::GetHead();};
    CInstrument * RemoveHead() {return (CInstrument *)CList::RemoveHead();};
};

#define WAVE_HASH_SIZE          31  // Keep waves in a hash table of linked lists to speed access.
#define INSTRUMENT_HASH_SIZE    31  // Same with instruments.

/*****************************************************************************
 * class CInstManager
 *****************************************************************************
 * Manages the instruments, including sample rates, downloads, and waves.
 * Utilizes a hash scheme for quick location of waves and instruments 
 * (they can become numerous).
 */
class CInstManager 
{
public:
                    CInstManager();
                    ~CInstManager();
    CInstrument *   GetInstrument(DWORD dwPatch,DWORD dwKey);
    void            Verify();           // Verifies that the data is valid.
    void            SetSampleRate(DWORD dwSampleRate);
    HRESULT         Download(LPHANDLE phDownload, 
                             void * pvData,
                             LPBOOL pbFree);
    HRESULT         Unload(HANDLE hDownload,
                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                           HANDLE hUserData);
private:
    HRESULT         DownloadInstrument(LPHANDLE phDownload, 
                                         DMUS_DOWNLOADINFO *pInfo, 
                                         void *pvOffsetTable[], 
                                         void *pvData,
                                         BOOL fNewFormat);
    HRESULT         DownloadWave(LPHANDLE phDownload,
                                DMUS_DOWNLOADINFO *pInfo, 
                                void *pvOffsetTable[], 
                                void *pvData);
    
    CInstrumentList m_InstrumentList[INSTRUMENT_HASH_SIZE];
    CWavePool       m_WavePool[WAVE_HASH_SIZE];
    CWavePool       m_FreeWavePool;     // Track waves still in use, but unloaded.
    DWORD           m_dwSampleRate;     // Sample rate requested by app.

public:
    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL            m_fCSInitialized;   
};

/*****************************************************************************
 * class CMIDIData
 *****************************************************************************
 * Represents a single MIDI event.
 */
class CMIDIData : public CListItem 
{
public:
                CMIDIData();
    CMIDIData *  GetNext()  {return (CMIDIData *)CListItem::GetNext();};
    
    STIME       m_stTime;   // Time this event was recorded.
    long        m_lData;    // Data stored in event.            
};

/*****************************************************************************
 * class CMIDIDataList
 *****************************************************************************
 * Implements a list of CMIDIData objects.
 */
class CMIDIDataList : public CList
{
public:
    CMIDIData *GetHead()    {return (CMIDIData *)CList::GetHead();};
    CMIDIData *RemoveHead() {return (CMIDIData *)CList::RemoveHead();};
};

#define MAX_MIDI_EVENTS     1000

/*****************************************************************************
 * class CMIDIRecorder
 *****************************************************************************
 * CMIDIRecorder is used to keep track of a time
 * slice of MIDI continuous controller events.
 * This is subclassed by the PitchBend, Volume, 
 * Expression, and ModWheel Recorder classes, so
 * each of them may reliably manage MIDI events
 * coming in.
 *
 * CMIDIRecorder uses a linked list of CMIDIData
 * structures to keep track of the changes within
 * the time slice.
 *
 * Allocation and freeing of the CMIDIData events 
 * is kept fast and efficient because they are
 * always pulled from the static pool m_pFreeList,
 * which is really a list of events pulled directly
 * from the static array m_sEventBuffer. This is
 * safe because we can make the assumption that
 * the maximum MIDI rate is 1000 events per second.
 * Since we are managing time slices of roughly
 * 1/16 of a second, a buffer of 100 events would
 * be overkill.
 *
 * Although CMIDIRecorder is subclassed to several 
 * different event types, they all share the one
 * static free list. 
 */
class CMIDIRecorder
{
public:
                CMIDIRecorder();
                ~CMIDIRecorder();        // Be sure to clear local list.
    void        Init();                  // Inits the free list.
    static void InitTables();
    BOOL        FlushMIDI(STIME stTime); // Clear after time stamp.
    BOOL        ClearMIDI(STIME stTime); // Clear up to time stamp.
    BOOL        RecordMIDI(STIME stTime, long lData); // MIDI input goes here.
    long        GetData(STIME stTime);   // Gets data at time.
    static VREL VelocityToVolume(WORD nVelocity);

    static CMIDIDataList * m_sFreeList;  // Free list of events.

protected:
    void        GrabSpinLock();
    void        ReleaseSpinLock();

    CMIDIDataList m_EventList;           // This recorder's list.
    STIME         m_stCurrentTime;       // Time for current value.
    long          m_lCurrentData;        // Current value.

private:
    KSPIN_LOCK    m_SpinLock;
    KIRQL         m_OldIrql;

};

/*****************************************************************************
 * class CNote
 *****************************************************************************
 * Represents a single note.  This can also represent fakes notes that 
 * represent special MIDI commands (Master Volume, etc).
 */
class CNote 
{
public:
    STIME       m_stTime;
    BYTE        m_bPart;
    BYTE        m_bKey;
    BYTE        m_bVelocity;
};


/*****************************************************************************
 * Fake note values held in CNoteIn's queue to indicate changes in the 
 * sustain pedal and "all notes off".
 *
 * This is a grab bag for synchronous events that should be queued in time, 
 * not simply done as soon as received.
 *
 * By putting them in the note queue, we ensure they are evaluated in the 
 * exact same order as the notes themselves.
 *****************************************************************************/
const BYTE NOTE_PROGRAMCHANGE   = 0xF1;
const BYTE NOTE_CC_BANKSELECTH  = 0xF2;
const BYTE NOTE_CC_BANKSELECTL  = 0xF3;
const BYTE NOTE_CC_POLYMODE     = 0xF4;
const BYTE NOTE_CC_MONOMODE     = 0xF5;
const BYTE NOTE_CC_RPN_MSB      = 0xF6;
const BYTE NOTE_CC_RPN_LSB      = 0xF7;
const BYTE NOTE_CC_NRPN         = 0xF8;
const BYTE NOTE_CC_DATAENTRYLSB = 0xF9;
const BYTE NOTE_CC_DATAENTRYMSB = 0xFA;
const BYTE NOTE_ASSIGNRECEIVE   = 0xFB;
const BYTE NOTE_MASTERVOLUME    = 0xFC;
const BYTE NOTE_SOUNDSOFF       = 0xFD;
const BYTE NOTE_SUSTAIN         = 0xFE;
const BYTE NOTE_ALLOFF          = 0xFF;

/*****************************************************************************
 * class CNoteIn
 *****************************************************************************
 * Implements a note receptor.  This is used by CControlLogic to queue notes.
 */
class CNoteIn : public CMIDIRecorder
{
public:
    void        FlushMIDI(STIME stTime);
    void        FlushPart(STIME stTime, BYTE bChannel);
    BOOL        RecordNote(STIME stTime, CNote * pNote);
    BOOL        RecordEvent(STIME stTime, DWORD dwPart, DWORD dwCommand, BYTE bData);
    BOOL        GetNote(STIME stTime, CNote * pNote); // Gets the next note.
}; 

/*****************************************************************************
 * class CModWheelIn
 *****************************************************************************
 * CModWheelIn handles one channel of Mod Wheel
 * input. As such, it is not embedded in the CVoice
 * class, rather it is in the Channel class.
 * CModWheelIn's task is simple: keep track of MIDI
 * Mod Wheel events, each tagged with millisecond
 * time and value, and return the value for a specific
 * time request.
 *
 * CModWheelIn inherits almost all of its functionality
 * from the CMIDIRecorder Class.
 * CModWheelIn receives MIDI mod wheel events through
 * the RecordMIDI() command, which stores the 
 * time and value of the event. 
 *
 * CModWheelIn is called by CVoiceLFO to get the 
 * current values for the mod wheel to set the amount
 * of LFO modulation for pitch and volume.
 */
class CModWheelIn : public CMIDIRecorder
{
public:
    DWORD       GetModulation(STIME stTime);    // Gets the current Mod Wheel value.
};       

/*****************************************************************************
 * class CPitchBendIn
 *****************************************************************************
 * CPitchBendIn handles one channel of Pitch Bend
 * input. Like the Mod Wheel module, it inherits
 * its abilities from the CMIDIRecorder class.
 *
 * It has one additional routine, GetPitch(),
 * which returns the current pitch bend value.
 */
class CPitchBendIn : public CMIDIRecorder
{
public:
                CPitchBendIn();
    PREL        GetPitch(STIME stTime); // Gets the current pitch in pitch cents.

    // current pitch bend range.  Note that this is not timestamped!
    PREL        m_prRange;              
};              

/*****************************************************************************
 * class CVolumeIn
 *****************************************************************************
 * CVolumeIn handles one channel of Volume
 * input. It inherits its abilities from 
 * the CMIDIRecorder class.
 *
 * It has one additional routine, GetVolume(),
 * which returns the volume in decibels at the
 * specified time.
 */
class CVolumeIn : public CMIDIRecorder
{
public:
                CVolumeIn();
    VREL        GetVolume(STIME stTime);    // Gets the current volume in db cents.
};

/*****************************************************************************
 * class CExpressionIn
 *****************************************************************************
 * CExpressionIn handles one channel of Expression
 * input. It inherits its abilities from 
 * the CMIDIRecorder class.
 *
 * It has one additional routine, GetVolume(),
 * which returns the volume in decibels at the
 * specified time.
 */
class CExpressionIn : public CMIDIRecorder
{
public:
                CExpressionIn();
    VREL        GetVolume(STIME stTime);    // Gets the current volume in db cents.
};

/*****************************************************************************
 * class CPanIn
 *****************************************************************************
 * CPanIn handles one channel of Volume
 * input. It inherits its abilities from 
 * the CMIDIRecorder class.
 *
 * It has one additional routine, GetPan(),
 * which returns the pan position (MIDI value)
 * at the specified time.
 */
class CPanIn : public CMIDIRecorder
{
public:
                CPanIn();
    long        GetPan(STIME stTime);       // Gets the current pan.
};

/*****************************************************************************
 * class CVoiceLFO
 *****************************************************************************
 * The CVoiceLFO class is used to track the behavior
 * of an LFO within a voice. The LFO is hard wired to 
 * output both volume and pitch values, through separate
 * calls to GetVolume and GetPitch.
 *
 * It also manages mixing Mod Wheel control of pitch and
 * volume LFO output. It tracks the scaling of Mod Wheel
 * for each of these in m_nMWVolumeScale and m_nMWPitchScale.
 * It calls the Mod Wheel module to get the current values 
 * if the respective scalings are greater than 0.
 *
 * All of the preset values for the LFO are carried in
 * the m_CSource field, which is a replica of the file
 * CSourceLFO structure. This is initialized with the
 * StartVoice call.
 */
class CVoiceLFO 
{
public:
                CVoiceLFO();
    STIME       StartVoice(CSourceLFO *pSource, 
                           STIME stStartTime,CModWheelIn * pModWheelIn);
    VREL        GetVolume( STIME stTime, STIME *pstTime);   // Returns volume cents.
    PREL        GetPitch(  STIME stTime, STIME *pstTime);   // Returns pitch cents.
private:
    long        GetLevel(  STIME stTime, STIME *pstTime);
    
    CSourceLFO   m_Source;              // All of the preset information.
    STIME        m_stStartTime;         // Time the voice started playing.
    CModWheelIn  *m_pModWheelIn;        // Pointer to Mod Wheel for this channel.
    STIME        m_stRepeatTime;        // Repeat time for LFO.
};


/*****************************************************************************
 * class CVoiceEG
 *****************************************************************************
 * The CVoiceEG class is used to track the behavior of
 * an Envelope Generator within a voice. There are two 
 * EG's, one for pitch and one for volume. However, they
 * behave identically.
 *
 * All of the preset values for the EG are carried in
 * the m_Source field, which is a replica of the file
 * CSourceEG structure. This is initialized with the
 * StartVoice call.
 */
class CVoiceEG
{
public:
                CVoiceEG();
    STIME       StartVoice(CSourceEG *pSource, STIME stStartTime, 
                           WORD nKey, WORD nVelocity);
    void        StopVoice(STIME stTime);
    void        QuickStopVoice(STIME stTime, DWORD dwSampleRate);
    VREL        GetVolume(STIME stTime, STIME *pstTime);    // Returns volume cents.
    PREL        GetPitch(STIME stTime, STIME *pstTime);     // Returns pitch cents.
    BOOL        InAttack(STIME stTime);     // is voice still in attack?
    BOOL        InRelease(STIME stTime);    // is voice in release?
private:
    long        GetLevel(STIME stTime, STIME *pstTime, BOOL fVolume);

    CSourceEG    m_Source;           // Preset values for envelope, copied from file.
    STIME        m_stStartTime;      // Time note turned on
    STIME        m_stStopTime;       // Time note turned off
};

/*****************************************************************************
 * class CDigitalAudio
 *****************************************************************************
 * The CDigitalAudio class is used to track the playback
 * of a sample within a voice.
 *
 * It manages the loop points, the pointer to the sample.
 * and the base pitch and base volume, which it initially sets 
 * when called via StartVoice(). 
 *
 * Pitch is stored in a fixed point format, where the leftmost
 * 20 bits define the sample increment and the right 12 bits
 * define the factional increment within the sample. This 
 * format is also used to track the position in the sample.
 * Mix is a critical routine. It is called by the CVoice to blend
 * the instrument into the data buffer. It is handed relative change
 * values for pitch and volume (semitone cents and decibel
 * cents.) These it converts into three linear values:
 * Left volume, Right volume, and Pitch.
 *
 * It then compares these new values with the values that existed 
 * for the previous slice and divides by the number of samples to 
 * determine an incremental change at the sample rate. 
 * Then, in the critical mix loop, these are added to the 
 * volume and pitch indices to give a smooth linear slope to the
 * change in volume and pitch.
 */

#define MAX_SAMPLE  4095
#define MIN_SAMPLE  (-4096)

#define MAXDB           0
#define MINDB           -100
#define TEST_WRITE_SIZE     3000
#define TEST_SOURCE_SIZE    44100

class CDigitalAudio
{
public:
                CDigitalAudio();
    STIME       StartVoice(CSynth *pSynth,
                    CSourceSample *pSample,
                    VREL vrBaseLVolume, VREL vrBaseRVolume,
                    PREL prBasePitch, long lKey);
    BOOL        Mix(short *pBuffer,DWORD dwLength,
                    VREL dwVolumeL, VREL dwVolumeR, PREL dwPitch,
                    DWORD dwStereo);
    void        ClearVoice();
    static PFRACT PRELToPFRACT(PREL prPitch); // Pitch cents to pitch.

private:
    DWORD       Mix8(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMono8(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       Mix16(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMono16(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD _cdecl Mix8X(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
                     VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                     PFRACT pfDeltaPitch, 
                     PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD _cdecl Mix16X(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
                     VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                     PFRACT pfDeltaPitch, 
                     PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMono16X(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMono8X(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume, 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    void        BeforeBigSampleMix();
    void        AfterBigSampleMix();
    static VFRACT VRELToVFRACT(VREL vrVolume); // dB to absolute.
    
    CSourceSample   m_Source;           // Preset values for sample.
    CSynth *        m_pSynth;           // For access to sample rate, etc.

    BOOL            m_fMMXEnabled;

    short *         m_pnWave;           // Private pointer to wave.
    VREL            m_vrBaseLVolume;    // Overall left volume.
    VREL            m_vrBaseRVolume;    // Overall left volume.
    PFRACT          m_pfBasePitch;      // Overall pitch.
    VFRACT          m_vfLastLVolume;    // The last left volume value.
    VFRACT          m_vfLastRVolume;    // The last right volume value.
    PFRACT          m_pfLastPitch;      // The last pitch value.
    VREL            m_vrLastLVolume;    // The last left volume value, in VREL.
    VREL            m_vrLastRVolume;    // Same for right.
    PREL            m_prLastPitch;      // Same for pitch, in PREL.
    PFRACT          m_pfLastSample;     // The last sample position.
    PFRACT          m_pfLoopStart;      // Start of loop.
    PFRACT          m_pfLoopEnd;        // End of loop.
    PFRACT          m_pfSampleLength;   // Length of sample buffer.
    BOOL            m_fElGrande;        // Indicates larger than 1m wave.
    ULONGLONG       m_ullLastSample;    // Used to track > 1m wave.
    ULONGLONG       m_ullLoopStart;     // Used to track > 1m wave.
    ULONGLONG       m_ullLoopEnd;       // Used to track > 1m wave.
    ULONGLONG       m_ullSampleLength;  // Used to track > 1m wave.
    DWORD           m_dwAddressUpper;   // Temp storage for upper bits of address.
};

/*****************************************************************************
 * class CVoice
 *****************************************************************************
 * The CVoice class pulls together everything needed to perform
 * one voice. It has the envelopes, lfo, and sample embedded
 * within it. 
 *
 * StartVoice() initializes a voice structure for playback. The
 * CSourceRegion structure carries the region and sample as well
 * as a pointer to the articulation, which is used to set up
 * the various articulation modules. It also carries pointers to 
 * all the MIDI modulation inputs and the values for the note key
 * and channel which are used by the parent ControlLogic object
 * to match incoming note off events with the right voice. 
 */
class CVoice : public CListItem
{
public:
                CVoice();
    CVoice *    GetNext() 
        {return (CVoice *)CListItem::GetNext();};

    BOOL        StartVoice(CSynth *pControl,
                           CSourceRegion *pRegion, STIME stStartTime,
                           CModWheelIn * pModWheelIn, 
                           CPitchBendIn * pPitchBendIn,
                           CExpressionIn * pExpressionIn,
                           CVolumeIn * pVolumeIn,
                           CPanIn * pPanIn,
                           WORD nKey,WORD nVelocity,
                           VREL vrVolume,      // Added for GS
                           PREL prPitch);      // Added for GS

    void        StopVoice(STIME stTime);        // Called on note off event.
    void        QuickStopVoice(STIME stTime);   // Called to get quick release.
    void        SpeedRelease();             // Force an already off envelope to release quickly.
    void        ClearVoice();               // Release use of sample.
    PREL        GetNewPitch(STIME stTime);  // Return current pitch value
    void        GetNewVolume(STIME stTime, VREL& vrVolume, VREL &vrVolumeR);
                                            // Return current volume value
    DWORD       Mix(short *pBuffer,DWORD dwLength,STIME stStart,STIME stEnd);

private:
    CVoiceLFO       m_LFO;              // LFO.
    CVoiceEG        m_PitchEG;          // Pitch Envelope.
    CVoiceEG        m_VolumeEG;         // Volume Envelope.
    CDigitalAudio   m_DigitalAudio;     // The Digital Audio Engine structure.
    CPitchBendIn *  m_pPitchBendIn;     // Pitch bend source.
    CExpressionIn * m_pExpressionIn;    // Expression source.
    CVolumeIn *     m_pVolumeIn;        // Volume source, if allowed to vary
    CPanIn *        m_pPanIn;           // Pan source, if allowed to vary
    CSynth *        m_pSynth;           // To access sample rate, etc.
    STIME           m_stMixTime;        // Next time we need a mix.
    long            m_lDefaultPan;      // Default pan
    STIME           m_stLastMix;        // Last sample position mixed.

public:
    STIME           m_stStartTime;      // Time the sound starts.
    STIME           m_stStopTime;       // Time the sound stops.
    BOOL            m_fInUse;           // This is currently in use.
    BOOL            m_fNoteOn;          // Note is considered on.
    BOOL            m_fTag;             // Used to track note stealing.
    VREL            m_vrVolume;         // Volume, used for voice stealing...
    BOOL            m_fSustainOn;       // Sus pedal kept note on after off event.
    WORD            m_nPart;            // Part that is playing this (channel).
    WORD            m_nKey;             // Note played.
    BOOL            m_fAllowOverlap;    // Allow overlapped note.
    DWORD           m_dwGroup;          // Group this voice is playing now
    DWORD           m_dwProgram;        // Bank and Patch choice.
    DWORD           m_dwPriority;       // Priority.
    CControlLogic * m_pControl;         // Which control group is playing voice.
};


/*****************************************************************************
 * class CVoiceList
 *****************************************************************************
 * Implements a list of CVoice objects.
 */
class CVoiceList : public CList
{
public:
    CVoice *     GetHead()            {return (CVoice *) CList::GetHead();};
    CVoice *     RemoveHead()         {return (CVoice *) CList::RemoveHead();};
    CVoice *     GetItem(LONG lIndex) {return (CVoice *) CList::GetItem(lIndex);};
};

/*****************************************************************************
 * struct PerfStats
 *****************************************************************************
 * Contains statistics on the synthesizer, updated continuously.
 */
typedef struct PerfStats
{
    DWORD dwTotalTime;
    DWORD dwTotalSamples;
    DWORD dwNotesLost;
    DWORD dwVoices;
    DWORD dwCPU;
    DWORD dwMaxAmplitude;
} PerfStats;

#define MIX_BUFFER_LEN      500     // Set the sample buffer size to 500 mils
#define MAX_NUM_VOICES      32
#define NUM_EXTRA_VOICES    8       // Extra voices for when we overload.


/*****************************************************************************
 * class CControlLogic
 *****************************************************************************
 * CControlLogic object, implementing the control logic for the DLS 
 * instrument.  This handles MIDI events, plus selection of instrument, sample
 * and articulation.
 *
 *
 * Essentially, ControlLogic is the big Kahuna that manages 
 * the whole system. It parses incoming MIDI events
 * by channel and event type. And, it manages the mixing
 * of voices into the buffer.
 *
 * MIDI Input:
 *
 * The most important events are the note on and
 * off events. When a note on event comes in, 
 * ControlLogic searches for an available voice.
 * ControlLogic matches the channel and finds the
 * instrument on that channel. It then call the instrument's
 * ScanForRegion() command which finds the region 
 * that matches the note. At this point, it can copy
 * the region and associated articulation into the
 * voice, using the StartVoice command.
 *
 * When it receives the sustain pedal command,
 * it artificially sets all notes on the channel on
 * until a sustain off arrives. To keep track of notes
 * that have been shut off while the sustain was on
 * it uses an array of 128 shorts, with each bit position 
 * representing a channel. When the sustain releases,
 * it scans through the array and creates a note off for
 * each bit that was set.
 *
 * Additional continuous controller events are managed
 * by the CModWheelIn, CPitchBendIn, etc., MIDI input recording
 * modules.
 *
 * Mixing:
 *
 * Control Logic is also called to mix the instruments into a buffer
 * at regular intervals. The buffer is provided by the calling sound 
 * driver. Each voice is called to mix its sample into the buffer.
 */
class CControlLogic
{
public:
                    CControlLogic();
                    ~CControlLogic();
    HRESULT         Init(CInstManager *pInstruments, CSynth *pSynth);
    void            Flush(STIME stTime); // Clears all events after time.
    BOOL            RecordMIDI(STIME stTime,BYTE bStatus, BYTE bData1, BYTE bData2);
    HRESULT         RecordSysEx(DWORD dwSysExLength,BYTE *pSysExData, STIME stTime);
    void            QueueNotes(STIME stEndTime);
    void            ClearMIDI(STIME stEndTime);
    void            SetGainAdjust(VREL vrGainAdjust);
    HRESULT         SetChannelPriority(DWORD dwChannel,DWORD dwPriority);
    HRESULT         GetChannelPriority(DWORD dwChannel,LPDWORD pdwPriority);

    CSynth *        m_pSynth;
    
private:
    void            GMReset();

    CInstManager *  m_pInstruments;
    CNoteIn         m_Notes;              // All Note ons and offs.
    CModWheelIn     m_ModWheel[16];       // Sixteen channels of Mod Wheel.
    CPitchBendIn    m_PitchBend[16];      // Sixteen channels of Pitch Bend.
    CVolumeIn       m_Volume[16];         // Sixteen channels of Volume.
    CExpressionIn   m_Expression[16];     // Sixteen channels of Expression.
    CPanIn          m_Pan[16];            // Sixteen channels of Pan.
    BOOL            m_fSustain[16];       // Sustain on / off.
    short           m_nCurrentRPN[16];    // RPN number.
    BYTE            m_bBankH[16];         // Bank selects for instrument.
    BYTE            m_bBankL[16];     
    DWORD           m_dwProgram[16];      // Instrument choice.
    BOOL            m_fEmpty;             // Indicates empty lists, no need to flush.
    VREL            m_vrGainAdjust;       // Final stage gain adjust
    DWORD           m_dwPriority[16];     // Priorities for each channel.
    
    BOOL            m_fXGActive;          // Is XG Active?
    BOOL            m_fGSActive;          // Is GS enabled?
    WORD            m_nData[16];          // Used to track RPN reading.
    VREL            m_vrMasterVolume;     // Master Volume.
    PREL            m_prFineTune[16];     // Fine tune for each channel.
    PREL            m_prScaleTune[16][12];// Alternate scale for each channel.
    PREL            m_prCoarseTune[16];   // Coarse tune.
    BYTE            m_bPartToChannel[16]; // Channel to Part converter.
    BYTE            m_bDrums[16];         // Melodic or which drum?
    BOOL            m_fMono[16];          // Mono mode?

public:
    CRITICAL_SECTION m_CriticalSection;   // Critical section to manage access.
    BOOL            m_fCSInitialized;   
};

#endif // __SYNTH_H__


=== ddksynth/syslink.cpp ===
//
// syslink.cpp
//
/*
  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
*/

#include "common.h"
#include "private.h"

#define STR_MODULENAME "DDKSynth.sys:SysLink: "


/*****************************************************************************
 *****************************************************************************
 * CDmSynthStream-- ISynthSinkDMus implementation
 *****************************************************************************
 ****************************************************************************/


#pragma code_seg()
/*****************************************************************************
 * CDmSynthStream::Render()
 *****************************************************************************
 * Render is called from the port driver, to fill the given buffer.  This is 
 * in turn forwarded to the synth (which -- roughly -- goes to the different 
 * voices, which goes to the DigitalAudios, which goes to the mix functions).
 *
 * Typically, a synthesizer manages converting messages into
 * rendered wave data in two processes. First, it time stamps the MIDI 
 * messages it receives from the application via calls to 
 * PlayBuffer and places them in its own internal queue. 
 * 
 * Then, in response to Render, it generates audio by pulling MIDI 
 * messages from the queue and synthesizing the appropriate tones within
 * the time span of the requested render buffer.
 * 
 * As the synthesizer renders the MIDI messages into the buffer, it
 * calls RefTimeToSample to translate the MIDI time stamps into sample 
 * positions. This guarantees extremely accurate timing.
 */
void CDmSynthStream::Render(
                            IN  PBYTE       pBuffer,
                            IN  DWORD       dwLength,
                            IN  LONGLONG    llPosition)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::Render"));
    ASSERT(pBuffer);

    m_pSynth->Mix((short*)pBuffer, dwLength, llPosition);

    m_llLastPosition = llPosition + dwLength;
}


/*****************************************************************************
 * CDmSynthStream::SyncToMaster()
 *****************************************************************************
 * Sync this stream to the master clock, using the given slave time, and
 * whether we are starting now.
 */
STDMETHODIMP 
CDmSynthStream::SyncToMaster(IN REFERENCE_TIME  rtSlaveTime,
                             IN BOOL            fStart)
{
    PAGED_CODE();

	_DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::SyncToMaster"));

    REFERENCE_TIME rtMasterTime;
	m_pMasterClock->GetTime(&rtMasterTime);

    if (!fStart)
    {
        m_SampleClock.SyncToMaster(rtSlaveTime, rtMasterTime);
    }
    else
    {
        m_llStartPosition = ((rtSlaveTime / 1000) * m_PortParams.SampleRate) / 10000;

        m_SampleClock.Start(m_pMasterClock, m_PortParams.SampleRate, m_llStartPosition);
    }


    return S_OK;
}

/*****************************************************************************
 * CDmSynthStream::SampleToRefTime()
 *****************************************************************************
 * Translate between sample time and reference clock time.
 */
STDMETHODIMP
CDmSynthStream::SampleToRefTime(IN  LONGLONG         llSampleTime,
                                OUT REFERENCE_TIME * prtTime)
{
	_DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::SampleToRefTime"));
    ASSERT(prtTime);

    m_SampleClock.SampleToRefTime(llSampleTime + m_llStartPosition, prtTime);

    return S_OK;
}


/*****************************************************************************
 * CDmSynthStream::RefTimeToSample()
 *****************************************************************************
 * Translate between sample time and reference clock time.
 */
STDMETHODIMP
CDmSynthStream::RefTimeToSample(IN  REFERENCE_TIME  rtTime,
                                OUT LONGLONG *      pllSampleTime)
{
	_DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::RefTimeToSample"));
    ASSERT(pllSampleTime);

    *pllSampleTime = m_SampleClock.RefTimeToSample(rtTime) - m_llStartPosition;
  
    return S_OK;
}


=== ddksynth/voice.cpp ===
//  Voice.cpp
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//

#include "common.h"
#include <math.h>
#include "muldiv32.h"

#define STR_MODULENAME "DDKSynth.sys:Voice: "


#ifdef _X86_
#define MMX_ENABLED 1
#endif

#pragma code_seg()
/*****************************************************************************
 * CVoiceLFO::CVoiceLFO()
 *****************************************************************************
 * Constructor for the low-frequency oscillator object.
 */
CVoiceLFO::CVoiceLFO()
{
    m_pModWheelIn = NULL;
}

/*****************************************************************************
 * snSineTable[]
 *****************************************************************************
 * Table of 16-bit integers, representing a sine wave.
 * value = sin((index*6.283185307)/256) * 100 where index = 0..255
 */
const CHAR snSineTable[] = {
//  0       1       2       3       4       5       6       7
    0,      2,      4,      7,      9,      12,     14,     17,
    19,     21,     24,     26,     29,     31,     33,     35,
    38,     40,     42,     44,     47,     49,     51,     53,
    55,     57,     59,     61,     63,     65,     67,     68,
    70,     72,     74,     75,     77,     78,     80,     81,
    83,     84,     85,     87,     88,     89,     90,     91,
    92,     93,     94,     94,     95,     96,     97,     97,
    98,     98,     98,     99,     99,     99,     99,     99,
    100,    99,     99,     99,     99,     99,     98,     98,
    98,     97,     97,     96,     95,     94,     94,     93,
    92,     91,     90,     89,     88,     87,     85,     84,
    83,     81,     80,     78,     77,     75,     74,     72,
    70,     68,     67,     65,     63,     61,     59,     57,
    55,     53,     51,     49,     47,     44,     42,     40,
    38,     35,     33,     31,     29,     26,     24,     21,
    19,     17,     14,     12,     9,      7,      4,      2,
    0,      -2,     -4,     -7,     -9,     -12,    -14,    -17,
    -19,    -21,    -24,    -26,    -29,    -31,    -33,    -35,
    -38,    -40,    -42,    -44,    -47,    -49,    -51,    -53,
    -55,    -57,    -59,    -61,    -63,    -65,    -67,    -68,
    -70,    -72,    -74,    -75,    -77,    -78,    -80,    -81,
    -83,    -84,    -85,    -87,    -88,    -89,    -90,    -91,
    -92,    -93,    -94,    -94,    -95,    -96,    -97,    -97,
    -98,    -98,    -98,    -99,    -99,    -99,    -99,    -99,
    -100,   -99,    -99,    -99,    -99,    -99,    -98,    -98,
    -98,    -97,    -97,    -96,    -95,    -94,    -94,    -93,
    -92,    -91,    -90,    -89,    -88,    -87,    -85,    -84,
    -83,    -81,    -80,    -78,    -77,    -75,    -74,    -72,
    -70,    -68,    -67,    -65,    -63,    -61,    -59,    -57,
    -55,    -53,    -51,    -49,    -47,    -44,    -42,    -40,
    -38,    -35,    -33,    -31,    -29,    -26,    -24,    -21,
    -19,    -17,    -14,    -12,    -9,     -7,     -4,     -2
};

/*****************************************************************************
 * CVoiceLFO::StartVoice()
 *****************************************************************************
 * Start a voice with this LFO.  Attach the given ModWheel receptor.
 */
STIME CVoiceLFO::StartVoice(CSourceLFO *pSource,STIME stStartTime,
                            CModWheelIn * pModWheelIn)
{
    m_pModWheelIn = pModWheelIn;
    m_Source = *pSource;
    m_stStartTime = stStartTime;
    if ((m_Source.m_prMWPitchScale == 0) && (m_Source.m_vrMWVolumeScale == 0) &&
        (m_Source.m_prPitchScale == 0) && (m_Source.m_vrVolumeScale == 0))
    {
        m_stRepeatTime = 44100;
    }
    else
    {
        m_stRepeatTime = 2097152 / m_Source.m_pfFrequency; // (1/8 * 256 * 4096 * 16)
    }
    return (m_stRepeatTime);
}

/*****************************************************************************
 * CVoiceLFO::GetLevel()
 *****************************************************************************
 * Return the value of the LFO right now.
 */
long CVoiceLFO::GetLevel(STIME stTime, STIME *pstNextTime)
{
    stTime -= (m_stStartTime + m_Source.m_stDelay);
    if (stTime < 0) 
    {
        *pstNextTime = -stTime;
        return (0);
    }
    *pstNextTime = m_stRepeatTime;
    stTime *= m_Source.m_pfFrequency;
    stTime = stTime >> (12 + 4); // We've added 4 extra bits of resolution...
    return (::snSineTable[stTime & 0xFF]);
}

/*****************************************************************************
 * CVoiceLFO::GetVolume()
 *****************************************************************************
 * Get the composite volume of the LFO.
 */
VREL CVoiceLFO::GetVolume(STIME stTime, STIME *pstNextTime)
{
    VREL vrVolume = m_pModWheelIn->GetModulation(stTime);
    vrVolume *= m_Source.m_vrMWVolumeScale;
    vrVolume /= 127;
    vrVolume += m_Source.m_vrVolumeScale;
    vrVolume *= GetLevel(stTime,pstNextTime);
    vrVolume /= 100;
    return (vrVolume);
}

/*****************************************************************************
 * CVoiceLFO::GetPitch()
 *****************************************************************************
 * Get the composite pitch of the LFO.
 */
PREL CVoiceLFO::GetPitch(STIME stTime, STIME *pstNextTime)
{
    PREL prPitch = m_pModWheelIn->GetModulation(stTime);
    prPitch *= m_Source.m_prMWPitchScale;
    prPitch /= 127;
    prPitch += m_Source.m_prPitchScale;
    prPitch *= GetLevel(stTime,pstNextTime);
    prPitch /= 100;
    return (prPitch);
}

/*****************************************************************************
 * CVoiceEG::CVoiceEG()
 *****************************************************************************
 * Constructor for the CVoiceEG object.
 */
CVoiceEG::CVoiceEG()
{
    m_stStopTime = 0;
}

/*****************************************************************************
 * snAttackTable[]
 *****************************************************************************
 * Table of 16-bit integers, representing a log attack curve.
 * value = (log10((index/200)^2)) * 10000 / 96 + 1000 where index = 0..199
 */
const short snAttackTable[] = {
//  0       1       2       3       4       5       6       7
    0,      520,    583,    620,    646,    666,    682,    696,
    708,    719,    728,    737,    745,    752,    759,    765,
    771,    776,    782,    787,    791,    796,    800,    804,
    808,    811,    815,    818,    822,    825,    828,    831,
    834,    836,    839,    842,    844,    847,    849,    852,
    854,    856,    858,    860,    863,    865,    867,    868,
    870,    872,    874,    876,    878,    879,    881,    883,
    884,    886,    887,    889,    891,    892,    894,    895,
    896,    898,    899,    901,    902,    903,    905,    906,
    907,    908,    910,    911,    912,    913,    914,    915,
    917,    918,    919,    920,    921,    922,    923,    924,
    925,    926,    927,    928,    929,    930,    931,    932,
    933,    934,    935,    936,    937,    938,    939,    939,
    940,    941,    942,    943,    944,    945,    945,    946,
    947,    948,    949,    949,    950,    951,    952,    953,
    953,    954,    955,    956,    956,    957,    958,    958,
    959,    960,    961,    961,    962,    963,    963,    964,
    965,    965,    966,    967,    967,    968,    969,    969,
    970,    970,    971,    972,    972,    973,    973,    974,
    975,    975,    976,    976,    977,    978,    978,    979,
    979,    980,    980,    981,    982,    982,    983,    983,
    984,    984,    985,    985,    986,    986,    987,    987,
    988,    988,    989,    989,    990,    990,    991,    991,
    992,    992,    993,    993,    994,    994,    995,    995,
    996,    996,    997,    997,    998,    998,    999,    999,
    1000
};

/*****************************************************************************
 * CVoiceEG::StopVoice()
 *****************************************************************************
 * Stop the envelope generator.  Use a heuristic to hasten the cutoff, 
 * depending on the current level.
 */
void CVoiceEG::StopVoice(STIME stTime)
{
    m_Source.m_stRelease *= GetLevel(stTime,&m_stStopTime,TRUE);    // Adjust for current sustain level.
    m_Source.m_stRelease /= 1000;
    m_stStopTime = stTime;
}

/*****************************************************************************
 * CVoiceEG::QuickStopVoice()
 *****************************************************************************
 * Stop the envelope generator ASAP.
 */
void CVoiceEG::QuickStopVoice(STIME stTime, DWORD dwSampleRate)
{
    m_Source.m_stRelease *= GetLevel(stTime,&m_stStopTime,TRUE);    // Adjust for current sustain level.
    m_Source.m_stRelease /= 1000;
    dwSampleRate /= 70;
    if (m_Source.m_stRelease > (long) dwSampleRate)
    {
        m_Source.m_stRelease = dwSampleRate;
    }
    m_stStopTime = stTime;
}

/*****************************************************************************
 * CVoiceEG::StartVoice()
 *****************************************************************************
 * Start the voice with the given envelope generator and parameters.
 */
STIME CVoiceEG::StartVoice(CSourceEG *pSource, STIME stStartTime, 
                           WORD nKey, WORD nVelocity)
{
    m_stStartTime = stStartTime;
    m_stStopTime = 0x7fffffffffffffff;      // set to indefinite future
    m_Source = *pSource;

    // apply velocity to attack length scaling here
    m_Source.m_stAttack *= CDigitalAudio::PRELToPFRACT(nVelocity * m_Source.m_trVelAttackScale / 127);
    m_Source.m_stAttack /= 4096;

    m_Source.m_stDecay *= CDigitalAudio::PRELToPFRACT(nKey * m_Source.m_trKeyDecayScale / 127);
    m_Source.m_stDecay /= 4096;

    m_Source.m_stDecay *= (1000 - m_Source.m_pcSustain);
    m_Source.m_stDecay /= 1000;
    return ((STIME)m_Source.m_stAttack);
}

/*****************************************************************************
 * CVoiceEG::InAttack()
 *****************************************************************************
 * Are we in the attack phase still?
 */
BOOL CVoiceEG::InAttack(STIME st)
{
    // has note been released?
    if (st >= m_stStopTime)
        return FALSE;

    // past length of attack?
    if (st >= m_stStartTime + m_Source.m_stAttack)
        return FALSE;

    return TRUE;
}
    
/*****************************************************************************
 * CVoiceEG::InRelease()
 *****************************************************************************
 * Are we in the release phase yet?
 */
BOOL CVoiceEG::InRelease(STIME st)
{
    // has note been released?
    if (st > m_stStopTime)
        return TRUE;

    return FALSE;
}
    
/*****************************************************************************
 * CVoiceEG::GetLevel()
 *****************************************************************************
 * Get the envelope generator's current level, from 0 to 1000.
 */
long CVoiceEG::GetLevel(STIME stEnd, STIME *pstNext, BOOL fVolume)
{
    long lLevel = 0;
    if (stEnd <= m_stStopTime)
    {
        stEnd -= m_stStartTime;
        // note not released yet.
        if (stEnd < m_Source.m_stAttack)
        {
            // still in attack
            lLevel = 1000 * (long) stEnd;
            if (m_Source.m_stAttack)
            {
                lLevel /= (long) m_Source.m_stAttack;
            }
            else // This should never happen, but it does...
            {
                lLevel = 0;
            }
            *pstNext = m_Source.m_stAttack - stEnd;
            if (lLevel < 0) lLevel = 0;
            if (lLevel > 1000) lLevel = 1000;
            if (fVolume)
            {
                lLevel = ::snAttackTable[lLevel / 5];
            }
        }
        else 
        {
            stEnd -= m_Source.m_stAttack;
            
            if (stEnd < m_Source.m_stDecay)
            {
                // still in decay
                lLevel = (1000 - m_Source.m_pcSustain) * (long) stEnd;
                lLevel /= (long) m_Source.m_stDecay;
                lLevel = 1000 - lLevel;
// To improve the decay curve, set the next point to be 1/4, 1/2, or end of slope. 
// To avoid close duplicates, fudge an extra 100 samples.
                if (stEnd < ((m_Source.m_stDecay >> 2) - 100))
                {
                    *pstNext = (m_Source.m_stDecay >> 2) - stEnd;
                }   
                else if (stEnd < ((m_Source.m_stDecay >> 1) - 100))
                {
                    *pstNext = (m_Source.m_stDecay >> 1) - stEnd;
                }
                else
                {
                    *pstNext = m_Source.m_stDecay - stEnd;  // Next is end of decay.
                }
            }
            else
            {
                // in sustain
                lLevel = m_Source.m_pcSustain;
                *pstNext = 44100;
            }
        }
    }
    else
    {
        STIME stBogus;
        // in release
        stEnd -= m_stStopTime;

        if (stEnd < m_Source.m_stRelease)
        {
            lLevel = GetLevel(m_stStopTime,&stBogus,fVolume) * (long) (m_Source.m_stRelease - stEnd);
            lLevel /= (long) m_Source.m_stRelease;
            if (stEnd < ((m_Source.m_stRelease >> 2) - 100))
            {
                *pstNext = (m_Source.m_stRelease >> 2) - stEnd;
            }   
            else if (stEnd < ((m_Source.m_stRelease >> 1) - 100))
            {
                *pstNext = (m_Source.m_stRelease >> 1) - stEnd;
            }
            else
            {
                *pstNext = m_Source.m_stRelease - stEnd;  // Next is end of decay.
            }
        }
        else
        {
            lLevel = 0;   // !!! off
            *pstNext = 0x7FFFFFFFFFFFFFFF;
        }
    }

    return lLevel;
}

/*****************************************************************************
 * CVoiceEG::GetVolume()
 *****************************************************************************
 * Get the composite volume of the envelope generator in dB cents (1/100ths db).
 */
VREL CVoiceEG::GetVolume(STIME stTime, STIME *pstNextTime)
{
    VREL vrLevel = GetLevel(stTime, pstNextTime, TRUE) * 96;
    vrLevel /= 10;
    vrLevel = vrLevel - 9600;
    return vrLevel;
}

/*****************************************************************************
 * CVoiceEG::GetPitch()
 *****************************************************************************
 * Get the composite pitch of the envelope generator, in fractional scale units.
 */
PREL CVoiceEG::GetPitch(STIME stTime, STIME *pstNextTime)
{
    PREL prLevel;
    if (m_Source.m_sScale != 0)
    {
        prLevel = GetLevel(stTime, pstNextTime,FALSE);
        prLevel *= m_Source.m_sScale;
        prLevel /= 1000;
    }
    else
    {
        *pstNextTime = 44100;
        prLevel = 0;
    }
    return prLevel;
}

BOOL MultiMediaInstructionsSupported();

/*****************************************************************************
 * CDigitalAudio::CDigitalAudio()
 *****************************************************************************
 * Initialize the digital audio object.
 * This object manages the sample looping and playback and 
 * digitally controlled amplifier.
 */
CDigitalAudio::CDigitalAudio()
{
    m_pfBasePitch = 0;
    m_pfLastPitch = 0;
    m_pfLastSample = 0;
    m_pfLoopEnd = 0;
    m_pfLoopStart = 0;
    m_pfSampleLength = 0;
    m_prLastPitch = 0;
    m_vrLastLVolume = 0;
    m_vrLastRVolume = 0;
    m_vrBaseLVolume = 0;
    m_vrBaseRVolume = 0;
    m_vfLastLVolume = 0;
    m_vfLastRVolume = 0;
    m_ullLastSample = 0;
    m_ullLoopStart = 0;
    m_ullLoopEnd = 0;
    m_ullSampleLength = 0;
    m_fElGrande = FALSE;
#ifdef MMX_ENABLED
    m_fMMXEnabled = MultiMediaInstructionsSupported();
#endif // MMX_ENABLED
};

/*****************************************************************************
 * Other CDigitalAudio tables
 *****************************************************************************/
// Pitch increment lookup.
// value = ((index/1200)^2)*4096 where index = -100..100
const /*PFRACT*/SHORT pfCents[] = {
//  0       1       2       3       4       5       6       7
    3866,   3868,   3870,   3872,   3875,   3877,   3879,   3881,
    3884,   3886,   3888,   3890,   3893,   3895,   3897,   3899,
    3902,   3904,   3906,   3908,   3911,   3913,   3915,   3917,
    3920,   3922,   3924,   3926,   3929,   3931,   3933,   3935,
    3938,   3940,   3942,   3945,   3947,   3949,   3951,   3954,
    3956,   3958,   3961,   3963,   3965,   3967,   3970,   3972,
    3974,   3977,   3979,   3981,   3983,   3986,   3988,   3990,
    3993,   3995,   3997,   4000,   4002,   4004,   4007,   4009,
    4011,   4014,   4016,   4018,   4020,   4023,   4025,   4027,
    4030,   4032,   4034,   4037,   4039,   4041,   4044,   4046,
    4048,   4051,   4053,   4055,   4058,   4060,   4063,   4065,
    4067,   4070,   4072,   4074,   4077,   4079,   4081,   4084,
    4086,   4088,   4091,   4093,   4096,   4098,   4100,   4103,
    4105,   4107,   4110,   4112,   4114,   4117,   4119,   4122,
    4124,   4126,   4129,   4131,   4134,   4136,   4138,   4141,
    4143,   4145,   4148,   4150,   4153,   4155,   4157,   4160,
    4162,   4165,   4167,   4170,   4172,   4174,   4177,   4179,
    4182,   4184,   4186,   4189,   4191,   4194,   4196,   4199,
    4201,   4203,   4206,   4208,   4211,   4213,   4216,   4218,
    4220,   4223,   4225,   4228,   4230,   4233,   4235,   4237,
    4240,   4242,   4245,   4247,   4250,   4252,   4255,   4257,
    4260,   4262,   4265,   4267,   4269,   4272,   4274,   4277,
    4279,   4282,   4284,   4287,   4289,   4292,   4294,   4297,
    4299,   4302,   4304,   4307,   4309,   4312,   4314,   4317,
    4319,   4322,   4324,   4327,   4329,   4332,   4334,   4337,
    4339
};
// Four octaves up and down.
// value = ((index/12)^2)*4096 where index = -48..48
const PFRACT pfSemiTones[] = {
//  0       1       2       3       4       5       6       7
    256,    271,    287,    304,    322,    341,    362,    383,
    406,    430,    456,    483,    512,    542,    574,    608,
    645,    683,    724,    767,    812,    861,    912,    966,
    1024,   1084,   1149,   1217,   1290,   1366,   1448,   1534,
    1625,   1722,   1824,   1933,   2048,   2169,   2298,   2435,
    2580,   2733,   2896,   3068,   3250,   3444,   3649,   3866,
    4096,   4339,   4597,   4870,   5160,   5467,   5792,   6137,
    6501,   6888,   7298,   7732,   8192,   8679,   9195,   9741,
    10321,  10935,  11585,  12274,  13003,  13777,  14596,  15464,
    16384,  17358,  18390,  19483,  20642,  21870,  23170,  24548,
    26007,  27554,  29192,  30928,  32768,  34716,  36780,  38967,
    41285,  43740,  46340,  49096,  52015,  55108,  58385,  61857,
    65536
};
// dB conversion table.
// value = (((index / 100)^10)^.5)*4095 where index = MINDB*10..MAXDB*10
const /*VFRACT*/SHORT vfDbToVolume[] = {
//  0       1       2       3       4       5       6       7
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      2,      2,      2,      2,      2,      2,
    2,      2,      2,      2,      2,      2,      2,      2,
    2,      2,      2,      2,      2,      2,      2,      2,
    2,      2,      2,      2,      2,      2,      2,      2,
    2,      2,      2,      2,      2,      3,      3,      3,
    3,      3,      3,      3,      3,      3,      3,      3,
    3,      3,      3,      3,      3,      3,      3,      3,
    3,      3,      3,      3,      3,      3,      4,      4,
    4,      4,      4,      4,      4,      4,      4,      4,
    4,      4,      4,      4,      4,      4,      4,      4,
    4,      4,      5,      5,      5,      5,      5,      5,
    5,      5,      5,      5,      5,      5,      5,      5,
    5,      5,      6,      6,      6,      6,      6,      6,
    6,      6,      6,      6,      6,      6,      6,      7,
    7,      7,      7,      7,      7,      7,      7,      7,
    7,      7,      7,      8,      8,      8,      8,      8,
    8,      8,      8,      8,      8,      9,      9,      9,
    9,      9,      9,      9,      9,      9,      10,     10,
    10,     10,     10,     10,     10,     10,     11,     11,
    11,     11,     11,     11,     11,     11,     12,     12,
    12,     12,     12,     12,     12,     13,     13,     13,
    13,     13,     13,     14,     14,     14,     14,     14,
    14,     15,     15,     15,     15,     15,     15,     16,
    16,     16,     16,     16,     17,     17,     17,     17,
    17,     18,     18,     18,     18,     18,     19,     19,
    19,     19,     20,     20,     20,     20,     21,     21,
    21,     21,     21,     22,     22,     22,     23,     23,
    23,     23,     24,     24,     24,     24,     25,     25,
    25,     26,     26,     26,     27,     27,     27,     28,
    28,     28,     28,     29,     29,     30,     30,     30,
    31,     31,     31,     32,     32,     32,     33,     33,
    34,     34,     34,     35,     35,     36,     36,     36,
    37,     37,     38,     38,     39,     39,     40,     40,
    40,     41,     41,     42,     42,     43,     43,     44,
    44,     45,     45,     46,     47,     47,     48,     48,
    49,     49,     50,     50,     51,     52,     52,     53,
    53,     54,     55,     55,     56,     57,     57,     58,
    59,     59,     60,     61,     61,     62,     63,     64,
    64,     65,     66,     67,     67,     68,     69,     70,
    71,     71,     72,     73,     74,     75,     76,     77,
    78,     78,     79,     80,     81,     82,     83,     84,
    85,     86,     87,     88,     89,     90,     91,     92,
    93,     94,     95,     97,     98,     99,     100,    101,
    102,    104,    105,    106,    107,    108,    110,    111,
    112,    114,    115,    116,    118,    119,    120,    122,
    123,    125,    126,    128,    129,    130,    132,    134,
    135,    137,    138,    140,    141,    143,    145,    146,
    148,    150,    152,    153,    155,    157,    159,    161,
    163,    164,    166,    168,    170,    172,    174,    176,
    178,    180,    182,    185,    187,    189,    191,    193,
    195,    198,    200,    202,    205,    207,    210,    212,
    214,    217,    219,    222,    225,    227,    230,    232,
    235,    238,    241,    243,    246,    249,    252,    255,
    258,    261,    264,    267,    270,    273,    276,    280,
    283,    286,    289,    293,    296,    300,    303,    307,
    310,    314,    317,    321,    325,    329,    332,    336,
    340,    344,    348,    352,    356,    360,    364,    369,
    373,    377,    382,    386,    391,    395,    400,    404,
    409,    414,    419,    423,    428,    433,    438,    443,
    449,    454,    459,    464,    470,    475,    481,    486,
    492,    498,    503,    509,    515,    521,    527,    533,
    539,    546,    552,    558,    565,    571,    578,    585,
    591,    598,    605,    612,    619,    626,    634,    641,
    649,    656,    664,    671,    679,    687,    695,    703,
    711,    719,    728,    736,    745,    753,    762,    771,
    780,    789,    798,    807,    817,    826,    836,    845,
    855,    865,    875,    885,    895,    906,    916,    927,
    938,    948,    959,    971,    982,    993,    1005,   1016,
    1028,   1040,   1052,   1064,   1077,   1089,   1102,   1114,
    1127,   1140,   1154,   1167,   1181,   1194,   1208,   1222,
    1236,   1250,   1265,   1280,   1294,   1309,   1325,   1340,
    1355,   1371,   1387,   1403,   1419,   1436,   1452,   1469,
    1486,   1504,   1521,   1539,   1556,   1574,   1593,   1611,
    1630,   1649,   1668,   1687,   1707,   1726,   1746,   1767,
    1787,   1808,   1829,   1850,   1871,   1893,   1915,   1937,
    1959,   1982,   2005,   2028,   2052,   2076,   2100,   2124,
    2149,   2173,   2199,   2224,   2250,   2276,   2302,   2329,
    2356,   2383,   2411,   2439,   2467,   2496,   2524,   2554,
    2583,   2613,   2643,   2674,   2705,   2736,   2768,   2800,
    2833,   2865,   2899,   2932,   2966,   3000,   3035,   3070,
    3106,   3142,   3178,   3215,   3252,   3290,   3328,   3367,
    3406,   3445,   3485,   3525,   3566,   3607,   3649,   3691,
    3734,   3777,   3821,   3865,   3910,   3955,   4001,   4048,
    4095
};

/*****************************************************************************
 * CDigitalAudio::VRELToVFRACT()
 *****************************************************************************
 * Translate between VREL and VFRACT, clamping if necessary.
 */
VFRACT CDigitalAudio::VRELToVFRACT(VREL vrVolume)
{
    vrVolume /= 10;
    if (vrVolume < MINDB * 10) vrVolume = MINDB * 10;
    else if (vrVolume >= MAXDB * 10) vrVolume = MAXDB * 10;
    return (::vfDbToVolume[vrVolume - MINDB * 10]);
}

/*****************************************************************************
 * CDigitalAudio::PRELToPFRACT()
 *****************************************************************************
 * Translates from PREL to PFRACT, clamping if necessary.
 */
PFRACT CDigitalAudio::PRELToPFRACT(PREL prPitch)
{
    PFRACT pfPitch = 0;
    PREL prOctave;
    if (prPitch > 100)
    {
        if (prPitch > 4800)
        {
            prPitch = 4800;
        }
        prOctave = prPitch / 100;
        prPitch = prPitch % 100;
        pfPitch = ::pfCents[prPitch + 100];
        pfPitch <<= prOctave / 12;
        prOctave = prOctave % 12;
        pfPitch *= ::pfSemiTones[prOctave + 48];
        pfPitch >>= 12;
    }
    else if (prPitch < -100)
    {
        if (prPitch < -4800)
        {
            prPitch = -4800;
        }
        prOctave = prPitch / 100;
        prPitch = (-prPitch) % 100;
        pfPitch = ::pfCents[100 - prPitch];
        pfPitch >>= ((-prOctave) / 12);
        prOctave = (-prOctave) % 12;
        pfPitch *= ::pfSemiTones[48 - prOctave];
        pfPitch >>= 12;
    }
    else
    {
        pfPitch = ::pfCents[prPitch + 100];
    }
    return (pfPitch);
}

/*****************************************************************************
 * CDigitalAudio::ClearVoice()
 *****************************************************************************
 * Clear this voice in the Digital Audio Engine.  The wave object can go away now.
 */
void CDigitalAudio::ClearVoice()
{
    if (m_Source.m_pWave != NULL)
    {
        m_Source.m_pWave->PlayOff();
        m_Source.m_pWave->Release();    // Releases wave structure.
        m_Source.m_pWave = NULL;
    }
}

/*****************************************************************************
 * CDigitalAudio::StartVoice()
 *****************************************************************************
 * Start a voice on the given synth and sample.
 */
STIME CDigitalAudio::StartVoice(CSynth *pSynth,    CSourceSample *pSample, 
                               VREL vrBaseLVolume, VREL vrBaseRVolume,
                               PREL prBasePitch,   long lKey)
{
    m_vrBaseLVolume = vrBaseLVolume;
    m_vrBaseRVolume = vrBaseRVolume;
    m_vfLastLVolume = VRELToVFRACT(MIN_VOLUME); 
    m_vfLastRVolume = VRELToVFRACT(MIN_VOLUME);
    m_vrLastLVolume = 0;
    m_vrLastRVolume = 0;
    m_prLastPitch = 0;
    m_Source = *pSample;
    m_pnWave = pSample->m_pWave->m_pnWave;
    m_pSynth = pSynth;
    pSample->m_pWave->AddRef(); // Keeps track of Wave usage.
    pSample->m_pWave->PlayOn();
    prBasePitch += pSample->m_prFineTune;
    prBasePitch += ((lKey - pSample->m_bMIDIRootKey) * 100);
    m_pfBasePitch = PRELToPFRACT(prBasePitch);
    m_pfBasePitch *= pSample->m_dwSampleRate;
    m_pfBasePitch /= pSynth->m_dwSampleRate;
    m_pfLastPitch = m_pfBasePitch;
    
    m_fElGrande = pSample->m_dwSampleLength >= 0x80000;     // Greater than 512k.
    if ((pSample->m_dwLoopEnd - pSample->m_dwLoopStart) >= 0x80000)
    {   // We can't handle loops greater than 1 meg!
        m_Source.m_bOneShot = TRUE;
    }
    m_ullLastSample = 0;
    m_ullLoopStart = pSample->m_dwLoopStart;
    m_ullLoopStart = m_ullLoopStart << 12;
    m_ullLoopEnd = pSample->m_dwLoopEnd;
    m_ullLoopEnd = m_ullLoopEnd << 12;
    m_ullSampleLength = pSample->m_dwSampleLength;
    m_ullSampleLength = m_ullSampleLength << 12;
    m_pfLastSample = 0;
    m_pfLoopStart = (long) m_ullLoopStart;
    m_pfLoopEnd = (long) m_ullLoopEnd;
    if (m_pfLoopEnd <= m_pfLoopStart) // Should never happen, but death if it does!
    {
        m_Source.m_bOneShot = TRUE;
    }
    if (m_fElGrande)
    {
        m_pfSampleLength = 0x7FFFFFFF;
    }
    else
    {
        m_pfSampleLength = (long) m_ullSampleLength;
    }
    return (0); // !!! what is this return value?
}

/*  If the wave is bigger than one meg, the index can overflow. 
    Solve this by assuming no mix session will ever be as great
    as one meg AND loops are never that long. We keep all our
    fractional indexes in two variables. In one case, m_pfLastSample,
    is the normal mode where the lower 12 bits are the fraction and 
    the upper 20 bits are the index. And, m_ullLastSample
    is a LONGLONG with an extra 32 bits of index. The mix engine
    does not want the LONGLONGs, so we need to track the variables
    in the LONGLONGs and prepare them for the mixer as follows:
    Prior to mixing,
    if the sample is large (m_fElGrande is set), BeforeSampleMix()
    is called. This finds the starting point for the mix, which 
    is either the current position or the start of the loop, 
    whichever is earlier. It subtracts this starting point from
    the LONGLONG variables and stores an offset in m_dwAddressUpper.
    It also adjusts the pointer to the wave data appropriately.
    AfterSampleMix() does the inverse, reconstructing the the LONGLONG
    indeces and returning everthing back to normal.
*/

/*****************************************************************************
 * CDigitalAudio::BeforeBigSampleMix()
 *****************************************************************************
 * Setup before doing a large sample mix/loop.
 */
void CDigitalAudio::BeforeBigSampleMix()
{
    if (m_fElGrande)
    {
        ULONGLONG ullBase = 0;
        DWORD dwBase;
        if (m_Source.m_bOneShot)
        {
            ullBase = m_ullLastSample;
        }
        else
        {
            if (m_ullLastSample < m_ullLoopStart)
            {
                ullBase = m_ullLastSample;
            }
            else
            { 
                ullBase = m_ullLoopStart;
            }
        }
        ullBase >>= 12;
        dwBase = (DWORD) ullBase & 0xFFFFFFFE;      // Clear bottom bit so 8 bit pointer aligns with short.
        ullBase = dwBase;
        ullBase <<= 12;
        m_dwAddressUpper = dwBase;
        m_pfLastSample = (long) (m_ullLastSample - ullBase);
        if ((m_ullLoopEnd - ullBase) < 0x7FFFFFFF)
        {
            m_pfLoopStart = (long) (m_ullLoopStart - ullBase);
            m_pfLoopEnd = (long) (m_ullLoopEnd - ullBase);
        }
        else
        {
            m_pfLoopStart = 0;
            m_pfLoopEnd = 0x7FFFFFFF;
        }
        ullBase = m_ullSampleLength - ullBase;
        if (ullBase > 0x7FFFFFFF)
        {
            m_pfSampleLength = 0x7FFFFFFF;
        }
        else
        {
            m_pfSampleLength = (long) ullBase;
        }
        if (m_Source.m_bSampleType & SFORMAT_8)
        {
            dwBase >>= 1;
        }
        m_pnWave = &m_Source.m_pWave->m_pnWave[dwBase];
    }
}

/*****************************************************************************
 * CDigitalAudio::AfterBigSampleMix()
 *****************************************************************************
 * Cleanup after doing a large sample mix/loop.
 */
void CDigitalAudio::AfterBigSampleMix()
{
    m_pnWave = m_Source.m_pWave->m_pnWave;
    if (m_fElGrande)
    {
        ULONGLONG ullBase = m_dwAddressUpper;
        m_ullLastSample = m_pfLastSample;
        m_ullLastSample += (ullBase << 12);
        m_dwAddressUpper = 0;
    }
}

/*****************************************************************************
 * CDigitalAudio::Mix()
 *****************************************************************************
 * Do a mix on this buffer.  This handles loops and calling the different mix 
 * functions (depending on format).
 */
BOOL CDigitalAudio::Mix(short *pBuffer, DWORD dwLength, // length in SAMPLES
                        VREL  vrVolumeL,VREL  vrVolumeR,
                        PREL  prPitch,  DWORD dwStereo)
{
    PFRACT pfDeltaPitch;
    PFRACT pfEnd;
    PFRACT pfLoopLen;
    PFRACT pfNewPitch;
    VFRACT vfNewLVolume;
    VFRACT vfNewRVolume;
    VFRACT vfDeltaLVolume;
    VFRACT vfDeltaRVolume;
    DWORD dwPeriod = 64;
    DWORD dwSoFar;
    DWORD dwStart; // position in WORDs
    DWORD dwMixChoice = dwStereo ? SPLAY_STEREO : 0;
    if (dwLength == 0)      // Attack was instant. 
    {
        m_pfLastPitch = (m_pfBasePitch * PRELToPFRACT(prPitch)) >> 12;
        m_vfLastLVolume = VRELToVFRACT(m_vrBaseLVolume + vrVolumeL);
        m_vfLastRVolume = VRELToVFRACT(m_vrBaseRVolume + vrVolumeR);
        m_prLastPitch = prPitch;
        m_vrLastLVolume = vrVolumeL;
        m_vrLastRVolume = vrVolumeR;
        return (TRUE);
    }
    if ((m_Source.m_pWave == NULL) || (m_Source.m_pWave->m_pnWave == NULL))
    {
        return FALSE;
    }
    DWORD dwMax = abs(vrVolumeL - m_vrLastLVolume);
    m_vrLastLVolume = vrVolumeL;
    dwMax = max((long)dwMax,abs(vrVolumeR - m_vrLastRVolume));
    m_vrLastRVolume = vrVolumeR;
    dwMax = max((long)dwMax,abs(prPitch - m_prLastPitch) << 1);
    dwMax >>= 1;
    m_prLastPitch = prPitch;
    if (dwMax > 0)
    {
        dwPeriod = (dwLength << 3) / dwMax;
        if (dwPeriod > 512)
        {
            dwPeriod = 512;
        }
        else if (dwPeriod < 1)
        {
            dwPeriod = 1;
        }
    }
    else
    {
        dwPeriod = 512;     // Make it happen anyway.
    }

    // This makes MMX sound a little better (MMX bug will be fixed)
    dwPeriod += 3;
    dwPeriod &= 0xFFFFFFFC;

    pfNewPitch = m_pfBasePitch * PRELToPFRACT(prPitch);
    pfNewPitch >>= 12;

    pfDeltaPitch = MulDiv(pfNewPitch - m_pfLastPitch,dwPeriod << 8,dwLength);
    vfNewLVolume = VRELToVFRACT(m_vrBaseLVolume + vrVolumeL);
    vfNewRVolume = VRELToVFRACT(m_vrBaseRVolume + vrVolumeR);
    vfDeltaLVolume = MulDiv(vfNewLVolume - m_vfLastLVolume,dwPeriod << 8,dwLength);
    vfDeltaRVolume = MulDiv(vfNewRVolume - m_vfLastRVolume,dwPeriod << 8,dwLength);

    if (m_fMMXEnabled && (dwLength > 8))
    {
       dwMixChoice |= SPLAY_MMX; 
    }
    dwMixChoice |= m_Source.m_bSampleType;
    dwStart = 0;

    for (;;)
    {
        if (dwLength <= 8)
        {
            dwMixChoice &= ~SPLAY_MMX;
        }
        if (m_fElGrande)
        {
            BeforeBigSampleMix();
        }
        if (m_Source.m_bOneShot)
        {
            pfEnd = m_pfSampleLength;
            pfLoopLen = 0;
        }
        else
        {
            pfEnd = m_pfLoopEnd;
            pfLoopLen = m_pfLoopEnd - m_pfLoopStart;
            if (pfLoopLen <= pfNewPitch)
            {
                return FALSE;
            }
        }
        switch (dwMixChoice)
        {
        case SFORMAT_8 | SPLAY_STEREO : 
            dwSoFar = Mix8(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_8 : 
            dwSoFar = MixMono8(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_16 | SPLAY_STEREO : 
            dwSoFar = Mix16(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_16 :
            dwSoFar = MixMono16(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
            break;
#ifdef MMX_ENABLED
        case SFORMAT_8 | SPLAY_MMX | SPLAY_STEREO : 
            dwSoFar = Mix8X(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume ,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
        
            break;
        case SFORMAT_16 | SPLAY_MMX | SPLAY_STEREO : 
            dwSoFar = Mix16X(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
            break; 
        case SFORMAT_8 | SPLAY_MMX : 
            dwSoFar = MixMono8X(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
        
            break;
        case SFORMAT_16 | SPLAY_MMX : 
            dwSoFar = MixMono16X(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, 
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
            break; 
#endif
        default :
            return (FALSE);
        }
        if (m_fElGrande)
        {
            AfterBigSampleMix();
        }
        if (m_Source.m_bOneShot)
        {
            if (dwSoFar < dwLength) 
            {
                return (FALSE);
            }
            break;
        }
        else
        {
            if (dwSoFar >= dwLength) break;

        // !!! even though we often handle loops in the mix function, sometimes
        // we don't, so we still need this code.
            // otherwise we must have reached the loop's end.
            dwStart += dwSoFar << dwStereo;
            dwLength -= dwSoFar;
            m_pfLastSample -= (m_pfLoopEnd - m_pfLoopStart);  
        }
    }

    m_vfLastLVolume = vfNewLVolume;
    m_vfLastRVolume = vfNewRVolume;
    m_pfLastPitch = pfNewPitch;
    return (TRUE);
}

/*****************************************************************************
 * CVoice::CVoice()
 *****************************************************************************
 * Constructor for the CVoice object.
 */
CVoice::CVoice()
{
    m_pControl = NULL;
    m_pPitchBendIn = NULL;
    m_pExpressionIn = NULL;
    m_dwPriority = 0;
    m_nPart = 0;
    m_nKey = 0;
    m_fInUse = FALSE;
    m_fSustainOn = FALSE;
    m_fNoteOn = FALSE;
    m_fTag = FALSE;
    m_stStartTime = 0;
    m_stStopTime = 0x7fffffffffffffff;
    m_vrVolume = 0;
    m_fAllowOverlap = FALSE;
}

/*****************************************************************************
 * svrPanToVREL[]
 *****************************************************************************
 * A table for 0-127 translation to log scale.
 * value = log10(index/127) * 1000 where index = 0..128
 */
const VREL svrPanToVREL[] = {
//  0       1       2       3       4       5       6       7
    -2500,  -2103,  -1802,  -1626,  -1501,  -1404,  -1325,  -1258,
    -1200,  -1149,  -1103,  -1062,  -1024,  -989,   -957,   -927,
    -899,   -873,   -848,   -825,   -802,   -781,   -761,   -742,
    -723,   -705,   -688,   -672,   -656,   -641,   -626,   -612,
    -598,   -585,   -572,   -559,   -547,   -535,   -524,   -512,
    -501,   -491,   -480,   -470,   -460,   -450,   -441,   -431,
    -422,   -413,   -404,   -396,   -387,   -379,   -371,   -363,
    -355,   -347,   -340,   -332,   -325,   -318,   -311,   -304,
    -297,   -290,   -284,   -277,   -271,   -264,   -258,   -252,
    -246,   -240,   -234,   -228,   -222,   -217,   -211,   -206,
    -200,   -195,   -189,   -184,   -179,   -174,   -169,   -164,
    -159,   -154,   -149,   -144,   -140,   -135,   -130,   -126,
    -121,   -117,   -112,   -108,   -103,   -99,    -95,    -90,
    -86,    -82,    -78,    -74,    -70,    -66,    -62,    -58,
    -54,    -50,    -46,    -43,    -39,    -35,    -31,    -28,
    -24,    -21,    -17,    -13,    -10,    -6,     -3,     0
};

/*****************************************************************************
 * CVoice::StopVoice()
 *****************************************************************************
 * Stop the voice if it is playing.  Reset the envelope generators, sustain.
 */
void CVoice::StopVoice(STIME stTime)
{
    if (m_fNoteOn)
    {
        if (stTime <= m_stStartTime) stTime = m_stStartTime + 1;
        m_PitchEG.StopVoice(stTime);
        m_VolumeEG.StopVoice(stTime);
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_stStopTime = stTime;
    }
}

/*****************************************************************************
 * CVoice::QuickStopVoice()
 *****************************************************************************
 * Stop the voice ASAP.  If the note is on or sustaining, turn everything off
 * now, otherwise we just have to stop the volume EG (kill the decay curve).
 */
void CVoice::QuickStopVoice(STIME stTime)
{
    m_fTag = TRUE;
    if (m_fNoteOn || m_fSustainOn)
    {
        if (stTime <= m_stStartTime) stTime = m_stStartTime + 1;
        m_PitchEG.StopVoice(stTime);
        m_VolumeEG.QuickStopVoice(stTime,m_pSynth->m_dwSampleRate);
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_stStopTime = stTime;
    }
    else
    {
        m_VolumeEG.QuickStopVoice(m_stStopTime,m_pSynth->m_dwSampleRate);
    }
}

/*****************************************************************************
 * CVoice::StartVoice()
 *****************************************************************************
 * Start the voice with all the given parameters for pitch, mod, pan, etc.
 * The region must have an articulation and a wave.  Mix it now if the 
 * start time dictates.
 */
BOOL CVoice::StartVoice(CSynth *pSynth,
                        CSourceRegion *pRegion, STIME stStartTime,
                        CModWheelIn * pModWheelIn,
                        CPitchBendIn * pPitchBendIn,
                        CExpressionIn * pExpressionIn,
                        CVolumeIn * pVolumeIn,
                        CPanIn * pPanIn,
                        WORD nKey,WORD nVelocity,
                        VREL vrVolume,
                        PREL prPitch)
{
    CSourceArticulation * pArticulation = pRegion->m_pArticulation;
    if (pArticulation == NULL)
    {
        return FALSE;
    }
    // if we're going to handle volume later, don't read it now.
    if (!pSynth->m_fAllowVolumeChangeWhilePlayingNote)
        vrVolume += pVolumeIn->GetVolume(stStartTime);
    prPitch += pRegion->m_prTuning;
    m_dwGroup = pRegion->m_bGroup;
    m_fAllowOverlap = pRegion->m_bAllowOverlap;

    m_pSynth = pSynth;

    vrVolume += CMIDIRecorder::VelocityToVolume(nVelocity);
//                 * (long) pArticulation->m_sVelToVolScale) / -9600);

    vrVolume += pRegion->m_vrAttenuation;

    m_lDefaultPan = pRegion->m_pArticulation->m_sDefaultPan;
    // ignore pan here if allowing pan to vary after note starts

    VREL vrLVolume;
    VREL vrRVolume;
    if (pSynth->m_dwStereo && !pSynth->m_fAllowPanWhilePlayingNote) {
        long lPan = pPanIn->GetPan(stStartTime) + m_lDefaultPan;
        if (lPan < 0) lPan = 0;
        if (lPan > 127) lPan = 127;
        vrLVolume = ::svrPanToVREL[127 - lPan] + vrVolume;
        vrRVolume = ::svrPanToVREL[lPan] + vrVolume;
    } else {
        vrLVolume = vrVolume;
        vrRVolume = vrVolume;
    }
    
    m_stMixTime = m_LFO.StartVoice(&pArticulation->m_LFO,
        stStartTime, pModWheelIn);
    STIME stMixTime = m_PitchEG.StartVoice(&pArticulation->m_PitchEG,
        stStartTime, nKey, nVelocity);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }
    stMixTime = m_VolumeEG.StartVoice(&pArticulation->m_VolumeEG,
            stStartTime, nKey, nVelocity);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }
    if (m_stMixTime > pSynth->m_stMaxSpan)
    {
        m_stMixTime = pSynth->m_stMaxSpan;
    }
    // Make sure we have a pointer to the wave ready:
    if ((pRegion->m_Sample.m_pWave == NULL) || (pRegion->m_Sample.m_pWave->m_pnWave == NULL))
    {
        return (FALSE);     // Do nothing if no sample.
    }
    m_DigitalAudio.StartVoice(pSynth,&pRegion->m_Sample,
        vrLVolume, vrRVolume, prPitch, (long)nKey);

    m_pPitchBendIn = pPitchBendIn;
    m_pExpressionIn = pExpressionIn;
    m_pPanIn = pPanIn;
    m_pVolumeIn = pVolumeIn;
    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_stStartTime = stStartTime;
    m_stLastMix = stStartTime - 1;
    m_stStopTime = 0x7fffffffffffffff;
    
    if (m_stMixTime == 0)
    {
        // zero length attack, be sure it isn't missed....

        PREL prPitch = GetNewPitch(stStartTime);
        VREL vrVolume, vrVolumeR;
        GetNewVolume(stStartTime, vrVolume, vrVolumeR);

        if (m_stMixTime > pSynth->m_stMaxSpan)
        {
            m_stMixTime = pSynth->m_stMaxSpan;
        }

        m_DigitalAudio.Mix(NULL, 0,
                               vrVolume, vrVolumeR, prPitch,
                               m_pSynth->m_dwStereo);
    }
    m_vrVolume = 0;
    return (TRUE);
}
    
/*****************************************************************************
 * CVoice::ClearVoice()
 *****************************************************************************
 * Clear the voice (just forward to the digital audio peer object).
 */
void CVoice::ClearVoice()
{
    m_fInUse = FALSE;
    m_DigitalAudio.ClearVoice();
}

/*****************************************************************************
 * CVoice::GetNewVolume()
 *****************************************************************************
 * Return the volume delta at time <stTime>.
 * Volume is sum of volume envelope, LFO, expression, optionally the
 * channel volume if we're allowing it to change, and optionally the current
 * pan if we're allowing that to change.
 * This will be added to the base volume calculated in CVoice::StartVoice().
 */
void CVoice::GetNewVolume(STIME stTime, VREL& vrVolume, VREL &vrVolumeR)
{
    STIME stMixTime;
    vrVolume = m_VolumeEG.GetVolume(stTime,&stMixTime);
    if (stMixTime < m_stMixTime) m_stMixTime = stMixTime;
    // save pre-LFO volume for code that detects whether this note is off
    m_vrVolume = vrVolume;

    vrVolume += m_LFO.GetVolume(stTime,&stMixTime);
    if (stMixTime < m_stMixTime) m_stMixTime = stMixTime;
    vrVolume += m_pExpressionIn->GetVolume(stTime);

    if (m_pSynth->m_fAllowVolumeChangeWhilePlayingNote)
        vrVolume += m_pVolumeIn->GetVolume(stTime);

    vrVolume += m_pSynth->m_vrGainAdjust;
    vrVolumeR = vrVolume;
   
    // handle pan here if allowing pan to vary after note starts
    if (m_pSynth->m_dwStereo &&
        m_pSynth->m_fAllowPanWhilePlayingNote)
    {
        // add current pan & instrument default pan
        LONG lPan = m_pPanIn->GetPan(stTime) + m_lDefaultPan;

        // don't go off either end....
        if (lPan < 0) lPan = 0;
        if (lPan > 127) lPan = 127;
        vrVolume += ::svrPanToVREL[127 - lPan];
        vrVolumeR += ::svrPanToVREL[lPan];
    }
}

/*****************************************************************************
 * CVoice::GetNewPitch()
 *****************************************************************************
 * Returns the current pitch for time <stTime>.
 * Pitch is the sum of the pitch LFO, the pitch envelope, and the current
 * pitch bend.
 */
PREL CVoice::GetNewPitch(STIME stTime)
{
    STIME stMixTime;
    PREL prPitch = m_LFO.GetPitch(stTime,&stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;
    prPitch += m_PitchEG.GetPitch(stTime,&stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;
    prPitch += m_pPitchBendIn->GetPitch(stTime); 

    return prPitch;
}


/*****************************************************************************
 * CVoice::Mix()
 *****************************************************************************
 * Mix this voice into the given buffer.  Determine certain volume and pitch
 * parameters, then call into the Digital Audio Engine.
 */
DWORD CVoice::Mix(  short *pBuffer, DWORD dwLength,
                    STIME stStart,  STIME stEnd)
{
    BOOL fInUse = TRUE;
    BOOL fFullMix = TRUE;
    STIME stEndMix = stStart;

    STIME stStartMix = m_stStartTime;
    if (stStartMix < stStart) 
    {
        stStartMix = stStart;
    }
    if (m_stLastMix >= stEnd)
    {
        return (0);
    }
    if (m_stLastMix >= stStartMix)
    {
        stStartMix = m_stLastMix;
    }
    while (stStartMix < stEnd && fInUse)
    {   
        stEndMix = stStartMix + m_stMixTime;
        
        if (stEndMix > stEnd)
        {
            stEndMix = stEnd;
        }
        m_stMixTime = m_pSynth->m_stMaxSpan;
        if ((m_stLastMix < m_stStopTime) && (m_stStopTime < stEnd))
        {
            if (m_stMixTime > (m_stStopTime - m_stLastMix))
            {
                m_stMixTime = m_stStopTime - m_stLastMix;
            }
        }
        
        PREL prPitch = GetNewPitch(stEndMix);

        VREL vrVolume, vrVolumeR;
        GetNewVolume(stEndMix, vrVolume, vrVolumeR);
        
        if (m_VolumeEG.InRelease(stEndMix)) 
        {
            if (m_vrVolume < PERCEIVED_MIN_VOLUME) // End of release slope
            {
                fInUse = FALSE;
            }
        }

        fFullMix = m_DigitalAudio.Mix(&pBuffer[(stStartMix - stStart) <<
                                                      m_pSynth->m_dwStereo],
                                      (DWORD) (stEndMix - stStartMix),
                                      vrVolume, vrVolumeR, prPitch,
                                      m_pSynth->m_dwStereo);
        stStartMix = stEndMix;
    }
    m_fInUse = fInUse && fFullMix;
    if (!m_fInUse) 
    {
        ClearVoice();
        m_stStopTime = stEndMix;    // For measurement purposes.
    }
    m_stLastMix = stEndMix;
    return (dwLength);
}



=== dmusuart/dmusuart.htm ===
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-
1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>DMUSUART</TITLE>
</HEAD>
<BODY LINK="#0000ff">

<FONT FACE="Verdana" SIZE=5><H2>DMUSUART</H2>
</FONT><FONT FACE="Verdana" SIZE=2>
<P><span style="color:#FF0000;font-size:10pt;font-family:Arial">[This is preliminary 
documentation and subject to change.]</span></P>

<H3>SUMMARY</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
This sample is a DMusic UART miniport driver, which provides an interface to the MPU-401 chip. <P>
The DMusic (DMUS) port driver, which is built into PortCls.sys, insulates this miniport and connects it to the rest of the system. The sample handles
one input stream visible to either DirectMusic or midiIn APIs, one output stream visible to midiOut APIs, and multiple output streams visible to DirectMusic APIs.  It compiles in the 64-bit environment and is compatible with both Alpha and x86 platforms.<P>
Plug and Play and Power Management are handled automatically on the miniport's behalf by PortCls.<P>

<H3>BUILDING THE SAMPLE</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>

Type <B>build</B> in the \\Ntddk\Src\Wdm\Audio\Miniport\dmusuart directory.  A 
successful build produces dmusuart.lib, which can be linked into an adapter driver.<P>


<H3>RESOURCES</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
This exact miniport is already included in PortCls. We have provided the source code as a starting point for those that need to write simple DMusic drivers (for more complex DMusic devices, including those that have DLS functionality, please instead reference the DMusic kernel-mode software synth sample).
This miniport interfaces to the port driver of type DMUS. There is also an older port, type MIDI, that is present in PortCls.  Unlike the DMUS port, the MIDI port is available in Windows 98.  The DMUS port provides higher functionality than the MIDI port, so if you are creating your own miniport, consider interfacing to DMUS instead of MIDI. The advantage of DMUS miniport drivers is that they are visible to DirectMusic APIs, unlike MIDI miniport drivers. Additionally, DMUS miniports can be visible to the older MIDI APIs if the legacy pin descriptor is included. In short, DirectMusic miniports have the benefits of both backward compatibility and advanced functionality. 
<p>
Please refer to the SB16 sample to learn how to include and use the built-in miniport.<p>


DirectMusic kernel support is available in Windows 98SE, Windows 2000 and later.




<H3>CODE TOUR</H3>
<H4>File Manifest</H4>
</FONT><U><PRE>File&#9;&#9;Description
</U>
miniport.cpp&#9;Miniport driver implementation
mpu.cpp&#9; 	MPU device-specific implementation
private.h&#9;Interface for the CPP files
sources&#9;	Sources for build
</FONT><P ALIGN="CENTER"><A HREF="#top"><FONT FACE="Verdana" SIZE=2>Top of page</FONT></A><FONT FACE="Verdana" SIZE=2> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 WIDTH=624>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff" HEIGHT=2>
<P></TD>
</TR>
</TABLE>

<FONT FACE="MS Sans Serif" SIZE=1><P>&copy; 1999 Microsoft Corporation</FONT><FONT FACE="Verdana" SIZE=2> </P></FONT></BODY>
</HTML>

=== dmusuart/makefile ===
#############################################################################
#
#       Copyright (C) Microsoft Corporation 1998-1999
#       All Rights Reserved.
#
#       Makefile for wdm\audio\backpln\miniport\DMusUART
#
#       6/8/98  MartinP
#
#############################################################################

## Define WIN95_BUILD to build in the memphis
## build enviroment

!IFDEF WIN95_BUILD

ROOT = ..\..\..\..\..

IS_32   = TRUE
IS_OEM  = TRUE
DEVICEDIR = DMusUART
COMMONMKFILE = $(DEVICEDIR).mk
DEPENDTARGETS = debug

!include $(ROOT)\dev\master.mk

## NT BUILD ENVIROMENT
!ELSE

#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT.
#
!INCLUDE $(NTMAKEENV)\makefile.def

!ENDIF

=== dmusuart/miniport.cpp ===
/*****************************************************************************
 * miniport.cpp - UART miniport implementation
 *****************************************************************************
 * Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *      Feb 98    MartinP   --  based on UART, began deltas for DirectMusic.
 */

#include "private.h"
#include "ksdebug.h"

#define STR_MODULENAME "DMusUART:Miniport: "


#define MartinTestCaptureHack   0
#if MartinTestCaptureHack
BOOLEAN gJustSetToRun = FALSE;
#endif  //  MartinTestCaptureHack


#pragma code_seg("PAGE")

/*****************************************************************************
 * PinDataRangesStreamLegacy
 * PinDataRangesStreamDMusic
 *****************************************************************************
 * Structures indicating range of valid format values for live pins.
 */
static
KSDATARANGE_MUSIC PinDataRangesStreamLegacy =
{
    {
        sizeof(KSDATARANGE_MUSIC),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    },
    STATICGUIDOF(KSMUSIC_TECHNOLOGY_PORT),
    0,
    0,
    0xFFFF
};
static
KSDATARANGE_MUSIC PinDataRangesStreamDMusic =
{
    {
        sizeof(KSDATARANGE_MUSIC),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    },
    STATICGUIDOF(KSMUSIC_TECHNOLOGY_PORT),
    0,
    0,
    0xFFFF
};

/*****************************************************************************
 * PinDataRangePointersStreamLegacy
 * PinDataRangePointersStreamDMusic
 * PinDataRangePointersStreamCombined
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for live pins.
 */
static
PKSDATARANGE PinDataRangePointersStreamLegacy[] =
{
    PKSDATARANGE(&PinDataRangesStreamLegacy)
};
static
PKSDATARANGE PinDataRangePointersStreamDMusic[] =
{
    PKSDATARANGE(&PinDataRangesStreamDMusic)
};
static
PKSDATARANGE PinDataRangePointersStreamCombined[] =
{
    PKSDATARANGE(&PinDataRangesStreamLegacy)
   ,PKSDATARANGE(&PinDataRangesStreamDMusic)
};

/*****************************************************************************
 * PinDataRangesBridge
 *****************************************************************************
 * Structures indicating range of valid format values for bridge pins.
 */
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI_BUS),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

/*****************************************************************************
 * PinDataRangePointersBridge
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for bridge pins.
 */
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

/*****************************************************************************
 * SynthProperties
 *****************************************************************************
 * List of properties in the Synth set.
 */
static
PCPROPERTY_ITEM
SynthProperties[] =
{
    // Per stream: Download DLS sample
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DLS_DOWNLOAD,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth_Dls
    },
    // Per stream: Unload DLS sample
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DLS_UNLOAD,
        KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth_Dls
    },
    // Global: Compact DLS memory
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DLS_COMPACT,
        KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth_Dls
    },
    // Global: Set append zone size
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DLS_APPEND,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth_Dls
    },
    // Global: Get current volume
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUME,
        KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Global: S/Get volume boost value
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUMEBOOST,
        KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Global: S/Get synthesizer caps
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CAPS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Global: S/Get port parameters
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_PORTPARAMETERS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per stream: S/Get channel groups
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CHANNELGROUPS,
        KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per stream: Get current voice priority
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOICEPRIORITY,
        KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per stream: Get current latency time
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_LATENCYCLOCK,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    }
};
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSynth,  SynthProperties);
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSynth2, SynthProperties);

#define kMaxNumCaptureStreams       1
#define kMaxNumLegacyRenderStreams  1
#define kMaxNumDMusicRenderStreams  16

/*****************************************************************************
 * MiniportPins
 *****************************************************************************
 * List of pins.
 */
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    {
        kMaxNumLegacyRenderStreams,kMaxNumLegacyRenderStreams,0,    // InstanceCount
        NULL,                                                       // AutomationTable
        {                                                           // KsPinDescriptor
            0,                                              // InterfacesCount
            NULL,                                           // Interfaces
            0,                                              // MediumsCount
            NULL,                                           // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStreamLegacy), // DataRangesCount
            PinDataRangePointersStreamLegacy,               // DataRanges
            KSPIN_DATAFLOW_IN,                              // DataFlow
            KSPIN_COMMUNICATION_SINK,                       // Communication
            (GUID *) &KSCATEGORY_AUDIO,                     // Category
            &KSAUDFNAME_MIDI,                               // Name
            0                                               // Reserved
        }
    },
    {
        kMaxNumDMusicRenderStreams,kMaxNumDMusicRenderStreams,0,    // InstanceCount
        NULL,                                                       // AutomationTable
        {                                                           // KsPinDescriptor
            0,                                              // InterfacesCount
            NULL,                                           // Interfaces
            0,                                              // MediumsCount
            NULL,                                           // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStreamDMusic), // DataRangesCount
            PinDataRangePointersStreamDMusic,               // DataRanges
            KSPIN_DATAFLOW_IN,                              // DataFlow
            KSPIN_COMMUNICATION_SINK,                       // Communication
            (GUID *) &KSCATEGORY_AUDIO,                     // Category
            &KSAUDFNAME_DMUSIC_MPU_OUT,                     // Name
            0                                               // Reserved
        }
    },
    {
        0,0,0,                                      // InstanceCount
        NULL,                                       // AutomationTable
        {                                           // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
    {
        0,0,0,                                      // InstanceCount
        NULL,                                       // AutomationTable
        {                                           // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
    {
        kMaxNumCaptureStreams,kMaxNumCaptureStreams,0,      // InstanceCount
        NULL,                                               // AutomationTable
        {                                                   // KsPinDescriptor
            0,                                                // InterfacesCount
            NULL,                                             // Interfaces
            0,                                                // MediumsCount
            NULL,                                             // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStreamCombined), // DataRangesCount
            PinDataRangePointersStreamCombined,               // DataRanges
            KSPIN_DATAFLOW_OUT,                               // DataFlow
            KSPIN_COMMUNICATION_SINK,                         // Communication
            (GUID *) &KSCATEGORY_AUDIO,                       // Category
            &KSAUDFNAME_DMUSIC_MPU_IN,                        // Name
            0                                                 // Reserved
        }
    }
};

/*****************************************************************************
 * MiniportNodes
 *****************************************************************************
 * List of nodes.
 */
#define CONST_PCNODE_DESCRIPTOR(n)			{ 0, NULL, &n, NULL }
#define CONST_PCNODE_DESCRIPTOR_AUTO(n,a)	{ 0, &a, &n, NULL }
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
      CONST_PCNODE_DESCRIPTOR_AUTO(KSNODETYPE_SYNTHESIZER, AutomationSynth)
    , CONST_PCNODE_DESCRIPTOR_AUTO(KSNODETYPE_SYNTHESIZER, AutomationSynth2)
};

/*****************************************************************************
 * MiniportConnections
 *****************************************************************************
 * List of connections.
 */
enum {
      eSynthNode  = 0
    , eInputNode
};

enum {
      eFilterInputPinLeg = 0,
      eFilterInputPinDM,
      eBridgeOutputPin,
      eBridgeInputPin,
      eFilterOutputPin
};

static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{  // From                                   To
   // Node           pin                     Node           pin
    { PCFILTER_NODE, eFilterInputPinLeg,     PCFILTER_NODE, eBridgeOutputPin }      // Legacy Stream in to synth.
  , { PCFILTER_NODE, eFilterInputPinDM,      eSynthNode,    KSNODEPIN_STANDARD_IN } // DM Stream in to synth.
  , { eSynthNode,    KSNODEPIN_STANDARD_OUT, PCFILTER_NODE, eBridgeOutputPin }      // Synth to bridge out.
  , { PCFILTER_NODE, eBridgeInputPin,        eInputNode,    KSNODEPIN_STANDARD_IN } // Bridge in to input.
  , { eInputNode,    KSNODEPIN_STANDARD_OUT, PCFILTER_NODE, eFilterOutputPin }      // Input to DM/Legacy Stream out.
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport filter description.
 */
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories
};

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::GetDescription()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP
CMiniportDMusUART::
GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_BLAB,("GetDescription"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CreateMiniportDMusUART()
 *****************************************************************************
 * Creates a MPU-401 miniport driver for the adapter.  This uses a
 * macro from STDUNK.H to do all the work.
 */
NTSTATUS
CreateMiniportDMusUART
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CreateMiniportDMusUART"));
    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportDMusUART,Unknown,UnknownOuter,PoolType);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::ProcessResources()
 *****************************************************************************
 * Processes the resource list, setting up helper objects accordingly.
 */
NTSTATUS
CMiniportDMusUART::
ProcessResources
(
    IN      PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_BLAB,("ProcessResources"));
    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }
    //
    // Get counts for the types of resources.
    //
    ULONG   countIO     = ResourceList->NumberOfPorts();
    ULONG   countIRQ    = ResourceList->NumberOfInterrupts();
    ULONG   countDMA    = ResourceList->NumberOfDmas();
    ULONG   lengthIO    = ResourceList->FindTranslatedPort(0)->u.Port.Length;

#if (DBG)
    _DbgPrintF(DEBUGLVL_VERBOSE,("Starting MPU401 Port 0x%X",
        ResourceList->FindTranslatedPort(0)->u.Port.Start.LowPart) );
#endif

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make sure we have the expected number of resources.
    //
    if  (   (countIO != 1)
        ||  (countIRQ  > 1)
        ||  (countDMA != 0)
        ||  (lengthIO == 0)
        )
    {
        _DbgPrintF(DEBUGLVL_TERSE,("Unknown ResourceList configuraton"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Get the port address.
        //
        m_pPortBase =
            PUCHAR(ResourceList->FindTranslatedPort(0)->u.Port.Start.LowPart);

        ntStatus = InitializeHardware(m_pInterruptSync,m_pPortBase);
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CMiniportDMusUART::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("Miniport::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportDMus))
    {
        *Object = PVOID(PMINIPORTDMUS(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::~CMiniportDMusUART()
 *****************************************************************************
 * Destructor.
 */
CMiniportDMusUART::~CMiniportDMusUART(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("~CMiniportDMusUART"));

    ASSERT(0 == m_NumCaptureStreams);
    ASSERT(0 == m_NumRenderStreams);

    //  reset the HW so we don't get anymore interrupts
    if (m_UseIRQ && m_pInterruptSync)
    {
        (void) m_pInterruptSync->CallSynchronizedRoutine(InitMPU,PVOID(m_pPortBase));
    }
    else
    {
        (void) InitMPU(NULL,PVOID(m_pPortBase));
    }

    if (m_pInterruptSync)
    {
//        m_pInterruptSync->Disconnect();
        m_pInterruptSync->Release();
        m_pInterruptSync = NULL;
    }
    if (m_pServiceGroup)
    {
        m_pServiceGroup->Release();
        m_pServiceGroup = NULL;
    }
    if (m_pPort)
    {
        m_pPort->Release();
        m_pPort = NULL;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::Init()
 *****************************************************************************
 * Initializes a the miniport.
 */
STDMETHODIMP
CMiniportDMusUART::
Init
(
    IN	    PUNKNOWN	    UnknownInterruptSync    OPTIONAL,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTDMUS       Port_,
    OUT     PSERVICEGROUP * ServiceGroup
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    ASSERT(Port_);
    ASSERT(ServiceGroup);

    _DbgPrintF(DEBUGLVL_BLAB,("Init"));

    m_pPortBase = 0;
    //
    // AddRef() is required because we are keeping this pointer.
    //
    m_pPort = Port_;
    m_pPort->AddRef();

    for (ULONG bufferCount = 0;bufferCount < kMPUInputBufferSize;bufferCount++)
    {
        m_MPUInputBuffer[bufferCount] = 0;
    }
    m_MPUInputBufferHead = 0;
    m_MPUInputBufferTail = 0;
    m_InputTimeStamp = 0;
    m_KSStateInput = KSSTATE_STOP;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    m_NumRenderStreams = 0;
    m_NumCaptureStreams = 0;

    m_UseIRQ = TRUE;
    if (ResourceList->NumberOfInterrupts() == 0)
    {
        m_UseIRQ = FALSE;
    }

    ntStatus = PcNewServiceGroup(&m_pServiceGroup,NULL);
    if (NT_SUCCESS(ntStatus) && !m_pServiceGroup)   //  keep any error
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus))
    {
        *ServiceGroup = m_pServiceGroup;
        m_pServiceGroup->AddRef();

		//
		// Register the service group with the port early so the port is
		// prepared to handle interrupts.
		//
		m_pPort->RegisterServiceGroup(m_pServiceGroup);
    }

    if (NT_SUCCESS(ntStatus) && m_UseIRQ)
    {
/*
        //
        //  Due to a bug in the InterruptSync design, we shouldn't share
        //  the interrupt sync object.  Whoever goes away first 
        //  will disconnect it, and the other points off into nowhere.
        //
        //  Instead we generate our own interrupt sync object.
        //
        UnknownInterruptSync = NULL;
*/
        if (UnknownInterruptSync)
        {
            ntStatus = 
                UnknownInterruptSync->QueryInterface
                (
                    IID_IInterruptSync,
                    (PVOID *) &m_pInterruptSync
                );

            if (!m_pInterruptSync && NT_SUCCESS(ntStatus))  //  keep any error
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            if (NT_SUCCESS(ntStatus))
            {                                                                           //  run this ISR first
                ntStatus = m_pInterruptSync->
                    RegisterServiceRoutine(DMusMPUInterruptServiceRoutine,PVOID(this),TRUE);
            }

        }
        else
        {   // create our own interruptsync mechanism.
            ntStatus = 
                PcNewInterruptSync
                (
                    &m_pInterruptSync,
                    NULL,
                    ResourceList,
                    0,                          // Resource Index
                    InterruptSyncModeNormal     // Run ISRs once until we get SUCCESS
                );

            if (!m_pInterruptSync && NT_SUCCESS(ntStatus))    //  keep any error
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_pInterruptSync->RegisterServiceRoutine(
                    DMusMPUInterruptServiceRoutine,
                    PVOID(this),
                    TRUE);          //  run this ISR first
            }
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_pInterruptSync->Connect();
            }
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ProcessResources(ResourceList);
    }

    if (!NT_SUCCESS(ntStatus))
    {
        //
        // clean up our mess
        //

        // clean up the interrupt sync
        if( m_pInterruptSync )
        {
//            m_pInterruptSync->Disconnect();
            m_pInterruptSync->Release();
            m_pInterruptSync = NULL;
        }

        // clean up the service group
        if( m_pServiceGroup )
        {
            m_pServiceGroup->Release();
            m_pServiceGroup = NULL;
        }
        (*ServiceGroup) = NULL; 

        // release the port
        m_pPort->Release();
        m_pPort = NULL;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::NewStream()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP 
CMiniportDMusUART::
NewStream
(
    OUT     PMXF                  * MXF,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   PinID,
    IN      DMUS_STREAM_TYPE        StreamType,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP         * ServiceGroup,
    IN      PAllocatorMXF           AllocatorMXF,
    IN      PMASTERCLOCK            MasterClock,
    OUT     PULONGLONG              SchedulePreFetch
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("NewStream"));
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // In 100 ns, we want stuff as soon as it comes in
    //
    *SchedulePreFetch = 0;

    // if we don't have any streams already open, get the hardware ready.
    if ((!m_NumCaptureStreams) && (!m_NumRenderStreams))
    {
        (void) ResetHardware(m_pPortBase);
    }

    if  (   ((m_NumCaptureStreams < kMaxNumCaptureStreams) 
            && (StreamType == DMUS_STREAM_MIDI_CAPTURE))
        ||  ((m_NumRenderStreams < kMaxNumLegacyRenderStreams + kMaxNumDMusicRenderStreams)
            && (StreamType == DMUS_STREAM_MIDI_RENDER))
        )
    {
        CMiniportDMusUARTStream *pStream =
            new(PoolType) CMiniportDMusUARTStream(OuterUnknown);

        if (pStream)
        {
            pStream->AddRef();

            ntStatus = 
                pStream->Init(this,m_pPortBase,(StreamType == DMUS_STREAM_MIDI_CAPTURE),AllocatorMXF,MasterClock);

            if (NT_SUCCESS(ntStatus))
            {
                *MXF = PMXF(pStream);
                (*MXF)->AddRef();

                if (StreamType == DMUS_STREAM_MIDI_CAPTURE)
                {
                    m_NumCaptureStreams++;
                    *ServiceGroup = m_pServiceGroup;
                    (*ServiceGroup)->AddRef();
                }
                else
                {
                    m_NumRenderStreams++;
                    *ServiceGroup = NULL;
                }
            }

            pStream->Release();
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        if (StreamType == DMUS_STREAM_MIDI_CAPTURE)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream failed, too many capture streams"));
        }
        else if (StreamType == DMUS_STREAM_MIDI_RENDER)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream failed, too many render streams"));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream invalid stream type"));
        }
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CMiniportDMusUARTStream::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("Stream::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::~CMiniportDMusUARTStream()
 *****************************************************************************
 * Destructs a stream.
 */
CMiniportDMusUARTStream::~CMiniportDMusUARTStream(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("~CMiniportDMusUARTStream"));

    KeCancelTimer(&m_TimerEvent);

    if (m_DMKEvtQueue)
    {
        if (m_AllocatorMXF)
        {
            m_AllocatorMXF->PutMessage(m_DMKEvtQueue);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_ERROR,("~CMiniportDMusUARTStream, no allocator, can't flush DMKEvts"));
        }
        m_DMKEvtQueue = NULL;
    }
    if (m_AllocatorMXF)
    {
        m_AllocatorMXF->Release();
        m_AllocatorMXF = NULL;
    }

    if (m_pMiniport)
    {
        if (m_fCapture)
        {
            m_pMiniport->m_NumCaptureStreams--;
        }
        else
        {
            m_pMiniport->m_NumRenderStreams--;
        }

        m_pMiniport->Release();
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::Init()
 *****************************************************************************
 * Initializes a stream.
 */
STDMETHODIMP 
CMiniportDMusUARTStream::
Init
(
    IN      CMiniportDMusUART * pMiniport,
    IN      PUCHAR              pPortBase,
    IN      BOOLEAN             fCapture,
    IN      PAllocatorMXF       allocatorMXF,
    IN      PMASTERCLOCK        masterClock
)
{
    PAGED_CODE();

    ASSERT(pMiniport);
    ASSERT(pPortBase);

    _DbgPrintF(DEBUGLVL_BLAB,("Init"));

    m_NumFailedMPUTries = 0;
    m_TimerQueued = FALSE;
    KeInitializeSpinLock(&m_DpcSpinLock);
    m_pMiniport = pMiniport;
    m_pMiniport->AddRef();

    pMiniport->m_MasterClock = masterClock;

    m_pPortBase = pPortBase;
    m_fCapture = fCapture;

    m_SnapshotTimeStamp = 0;
    m_DMKEvtQueue = NULL;
    m_DMKEvtOffset = 0;

    m_NumberOfRetries = 0;

    if (allocatorMXF)
    {
        allocatorMXF->AddRef();
        m_AllocatorMXF = allocatorMXF;
        m_sinkMXF = m_AllocatorMXF;
    }
    else
    {
        return STATUS_INVALID_PARAMETER;
    }

    KeInitializeDpc
    (
        &m_Dpc,
        &::DMusUARTTimerDPC,
        PVOID(this)
    );
    KeInitializeTimer(&m_TimerEvent);

    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::SetState()
 *****************************************************************************
 * Sets the state of the channel.
 */
STDMETHODIMP
CMiniportDMusUARTStream::
SetState
(
    IN      KSSTATE     NewState
)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("SetState %d",NewState));

    if (NewState == KSSTATE_RUN)
    {

#if MartinTestCaptureHack
        gJustSetToRun = TRUE;
#endif //   MartinTestCaptureHack


        LARGE_INTEGER timeDue100ns;
        timeDue100ns.QuadPart = 0;
        KeSetTimer(&m_TimerEvent,timeDue100ns,&m_Dpc);
    }
    
    if (m_fCapture)
    {
        m_pMiniport->m_KSStateInput = NewState;
        if (NewState == KSSTATE_STOP)   //  STOPping
        {
            m_pMiniport->m_MPUInputBufferHead = 0;   // Previously read bytes are discarded.
            m_pMiniport->m_MPUInputBufferTail = 0;   // The entire FIFO is available.
        }
    }
    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUART::Service()
 *****************************************************************************
 * DPC-mode service call from the port.
 */
STDMETHODIMP_(void) 
CMiniportDMusUART::
Service
(   void
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("Service"));
    if (!m_NumCaptureStreams)
    {
        //  we should never get here....
        //  if we do, we must have read some trash,
        //  so just reset the input FIFO
        m_MPUInputBufferTail = m_MPUInputBufferHead = 0;
    }
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::ConnectOutput()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
NTSTATUS 
CMiniportDMusUARTStream::
ConnectOutput(PMXF sinkMXF)
{
    if (m_fCapture)
    {
        if ((sinkMXF) && (m_sinkMXF == m_AllocatorMXF))
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ConnectOutput"));
            m_sinkMXF = sinkMXF;
            return STATUS_SUCCESS;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ConnectOutput failed"));
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("ConnectOutput called on renderer; failed"));
    }
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::DisconnectOutput()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
NTSTATUS 
CMiniportDMusUARTStream::
DisconnectOutput(PMXF sinkMXF)
{
    if (m_fCapture)
    {
        if ((m_sinkMXF == sinkMXF) || (!sinkMXF))
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("DisconnectOutput"));
            m_sinkMXF = m_AllocatorMXF;
            return STATUS_SUCCESS;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("DisconnectOutput failed"));
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("DisconnectOutput called on renderer; failed"));
    }
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::PutMessage()
 *****************************************************************************
 * Writes an outgoing MIDI message.
 * We don't sort a new message into the queue -- we append it.
 * This is fine, since the sequencer feeds us sequenced data.  
 * Timestamps will ascend by design.
 */
NTSTATUS CMiniportDMusUARTStream::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PDMUS_KERNEL_EVENT aDMKEvt;
    
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (!m_fCapture)
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("PutMessage to render stream"));
        if (pDMKEvt)
        {
            KeAcquireSpinLockAtDpcLevel(&m_DpcSpinLock);
            if (m_DMKEvtQueue)  
            {
                aDMKEvt = m_DMKEvtQueue;            //  put pDMKEvt in event queue 

                while (aDMKEvt->pNextEvt)
                {           
                    aDMKEvt = aDMKEvt->pNextEvt;
                }
                aDMKEvt->pNextEvt = pDMKEvt;        //  here is end of queue
            }
            else                                    //  currently nothing in queue
            {
                m_DMKEvtQueue = pDMKEvt;
                if (m_DMKEvtOffset)
                {
                    _DbgPrintF(DEBUGLVL_ERROR, ("PutMessage  Nothing in the queue, but m_DMKEvtOffset == %d",m_DMKEvtOffset));
                    m_DMKEvtOffset = 0;
                }
            }
            KeReleaseSpinLockFromDpcLevel(&m_DpcSpinLock);
        }
        if (!m_TimerQueued)
        {
            (void) ConsumeEvents();
        }
    }
    else    //  capture
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("PutMessage to capture stream"));
        ASSERT(NULL == pDMKEvt);

        SourceEvtsToPort();
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::ConsumeEvents()
 *****************************************************************************
 * Attempts to empty the render message queue.  
 * Called either from DPC timer or upon IRP submittal.
//  TODO: support packages right
//  process the package (actually, should do this above.
//  treat the package as a list fragment that shouldn't be sorted.
//  better yet, go through each event in the package, and when
//  an event is exhausted, delete it and decrement m_offset.
 */
NTSTATUS CMiniportDMusUARTStream::ConsumeEvents(void)
{
    PDMUS_KERNEL_EVENT aDMKEvt;

    NTSTATUS        ntStatus = STATUS_SUCCESS;
    ULONG           bytesRemaining = 0,bytesWritten = 0;
    LARGE_INTEGER   aMillisecIn100ns;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    KeAcquireSpinLockAtDpcLevel(&m_DpcSpinLock);

    m_TimerQueued = FALSE;
    while (m_DMKEvtQueue)                   //  do we have anything to play at all?
    {
        aDMKEvt = m_DMKEvtQueue;                            //  event we try to play
        if (aDMKEvt->cbEvent)
        {
            ASSERT(m_DMKEvtOffset >= 0);
            if (m_DMKEvtOffset < 0)
            {
                m_DMKEvtOffset = 0;
            }
            bytesRemaining = aDMKEvt->cbEvent - m_DMKEvtOffset; //  number of bytes left in this evt

            ASSERT(bytesRemaining > 0);
            if (bytesRemaining <= 0)
            {
                bytesRemaining = aDMKEvt->cbEvent;
            }

            if (aDMKEvt->cbEvent <= sizeof(PBYTE))                //  short message
            {
                _DbgPrintF(DEBUGLVL_BLAB, ("ConsumeEvents(%02x%02x%02x%02x)",aDMKEvt->uData.abData[0],aDMKEvt->uData.abData[1],aDMKEvt->uData.abData[2],aDMKEvt->uData.abData[3]));
                ntStatus = Write(aDMKEvt->uData.abData + m_DMKEvtOffset,bytesRemaining,&bytesWritten);
            }
            else if (PACKAGE_EVT(aDMKEvt))
            {
                ASSERT(m_DMKEvtOffset == 0);
                m_DMKEvtOffset = 0;
                _DbgPrintF(DEBUGLVL_BLAB, ("ConsumeEvents(Package)"));
    
                ntStatus = (PutMessage(aDMKEvt->uData.pPackageEvt));

                // null this because we are about to throw it in the allocator
                aDMKEvt->uData.pPackageEvt = NULL;
                aDMKEvt->cbEvent = 0;
                bytesWritten = bytesRemaining;
            }
            else                //  SysEx message
            {
                _DbgPrintF(DEBUGLVL_BLAB, ("ConsumeEvents(%02x%02x%02x%02x)",aDMKEvt->uData.pbData[0],aDMKEvt->uData.pbData[1],aDMKEvt->uData.pbData[2],aDMKEvt->uData.pbData[3]));

                ntStatus = Write(aDMKEvt->uData.pbData + m_DMKEvtOffset,bytesRemaining,&bytesWritten);
            }
        }   //  if (aDMKEvt->cbEvent)
        if (STATUS_SUCCESS != ntStatus)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ConsumeEvents: Write returned 0x%08x",ntStatus));
            bytesWritten = bytesRemaining;  //  just bail on this event and try next time
        }
        
        ASSERT(bytesWritten <= bytesRemaining);
        if (bytesWritten == bytesRemaining)
        {
            m_DMKEvtQueue = m_DMKEvtQueue->pNextEvt;
            aDMKEvt->pNextEvt = NULL;

            m_AllocatorMXF->PutMessage(aDMKEvt);    //  throw back in free pool
            m_DMKEvtOffset = 0;                     //  start fresh on next evt
            m_NumberOfRetries = 0;
        }           //  but wait ... there's more!
        else        //  our FIFO is full for now.
        {
            //  update our offset by that amount we did write
            m_DMKEvtOffset += bytesWritten;
            ASSERT(m_DMKEvtOffset < aDMKEvt->cbEvent);

            _DbgPrintF(DEBUGLVL_BLAB,("ConsumeEvents tried %d, wrote %d, at offset %d",bytesRemaining,bytesWritten,m_DMKEvtOffset));
            aMillisecIn100ns.QuadPart = -(kOneMillisec);    //  set timer, come back later
            m_TimerQueued = TRUE;
            m_NumberOfRetries++;
            ntStatus = KeSetTimer( &m_TimerEvent, aMillisecIn100ns, &m_Dpc );
            break;
        }   //  we didn't write it all
    }       //  go back, Jack, do it again (while m_DMKEvtQueue)
    KeReleaseSpinLockFromDpcLevel(&m_DpcSpinLock);
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::HandlePortParams()
 *****************************************************************************
 * Writes an outgoing MIDI message.
 */
NTSTATUS 
CMiniportDMusUARTStream::
HandlePortParams
(
    IN      PPCPROPERTY_REQUEST     pRequest
)
{
    PAGED_CODE();

    if (pRequest->Verb & KSPROPERTY_TYPE_SET)
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    else if (pRequest->ValueSize < sizeof(SYNTH_PORTPARAMS) ||
             pRequest->InstanceSize < sizeof(SYNTH_PORTPARAMS) || 
             pRequest->Value == NULL)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportDMusUARTStream::HandlePortParams STATUS_BUFFER_TOO_SMALL"));
        pRequest->ValueSize = sizeof(SYNTH_PORTPARAMS);
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    RtlCopyMemory(pRequest->Value, pRequest->Instance, sizeof(SYNTH_PORTPARAMS));

    pRequest->ValueSize = sizeof(SYNTH_PORTPARAMS);

    PSYNTH_PORTPARAMS Params = (PSYNTH_PORTPARAMS)pRequest->Value;

    if (Params->ValidParams & ~SYNTH_PORTPARAMS_CHANNELGROUPS)
    {
        Params->ValidParams &= SYNTH_PORTPARAMS_CHANNELGROUPS;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_CHANNELGROUPS))
    {
        Params->ChannelGroups = 1;
    }
    else if (Params->ChannelGroups != 1)
    {
        Params->ChannelGroups = 1;
    }

    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * DMusTimerDPC()
 *****************************************************************************
 * The timer DPC callback. Thunks to a C++ member function.
 * This is called by the OS in response to the DirectMusic pin
 * wanting to wakeup later to process more DirectMusic stuff.
 */
VOID 
NTAPI
DMusUARTTimerDPC
(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
)
{
    ASSERT(DeferredContext);

    CMiniportDMusUARTStream *aStream;
    aStream = (CMiniportDMusUARTStream *) DeferredContext;
    if (aStream)
    {
#if MartinTestCaptureHack
        PDMUS_KERNEL_EVENT  pDMKEvt,pDMKEvt2;

        if (aStream->m_fCapture && gJustSetToRun)
        {
            REFERENCE_TIME rfTime;

            gJustSetToRun = FALSE;

            (void) aStream->m_AllocatorMXF->GetMessage(&pDMKEvt);
            if (pDMKEvt)
            {
                (void) aStream->m_AllocatorMXF->GetBuffer(&(pDMKEvt->uData.pbData));
                pDMKEvt->cbEvent = 7;
                pDMKEvt->usChannelGroup = 1;
                pDMKEvt->usFlags = DMUS_KEF_EVENT_INCOMPLETE;
                pDMKEvt->ullPresTime100ns = 0x13;
                pDMKEvt->pNextEvt = NULL;
                pDMKEvt->uData.pbData[0] = 0xF6;
                pDMKEvt->uData.pbData[1] = 0xF6;
                pDMKEvt->uData.pbData[2] = 0xE0;
                pDMKEvt->uData.pbData[3] = 0xE0;
                pDMKEvt->uData.pbData[4] = 0xF2;
                pDMKEvt->uData.pbData[5] = 0xF0;
                pDMKEvt->uData.pbData[6] = 0xF6;
                aStream->m_sinkMXF->PutMessage(pDMKEvt);
            }

            (void) aStream->m_AllocatorMXF->GetMessage(&pDMKEvt);
            if (pDMKEvt)
            {
                pDMKEvt->cbEvent = 2;
                pDMKEvt->usChannelGroup = 1;
                pDMKEvt->usFlags = DMUS_KEF_EVENT_INCOMPLETE;
                pDMKEvt->ullPresTime100ns = 0x12;
                pDMKEvt->pNextEvt = NULL;
                pDMKEvt->uData.pbData = (PBYTE) 0xF6F6;
                aStream->m_sinkMXF->PutMessage(pDMKEvt);
            }

            (void) aStream->m_AllocatorMXF->GetMessage(&pDMKEvt);
            if (pDMKEvt)
            {
                pDMKEvt->cbEvent = 4;
                pDMKEvt->usChannelGroup = 1;
                pDMKEvt->usFlags = DMUS_KEF_EVENT_INCOMPLETE;
                pDMKEvt->ullPresTime100ns = 0x0123456789abcdef;
                (void) aStream->m_AllocatorMXF->GetMessage(&pDMKEvt2);
                pDMKEvt->pNextEvt = pDMKEvt2;
                for (int count = 0;count < pDMKEvt->cbEvent;count++)
                {
                    pDMKEvt->uData.abData[count] = 0xfc+count;
                }

                if (pDMKEvt2)
                {
                    pDMKEvt2->cbEvent = 13;
                    pDMKEvt2->usChannelGroup = 1;
                    pDMKEvt2->usFlags = DMUS_KEF_EVENT_INCOMPLETE;
                    aStream->m_pMiniport->m_MasterClock->GetTime(&(pDMKEvt2->ullPresTime100ns));
                    pDMKEvt2->pNextEvt = NULL;
                    pDMKEvt2->uData.pbData = (PBYTE) ExAllocatePoolWithTag(NonPagedPool,pDMKEvt2->cbEvent,' FXM');    //  'MXF '
                    if (pDMKEvt2->uData.pbData)
                    {
                        PBYTE pbData = pDMKEvt2->uData.pbData;
                        *pbData++ = 0xf0;
                        for (int count = 2;count < pDMKEvt2->cbEvent - 1;count++,pbData++)
                        {
                            *pbData = count;
                        }
                        *pbData++ = 0xf7;
                        *pbData = 0xe0;
                    }
                }
                aStream->m_sinkMXF->PutMessage(pDMKEvt);
            }
        }
#endif  //  MartinTestCaptureHack

        _DbgPrintF(DEBUGLVL_BLAB,("DMusUARTTimerDPC"));
        if (false == aStream->m_fCapture)
        {
            (void) aStream->ConsumeEvents();
        }
        //  ignores return value!
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * DirectMusic properties
 *****************************************************************************
 *  Properties concerning implementations of DLS
 */
NTSTATUS PropertyHandler_Synth_Dls
(
    IN      PPCPROPERTY_REQUEST     pRequest
)
{
    NTSTATUS    ntStatus;

    PAGED_CODE();

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        if (pRequest->ValueSize >= sizeof(ULONG) &&  
            pRequest->Value != NULL)
        {
            // if return buffer can hold a ULONG, return the access flags
            PULONG AccessFlags = PULONG(pRequest->Value);

            *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                           KSPROPERTY_TYPE_GET |
                           KSPROPERTY_TYPE_SET;

            ntStatus = STATUS_SUCCESS;                    
        }
        else
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        // set the return value size
        pRequest->ValueSize = sizeof(ULONG);
    }
    else
    {
        ntStatus = STATUS_SUCCESS;
        switch(pRequest->PropertyItem->Id)
        {
            case KSPROPERTY_SYNTH_DLS_DOWNLOAD:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth_Dls:KSPROPERTY_SYNTH_DLS_DOWNLOAD"));
               break;

            case KSPROPERTY_SYNTH_DLS_UNLOAD:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth_Dls:KSPROPERTY_SYNTH_DLS_UNLOAD"));
               break;

            case KSPROPERTY_SYNTH_DLS_COMPACT:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth_Dls:KSPROPERTY_SYNTH_DLS_COMPACT"));
               break;

            case KSPROPERTY_SYNTH_DLS_APPEND:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth_Dls:KSPROPERTY_SYNTH_DLS_APPEND"));
               break;

            default:
                _DbgPrintF(DEBUGLVL_TERSE,("Unhandled property in PropertyHandler_Synth_Dls"));
                break;
        }
    }    
    return ntStatus;
}

#pragma code_seg("PAGE")
/*
 *  Properties concerning synthesizer functions.
 */
const WCHAR wszDescription[] = L"Microsoft MPU-401 (WDM)";

NTSTATUS PropertyHandler_Synth
(
    IN      PPCPROPERTY_REQUEST     pRequest
)
{
    NTSTATUS    ntStatus;

    PAGED_CODE();

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        if (pRequest->ValueSize >= sizeof(ULONG) &&  
            pRequest->Value != NULL)
        {
            // if return buffer can hold a ULONG, return the access flags
            PULONG AccessFlags = PULONG(pRequest->Value);

            *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT;
            switch (pRequest->PropertyItem->Id)
            {
                case KSPROPERTY_SYNTH_VOLUME:
                case KSPROPERTY_SYNTH_VOLUMEBOOST:
                case KSPROPERTY_SYNTH_CAPS:
                case KSPROPERTY_SYNTH_CHANNELGROUPS:
                case KSPROPERTY_SYNTH_VOICEPRIORITY:
                case KSPROPERTY_SYNTH_LATENCYCLOCK:
                case KSPROPERTY_SYNTH_PORTPARAMETERS:
                    *AccessFlags |= KSPROPERTY_TYPE_GET;
            }
            switch (pRequest->PropertyItem->Id)
            {
                case KSPROPERTY_SYNTH_VOLUME:
                case KSPROPERTY_SYNTH_VOLUMEBOOST:
                case KSPROPERTY_SYNTH_CHANNELGROUPS:
                case KSPROPERTY_SYNTH_VOICEPRIORITY:
                    *AccessFlags |= KSPROPERTY_TYPE_SET;
            }
            ntStatus = STATUS_SUCCESS;                    
        }
        else
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        // set the return value size
        pRequest->ValueSize = sizeof(ULONG);
    }
    else
    {
        ntStatus = STATUS_SUCCESS;
        switch(pRequest->PropertyItem->Id)
        {
            case KSPROPERTY_SYNTH_VOLUME:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_VOLUME"));
                break;
    
            case KSPROPERTY_SYNTH_VOLUMEBOOST:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_VOLUMEBOOST"));
                break;
    
            case KSPROPERTY_SYNTH_CAPS:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_CAPS"));

                if (pRequest->Verb & KSPROPERTY_TYPE_SET)
                {
                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                }

                if (pRequest->ValueSize < sizeof(SYNTHCAPS) ||
                    pRequest->Value == NULL)
                {
                    ntStatus = STATUS_BUFFER_TOO_SMALL;
                }
                else
                {
                    SYNTHCAPS *caps = (SYNTHCAPS*)pRequest->Value;
                    RtlZeroMemory(caps, sizeof(SYNTHCAPS));
                    // XXX Different guids for different instances!
                    //
                    if (pRequest->Node == eSynthNode)
                    {
                        caps->Guid           = CLSID_MiniportDriverDMusUART;
                    }
                    else
                    {
                        caps->Guid           = CLSID_MiniportDriverDMusUARTCapture;
                    }

                    caps->Flags              = SYNTH_PC_EXTERNAL;
                    caps->MemorySize         = 0;         
                    caps->MaxChannelGroups   = 1;
                    caps->MaxVoices          = 0xFFFFFFFF;
                    caps->MaxAudioChannels   = 0xFFFFFFFF;

                    caps->EffectFlags        = 0;

                    RtlCopyMemory(caps->Description, wszDescription, sizeof(wszDescription));
                }
                // set the return value size
                pRequest->ValueSize = sizeof(SYNTHCAPS);

                break;

             case KSPROPERTY_SYNTH_PORTPARAMETERS:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_PORTPARAMETERS"));
                ASSERT(pRequest->MinorTarget);
                CMiniportDMusUARTStream *Stream;

                Stream = (CMiniportDMusUARTStream*)(pRequest->MinorTarget);
                ntStatus = Stream->HandlePortParams(pRequest);                
                break;
    
            case KSPROPERTY_SYNTH_CHANNELGROUPS:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_CHANNELGROUPS"));
                if (pRequest->ValueSize < sizeof(ULONG) ||
                    pRequest->Value == NULL)
                {
                    ntStatus = STATUS_BUFFER_TOO_SMALL;
                } 
                else
                {
                    *(PULONG)(pRequest->Value) = 1;
                }
                pRequest->ValueSize = sizeof(ULONG);                    
                break;

            case KSPROPERTY_SYNTH_VOICEPRIORITY:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_VOICEPRIORITY"));
                break;
    
            case KSPROPERTY_SYNTH_LATENCYCLOCK:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_LATENCYCLOCK"));

                if (pRequest->Verb & KSPROPERTY_TYPE_GET)
                {
                    if (pRequest->ValueSize >= sizeof(ULONGLONG) && 
                        pRequest->Value != NULL)
                    {
                        CMiniportDMusUARTStream *aStream;

                        aStream = (CMiniportDMusUARTStream*)(pRequest->MinorTarget);
                        if (aStream 
                         && aStream->m_pMiniport 
                         && aStream->m_pMiniport->m_MasterClock)
                        {
                            ntStatus = aStream->m_pMiniport->m_MasterClock->
                                            GetTime((REFERENCE_TIME *)(pRequest->Value));
                        }
                        else
                        {
                            *(REFERENCE_TIME *)(pRequest->Value) = 0;
                            ntStatus = STATUS_INVALID_PARAMETER;
                        }
                    }
                    else
                    {
                        ntStatus = STATUS_BUFFER_TOO_SMALL;
                    }
                    pRequest->ValueSize = sizeof(ULONGLONG);
                }
                else
                {
                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
                break;

            default:
                _DbgPrintF(DEBUGLVL_TERSE,("Unhandled property in PropertyHandler_Synth"));
                break;
        }
    }
    return ntStatus;
}

#pragma code_seg()

=== dmusuart/mpu.cpp ===
/*****************************************************************************
 * MPU.cpp - UART miniport implementation
 *****************************************************************************
 * Copyright (c) Microsoft Corporation 1998-1999.  All rights reserved.
 *
 *      Sept 98    MartinP .
 */

#include "private.h"
#include "ksdebug.h"

#define STR_MODULENAME "DMusUART:MPU: "

#define UartFifoOkForWrite(status)  ((status & MPU401_DRR) == 0)
#define UartFifoOkForRead(status)   ((status & MPU401_DSR) == 0)

typedef struct
{
    CMiniportDMusUART  *Miniport;
    PUCHAR              PortBase;
    PVOID               BufferAddress;
    ULONG               Length;
    PULONG              BytesRead;
}
SYNCWRITECONTEXT, *PSYNCWRITECONTEXT;

BOOLEAN  TryMPU(IN PUCHAR PortBase);
NTSTATUS WriteMPU(IN PUCHAR PortBase,IN BOOLEAN IsCommand,IN UCHAR Value);

#pragma code_seg("PAGE")
//  make sure we're in UART mode
NTSTATUS ResetHardware(PUCHAR portBase)
{
    PAGED_CODE();

    return WriteMPU(portBase,COMMAND,MPU401_CMD_UART);
}

#pragma code_seg("PAGE")
//
// We initialize the UART with interrupts suppressed so we don't
// try to service the chip prematurely.
//
NTSTATUS CMiniportDMusUART::InitializeHardware(PINTERRUPTSYNC interruptSync,PUCHAR portBase)
{
    PAGED_CODE();

    NTSTATUS    ntStatus;
    if (m_UseIRQ)
    {
        ntStatus = interruptSync->CallSynchronizedRoutine(InitMPU,PVOID(portBase));
    }
    else
    {
        ntStatus = InitMPU(NULL,PVOID(portBase));
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Start the UART (this should trigger an interrupt).
        //
        ntStatus = ResetHardware(portBase);
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("*** InitMPU returned with ntStatus 0x%08x ***",ntStatus));
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * InitMPU()
 *****************************************************************************
 * Synchronized routine to initialize the MPU401.
 */
NTSTATUS
InitMPU
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("InitMPU"));
    if (!DynamicContext)
    {
        return STATUS_INVALID_PARAMETER_2;
    }
        
    PUCHAR      portBase = PUCHAR(DynamicContext);
    UCHAR       status;
    ULONGLONG   startTime;
    BOOLEAN     success;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    
    //
    // Reset the card (puts it into "smart mode")
    //
    ntStatus = WriteMPU(portBase,COMMAND,MPU401_CMD_RESET);

    // wait for the acknowledgement
    // NOTE: When the Ack arrives, it will trigger an interrupt.  
    //       Normally the DPC routine would read in the ack byte and we
    //       would never see it, however since we have the hardware locked (HwEnter),
    //       we can read the port before the DPC can and thus we receive the Ack.
    startTime = PcGetTimeInterval(0);
    success = FALSE;
    while(PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        status = READ_PORT_UCHAR(portBase + MPU401_REG_STATUS);
        
        if (UartFifoOkForRead(status))                      // Is data waiting?
        {
            READ_PORT_UCHAR(portBase + MPU401_REG_DATA);    // yep.. read ACK 
            success = TRUE;                                 // don't need to do more 
            break;
        }
        KeStallExecutionProcessor(25);  //  microseconds
    }
#if (DBG)
    if (!success)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("First attempt to reset the MPU didn't get ACKed.\n"));
    }
#endif  //  (DBG)

    // NOTE: We cannot check the ACK byte because if the card was already in
    // UART mode it will not send an ACK but it will reset.

    // reset the card again
    (void) WriteMPU(portBase,COMMAND,MPU401_CMD_RESET);

                                    // wait for ack (again)
    startTime = PcGetTimeInterval(0); // This might take a while
    BYTE dataByte = 0;
    success = FALSE;
    while (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        status = READ_PORT_UCHAR(portBase + MPU401_REG_STATUS);
        if (UartFifoOkForRead(status))                              // Is data waiting?
        {
            dataByte = READ_PORT_UCHAR(portBase + MPU401_REG_DATA); // yep.. read ACK
            success = TRUE;                                         // don't need to do more
            break;
        }
        KeStallExecutionProcessor(25);
    }

    if ((0xFE != dataByte) || !success)   // Did we succeed? If no second ACK, something is hosed  
    {                       
        _DbgPrintF(DEBUGLVL_TERSE,("Second attempt to reset the MPU didn't get ACKed.\n"));
        _DbgPrintF(DEBUGLVL_TERSE,("Init Reset failure error. Ack = %X", ULONG(dataByte) ) );
        ntStatus = STATUS_IO_DEVICE_ERROR;
    }
    
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::Write()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
STDMETHODIMP
CMiniportDMusUARTStream::
Write
(
    IN      PVOID       BufferAddress,
    IN      ULONG       Length,
    OUT     PULONG      BytesWritten
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("Write"));
    ASSERT(BytesWritten);
    if (!BufferAddress)
    {
        Length = 0;
    }

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (!m_fCapture)
    {
        PUCHAR  pMidiData;
        ULONG   count;

        count = 0;
        pMidiData = PUCHAR(BufferAddress);

        if (Length)
        {
            SYNCWRITECONTEXT context;
            context.Miniport        = (m_pMiniport);
            context.PortBase        = m_pPortBase;
            context.BufferAddress   = pMidiData;
            context.Length          = Length;
            context.BytesRead       = &count;

            if (m_pMiniport->m_UseIRQ)
            {
                ntStatus = m_pMiniport->m_pInterruptSync->
                                CallSynchronizedRoutine(SynchronizedDMusMPUWrite,PVOID(&context));
            }
            else    //  !m_UseIRQ
            {
                ntStatus = SynchronizedDMusMPUWrite(NULL,PVOID(&context));
            }       //  !m_UseIRQ

            if (count == 0)
            {
                m_NumFailedMPUTries++;
                if (m_NumFailedMPUTries >= 100)
                {
                    ntStatus = STATUS_IO_DEVICE_ERROR;
                    m_NumFailedMPUTries = 0;
                }
            }
            else
            {
                m_NumFailedMPUTries = 0;
            }
        }           //  if we have data at all
        *BytesWritten = count;
    }
    else    //  called write on the read stream
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * SynchronizedDMusMPUWrite()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
NTSTATUS
SynchronizedDMusMPUWrite
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           syncWriteContext
)
{
    PSYNCWRITECONTEXT context;
    context = (PSYNCWRITECONTEXT)syncWriteContext;
    ASSERT(context->Miniport);
    ASSERT(context->PortBase);
    ASSERT(context->BufferAddress);
    ASSERT(context->Length);
    ASSERT(context->BytesRead);

    PUCHAR  pChar = PUCHAR(context->BufferAddress);
    NTSTATUS ntStatus,readStatus;
    ntStatus = STATUS_SUCCESS;
    //
    // while we're not there yet, and
    // while we don't have to wait on an aligned byte (including 0)
    // (we never wait on a byte.  Better to come back later)
    readStatus = DMusMPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
    while (  (*(context->BytesRead) < context->Length)
          && (  TryMPU(context->PortBase) 
             || (*(context->BytesRead)%3)
          )  )
    {
        ntStatus = WriteMPU(context->PortBase,DATA,*pChar);
        if (NT_SUCCESS(ntStatus))
        {
            pChar++;
            *(context->BytesRead) = *(context->BytesRead) + 1;
//            readStatus = DMusMPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("SynchronizedDMusMPUWrite failed (0x%08x)",ntStatus));
            break;
        }
    }
    readStatus = DMusMPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
    return ntStatus;
}

#define kMPUPollTimeout 2

#pragma code_seg()
/*****************************************************************************
 * TryMPU()
 *****************************************************************************
 * See if the MPU401 is free.
 */
BOOLEAN
TryMPU
(
    IN      PUCHAR      PortBase
)
{
    BOOLEAN success;
    USHORT  numPolls;
    UCHAR   status;

    _DbgPrintF(DEBUGLVL_BLAB, ("TryMPU"));
    numPolls = 0;

    while (numPolls < kMPUPollTimeout)
    {
        status = READ_PORT_UCHAR(PortBase + MPU401_REG_STATUS);
                                       
        if (UartFifoOkForWrite(status)) // Is this a good time to write data?
        {
            break;
        }
        numPolls++;
    }
    if (numPolls >= kMPUPollTimeout)
    {
        success = FALSE;
        _DbgPrintF(DEBUGLVL_BLAB, ("TryMPU failed"));
    }
    else
    {
        success = TRUE;
    }

    return success;
}

#pragma code_seg()
/*****************************************************************************
 * WriteMPU()
 *****************************************************************************
 * Write a byte out to the MPU401.
 */
NTSTATUS
WriteMPU
(
    IN      PUCHAR      PortBase,
    IN      BOOLEAN     IsCommand,
    IN      UCHAR       Value
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("WriteMPU"));
    NTSTATUS ntStatus = STATUS_IO_DEVICE_ERROR;

    if (!PortBase)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("O: PortBase is zero\n"));
        return ntStatus;
    }
    PUCHAR deviceAddr = PortBase + MPU401_REG_DATA;

    if (IsCommand)
    {
        deviceAddr = PortBase + MPU401_REG_COMMAND;
    }

    ULONGLONG startTime = PcGetTimeInterval(0);
    
    while (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        UCHAR status
        = READ_PORT_UCHAR(PortBase + MPU401_REG_STATUS);

        if (UartFifoOkForWrite(status)) // Is this a good time to write data?
        {                               // yep (Jon comment)
            WRITE_PORT_UCHAR(deviceAddr,Value);
#if kTurnOnKdPrint
            KdPrint(("'Dm:O: %02X\n",Value));
#endif //   kTurnOnKdPrint
            _DbgPrintF(DEBUGLVL_BLAB, ("WriteMPU emitted 0x%02x",Value));
            ntStatus = STATUS_SUCCESS;
            break;
        }
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * SnapTimeStamp()
 *****************************************************************************
 *
 * At synchronized execution to ISR, copy miniport's volatile m_InputTimeStamp 
 * to stream's m_SnapshotTimeStamp and zero m_InputTimeStamp.
 *
 */
STDMETHODIMP 
SnapTimeStamp(PINTERRUPTSYNC InterruptSync,PVOID pStream)
{
    CMiniportDMusUARTStream *pMPStream = (CMiniportDMusUARTStream *)pStream;

    //  cache the timestamp
    pMPStream->m_SnapshotTimeStamp = pMPStream->m_pMiniport->m_InputTimeStamp;

    //  if the window is closed, zero the timestamp
    if (pMPStream->m_pMiniport->m_MPUInputBufferHead == 
        pMPStream->m_pMiniport->m_MPUInputBufferTail)
    {
        pMPStream->m_pMiniport->m_InputTimeStamp = 0;
    }

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportDMusUARTStream::SourceEvtsToPort()
 *****************************************************************************
 *
 * Reads incoming MIDI data, feeds into DMus events.
 * No need to touch the hardware, just read from our SW FIFO.
 *
 */
STDMETHODIMP
CMiniportDMusUARTStream::SourceEvtsToPort()
{
    NTSTATUS    ntStatus;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    _DbgPrintF(DEBUGLVL_BLAB, ("SourceEvtsToPort"));

    if (m_fCapture)
    {
        ntStatus = STATUS_SUCCESS;
        if (m_pMiniport->m_MPUInputBufferHead != m_pMiniport->m_MPUInputBufferTail)
        {
            PDMUS_KERNEL_EVENT  aDMKEvt,eventTail,eventHead = NULL;

            while (m_pMiniport->m_MPUInputBufferHead != m_pMiniport->m_MPUInputBufferTail)
            {
                (void) m_AllocatorMXF->GetMessage(&aDMKEvt);
                if (!aDMKEvt)
                {
                    _DbgPrintF(DEBUGLVL_TERSE, ("SourceEvtsToPort can't allocate DMKEvt"));
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                //  put this event at the end of the list
                if (!eventHead)
                {
                    eventHead = aDMKEvt;
                }
                else
                {
                    eventTail = eventHead;
                    while (eventTail->pNextEvt)
                    {
                        eventTail = eventTail->pNextEvt;
                    }
                    eventTail->pNextEvt = aDMKEvt;
                }
                //  read all the bytes out of the buffer, into event(s)
                for (aDMKEvt->cbEvent = 0; aDMKEvt->cbEvent < sizeof(PBYTE); aDMKEvt->cbEvent++)
                {
                    if (m_pMiniport->m_MPUInputBufferHead == m_pMiniport->m_MPUInputBufferTail)
                    {
//                        _DbgPrintF(DEBUGLVL_TERSE, ("SourceEvtsToPort m_MPUInputBufferHead met m_MPUInputBufferTail, overrun"));
                        break;
                    }
                    aDMKEvt->uData.abData[aDMKEvt->cbEvent] = m_pMiniport->m_MPUInputBuffer[m_pMiniport->m_MPUInputBufferHead];
                    m_pMiniport->m_MPUInputBufferHead++;
                    if (m_pMiniport->m_MPUInputBufferHead >= kMPUInputBufferSize)
                    {
                        m_pMiniport->m_MPUInputBufferHead = 0;
                    }
                }
            }

            if (m_pMiniport->m_UseIRQ)
            {
                ntStatus = m_pMiniport->m_pInterruptSync->CallSynchronizedRoutine(SnapTimeStamp,PVOID(this));
            }
            else    //  !m_UseIRQ
            {
                ntStatus = SnapTimeStamp(NULL,PVOID(this));
            }       //  !m_UseIRQ
            aDMKEvt = eventHead;
            while (aDMKEvt)
            {
                aDMKEvt->ullPresTime100ns = m_SnapshotTimeStamp;
                aDMKEvt->usChannelGroup = 1;
                aDMKEvt->usFlags = DMUS_KEF_EVENT_INCOMPLETE;
                aDMKEvt = aDMKEvt->pNextEvt;
            }
            (void)m_sinkMXF->PutMessage(eventHead);
        }
    }
    else    //  render stream
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("SourceEvtsToPort called on render stream"));
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * DMusMPUInterruptServiceRoutine()
 *****************************************************************************
 * ISR.
 */
NTSTATUS
DMusMPUInterruptServiceRoutine
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("DMusMPUInterruptServiceRoutine"));
    ULONGLONG   startTime;

    ASSERT(DynamicContext);

    NTSTATUS            ntStatus;
    BOOL                newBytesAvailable;
    CMiniportDMusUART   *that;
    NTSTATUS            clockStatus;

    that = (CMiniportDMusUART *) DynamicContext;
    newBytesAvailable = FALSE;
    ntStatus = STATUS_UNSUCCESSFUL;

    UCHAR portStatus = 0xff;

    //
    // Read the MPU status byte.
    //
    if (that->m_pPortBase)
    {
        portStatus =
            READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_STATUS);

        //
        // If there is outstanding work to do and there is a port-driver for
        // the MPU miniport...
        //
        if (UartFifoOkForRead(portStatus) && that->m_pPort)
        {
            startTime = PcGetTimeInterval(0);
            while ( (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50)) 
                &&  (UartFifoOkForRead(portStatus)) )
            {
                UCHAR uDest = READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_DATA);
                if (    (that->m_KSStateInput == KSSTATE_RUN) 
                    &&  (that->m_NumCaptureStreams)
                   )
                {
#if kTurnOnKdPrint
                    KdPrint(("'Dm:\t\tI: %02X\n",uDest));
#endif //   kTurnOnKdPrint
                    LONG    buffHead = that->m_MPUInputBufferHead;
                    if (   (that->m_MPUInputBufferTail + 1 == buffHead)
                        || (that->m_MPUInputBufferTail + 1 - kMPUInputBufferSize == buffHead))
                    {
                        _DbgPrintF(DEBUGLVL_TERSE,("*****MPU Input Buffer Overflow*****"));
                    }
                    else
                    {
                        if (!that->m_InputTimeStamp)
                        {
                            clockStatus = that->m_MasterClock->GetTime(&that->m_InputTimeStamp);
                            if (STATUS_SUCCESS != clockStatus)
                            {
                                _DbgPrintF(DEBUGLVL_TERSE,("GetTime failed for clock 0x%08x",that->m_MasterClock));
                            }
                        }
                        newBytesAvailable = TRUE;
                        //  ...place the data in our FIFO...
                        that->m_MPUInputBuffer[that->m_MPUInputBufferTail] = uDest;
                        ASSERT(that->m_MPUInputBufferTail < kMPUInputBufferSize);
                        
                        that->m_MPUInputBufferTail++;
                        if (that->m_MPUInputBufferTail >= kMPUInputBufferSize)
                        {
                            that->m_MPUInputBufferTail = 0;
                        }
                    } 
                }
#if kTurnOnKdPrint
                else
                {
                    KdPrint(("'Dm:\t\tI: %02X XXX\n",uDest));
                }
#endif //   kTurnOnKdPrint
                //
                // Look for more MIDI data.
                //
                portStatus =
                    READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_STATUS);
            }   //  either there's no data or we ran too long
            if (newBytesAvailable)
            {
                //
                // ...notify the MPU port driver that we have bytes.
                //
                that->m_pPort->Notify(that->m_pServiceGroup);
            }
            ntStatus = STATUS_SUCCESS;
        }
    }

    return ntStatus;
}

=== dmusuart/private.h ===
/*****************************************************************************
 * private.h - MPU-401 miniport private definitions
 *****************************************************************************
 * Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 */

#ifndef _DMUSUART_PRIVATE_H_
#define _DMUSUART_PRIVATE_H_

#include "portcls.h"
#include "stdunk.h"
#include "dmusicks.h"

#ifdef  UNDER_NT
#define kTurnOnKdPrint  (0)
#else   //  UNDER_NT
#define kTurnOnKdPrint  (1)
#endif  //  UNDER_NT

//  + for absolute / - for relative
#define kOneMillisec (10 * 1000)

//
// MPU401 ports
//
#define MPU401_REG_STATUS   0x01    // Status register
#define MPU401_DRR          0x40    // Output ready (for command or data)
                                    // if this bit is set, the output FIFO is FULL
#define MPU401_DSR          0x80    // Input ready (for data)
                                    // if this bit is set, the input FIFO is empty

#define MPU401_REG_DATA     0x00    // Data in
#define MPU401_REG_COMMAND  0x01    // Commands
#define MPU401_CMD_RESET    0xFF    // Reset command
#define MPU401_CMD_UART     0x3F    // Switch to UART mod


/*****************************************************************************
 * References forward
 */


/*****************************************************************************
 * Prototypes
 */

NTSTATUS InitMPU(IN PINTERRUPTSYNC InterruptSync,IN PVOID DynamicContext);
NTSTATUS ResetHardware(PUCHAR portBase);

NTSTATUS PropertyHandler_Synth_Dls(IN PPCPROPERTY_REQUEST);


/*****************************************************************************
 * Constants
 */

const BOOLEAN   COMMAND   = TRUE;
const BOOLEAN   DATA      = FALSE;

const LONG      kMPUInputBufferSize = 128;


/*****************************************************************************
 * Globals
 */


/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportDMusUART
 *****************************************************************************
 * MPU-401 miniport.  This object is associated with the device and is 
 * created when the device is started.  The class inherits IMiniportDMus
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportDMusUART
:   public IMiniportDMus,
    public CUnknown
{
private:
    KSSTATE         m_KSStateInput;         // Miniport state (RUN/PAUSE/ACQUIRE/STOP)
    PPORTDMUS       m_pPort;                // Callback interface.
    PUCHAR          m_pPortBase;            // Base port address.
    PINTERRUPTSYNC  m_pInterruptSync;       // Interrupt synchronization object.
    PSERVICEGROUP   m_pServiceGroup;        // Service group for capture.
    PMASTERCLOCK    m_MasterClock;          // for input data
    REFERENCE_TIME  m_InputTimeStamp;       // capture data timestamp
    USHORT          m_NumRenderStreams;     // Num active render streams.
    USHORT          m_NumCaptureStreams;    // Num active capture streams.
    LONG            m_MPUInputBufferHead;   // Index of the newest byte in the FIFO.
    LONG            m_MPUInputBufferTail;   // Index of the oldest empty space in the FIFO.
    BOOLEAN         m_UseIRQ;               // FALSE if no IRQ is used for MIDI.
    UCHAR           m_MPUInputBuffer[kMPUInputBufferSize];  // Internal SW FIFO.

/*************************************************************************
     * CMiniportDMusUART methods
     *
     * These are private member functions used internally by the object.
     * See MINIPORT.CPP for specific descriptions.
     */
    NTSTATUS ProcessResources
    (
        IN      PRESOURCELIST   ResourceList
    );
    NTSTATUS InitializeHardware(PINTERRUPTSYNC interruptSync,PUCHAR portBase);

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportDMusUART);

    ~CMiniportDMusUART();

    /*************************************************************************
     * IMiniport methods
     */
    STDMETHODIMP 
    GetDescription
    (   OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );
    STDMETHODIMP 
    DataRangeIntersection
    (   IN      ULONG           PinId
    ,   IN      PKSDATARANGE    DataRange
    ,   IN      PKSDATARANGE    MatchingDataRange
    ,   IN      ULONG           OutputBufferLength
    ,   OUT     PVOID           ResultantFormat
    ,   OUT     PULONG          ResultantFormatLength
    )
    {
        return STATUS_NOT_IMPLEMENTED;
    }

    /*************************************************************************
     * IMiniportDMus methods
     */
    STDMETHODIMP Init
    (
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTDMUS       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    );
    STDMETHODIMP NewStream
    (
        OUT     PMXF                  * Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   PinID,
        IN      DMUS_STREAM_TYPE        StreamType,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP         * ServiceGroup,
        IN      PAllocatorMXF           AllocatorMXF,
        IN      PMASTERCLOCK            MasterClock,
        OUT     PULONGLONG              SchedulePreFetch
    );
    STDMETHODIMP_(void) Service
    (   void
    );

    /*************************************************************************
     * Friends 
     */
    friend class CMiniportDMusUARTStream;
    friend NTSTATUS 
        DMusMPUInterruptServiceRoutine(PINTERRUPTSYNC InterruptSync,PVOID DynamicContext);
    friend NTSTATUS 
        SynchronizedDMusMPUWrite(PINTERRUPTSYNC InterruptSync,PVOID syncWriteContext);
    friend VOID NTAPI 
        DMusUARTTimerDPC(PKDPC Dpc,PVOID DeferredContext,PVOID SystemArgument1,PVOID SystemArgument2);
    friend NTSTATUS PropertyHandler_Synth(IN PPCPROPERTY_REQUEST);
    friend STDMETHODIMP SnapTimeStamp(PINTERRUPTSYNC InterruptSync,PVOID pStream);
};

/*****************************************************************************
 * CMiniportDMusUARTStream
 *****************************************************************************
 * MPU-401 miniport stream.  This object is associated with the pin and is
 * created when the pin is instantiated.  It inherits IMXF
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportDMusUARTStream
:   public IMXF,
    public CUnknown
{
private:
    CMiniportDMusUART * m_pMiniport;            // Parent.
    REFERENCE_TIME      m_SnapshotTimeStamp;    // Current snapshot of miniport's input timestamp.
    PUCHAR              m_pPortBase;            // Base port address.
    BOOLEAN             m_fCapture;             // Whether this is capture.
    long                m_NumFailedMPUTries;    // Deadman timeout for MPU hardware.
    PAllocatorMXF       m_AllocatorMXF;         // source/sink for DMus structs
    PMXF                m_sinkMXF;              // sink for DMus capture
    PDMUS_KERNEL_EVENT  m_DMKEvtQueue;          // queue of waiting events
    ULONG               m_NumberOfRetries;      // Number of consecutive times the h/w was busy/full
    ULONG               m_DMKEvtOffset;         // offset into the event
    KDPC                m_Dpc;                  // DPC for timer
    KTIMER              m_TimerEvent;           // timer 
    BOOL                m_TimerQueued;          // whether a timer has been set
    KSPIN_LOCK          m_DpcSpinLock;          // protects the ConsumeEvents DPC

    STDMETHODIMP SourceEvtsToPort();
    STDMETHODIMP ConsumeEvents();

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportDMusUARTStream);

    ~CMiniportDMusUARTStream();

    STDMETHODIMP Init
    (
        IN      CMiniportDMusUART * pMiniport,
        IN      PUCHAR              pPortBase,
        IN      BOOLEAN             fCapture,
        IN      PAllocatorMXF       allocatorMXF,
        IN      PMASTERCLOCK        masterClock
    );

    NTSTATUS HandlePortParams
    (
        IN      PPCPROPERTY_REQUEST     Request
    );

    /*************************************************************************
     * IMiniportStreamDMusUART methods
     */
    IMP_IMXF;

    STDMETHODIMP Write
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BytesToWrite,
        OUT     PULONG      BytesWritten
    );

    friend VOID NTAPI
    DMusUARTTimerDPC
    (
        IN      PKDPC   Dpc,
        IN      PVOID   DeferredContext,
        IN      PVOID   SystemArgument1,
        IN      PVOID   SystemArgument2
    );
    friend NTSTATUS PropertyHandler_Synth(IN PPCPROPERTY_REQUEST);
    friend STDMETHODIMP SnapTimeStamp(PINTERRUPTSYNC InterruptSync,PVOID pStream);
};
#endif  //  _DMusUART_PRIVATE_H_
=== dmusuart/sources ===
# Copyright (c) 1998-1999 Microsoft Corporation.  All rights reserved.

TARGETNAME=DMusUART
TARGETTYPE=LIBRARY
TARGETPATH=..\lib

C_DEFINES=-D_WIN32 -DUNICODE -D_UNICODE -DUNDER_NT -DDEBUG_LEVEL=DEBUGLVL_TERSE
LINKER_FLAGS=-map

INCLUDES=..\inc

MSC_WARNING_LEVEL=-W3 -WX

SOURCES=\
        miniport.cpp\
        MPU.cpp

=== fmsynth/fmsynth.htm ===
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-
1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>FMSynth</TITLE>
</HEAD>
<BODY LINK="#0000ff">

<FONT FACE="Verdana" SIZE=5><H2>FMSynth</H2>
</FONT><FONT FACE="Verdana" SIZE=2>
<P><span style="color:#FF0000;font-size:10pt;font-family:Arial">[This is preliminary 
documentation and subject to change.]</span></P>

<H3>SUMMARY</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
This sample is a MIDI FM miniport driver.  This sample provides an interface to a device that implements
OPL3-style FM synthesis.  The MIDI port driver serves as a wrapper for this miniport
driver.  Because the sample is a synthesizer, it is
for output only.  It compiles in the 64-bit environment and is compatible with Alpha and x86 platforms.<P>
Because the sample  is a PortCls client,  PortCls handles Plug and Play.  Power Management is also supported.  <P>
There are two GUIDs with which an adapter can instantiate this miniport.  The first is the normal mode, used by a vast majority of clients. However, if the audio device does not provide an analog volume control after the FM synth (such as the WSS
device), then the second GUID, which implements an FM synth with a built-in volume control, can be used.<P>


<H3>BUILDING THE SAMPLE</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>

Type <B>build</B> in the \\Ntddk\Src\Wdm\Audio\Miniport\Fmsynth directory.  A 
successful build produces Fmsynth.lib, which is a .lib file used in building the
audio adapter samples.<P>

<H3>RESOURCES</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
 This exact miniport is already included in PortCls. We have provided the source code as a starting point for those that need to augment it, as well as those that need to create completely new miniports. 
This miniport interfaces to the port driver of type MIDI. A new port, type DMUS, was introduced in Microsoft Windows 98 Second Edition (SE) and Microsoft Windows 2000.  The DMUS port provides higher functionality than the MIDI port, so if you are creating your own miniport, consider interfacing to DMUS instead of MIDI. The advantage of DMUS miniport drivers is that they are visible to DirectMusic APIs, unlike MIDI miniport drivers. Additionally, DMUS miniports are still visible to the older MIDI APIs. In short, DirectMusic miniports have the benefits of both backward compatibility and advanced functionality. 
 
<p>
Please refer to the SB16 sample to learn how to use the built-in miniport.<p>
DirectMusic kernel support is not available in Windows 98, only in Windows 98SE and Windows 2000 and later.

<H3>CODE TOUR</H3>
<H4>File Manifest</H4>
</FONT><U><PRE>File&#9;&#9;Description
</U>
Miniport.cpp&#9;Miniport driver implementation for FMSynth
Sources&#9;	Sources for build
<P>
</FONT><P ALIGN="CENTER"><A HREF="#top"><FONT FACE="Verdana" SIZE=2>Top of page</FONT></A><FONT FACE="Verdana" SIZE=2> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 WIDTH=624>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff" HEIGHT=2>
<P></TD>
</TR>
</TABLE>

<FONT FACE="MS Sans Serif" SIZE=1><P>&copy; 1999 Microsoft Corporation</FONT><FONT FACE="Verdana" SIZE=2> </P></FONT></BODY>
</HTML>

=== fmsynth/makefile ===
#############################################################################
#
#       Copyright (C) Microsoft Corporation 1991-1999
#       All Rights Reserved.
#
#       Makefile for wdm\audio\fmsynth
#
#############################################################################

## Define WIN95_BUILD to build in the memphis
## build enviroment

!IFDEF WIN95_BUILD

ROOT = ..\..\..\..\..

IS_32   = TRUE
IS_OEM  = TRUE
DEVICEDIR = fmsynth
COMMONMKFILE = $(DEVICEDIR).mk
DEPENDTARGETS = debug

!include $(ROOT)\dev\master.mk

## NT BUILD ENVIROMENT
!ELSE

#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT.
#
!INCLUDE $(NTMAKEENV)\makefile.def

!ENDIF

=== fmsynth/miniport.cpp ===
// ==============================================================================
//
// miniport.cpp - miniport driver implementation for FM synth.
// Copyright (c) Microsoft Corporation 1996-1999.  All rights reserved.
//
// ==============================================================================

#include "private.h"    // contains class definitions.

#define STR_MODULENAME "FMSynth: "


#pragma code_seg("PAGE")
// ==============================================================================
// CreateMiniportMidiFM()
// Creates a MIDI FM miniport driver.  This uses a
// macro from STDUNK.H to do all the work.
// ==============================================================================
NTSTATUS CreateMiniportMidiFM
(
OUT     PUNKNOWN *  Unknown,
IN      REFCLSID    ClassID,
IN      PUNKNOWN    UnknownOuter    OPTIONAL,
IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CreateMiniportMidiFM"));

//  expand STD_CREATE_BODY_ to take constructor(boolean) for whether to include volume
    NTSTATUS ntStatus;
    CMiniportMidiFM *p =  
        new(PoolType,'MFcP') CMiniportMidiFM(
                                 UnknownOuter,
                                 (IsEqualGUIDAligned(ClassID,CLSID_MiniportDriverFmSynthWithVol))
                             );

#ifdef DEBUG
    if (IsEqualGUIDAligned(ClassID,CLSID_MiniportDriverFmSynthWithVol))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Creating new FM miniport with volume node"));
    }
#endif
    if (p)
    {
        *Unknown = PUNKNOWN((PMINIPORTMIDI)(p));
        (*Unknown)->AddRef();
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    return ntStatus;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiFM::ProcessResources()
// Processes the resource list.
// ==============================================================================
NTSTATUS
CMiniportMidiFM::
ProcessResources
(
IN  PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::ProcessResources"));

    //
    // Get counts for the types of resources.
    //
    ULONG       countIO     = ResourceList->NumberOfPorts();
    ULONG       countIRQ    = ResourceList->NumberOfInterrupts();
    ULONG       countDMA    = ResourceList->NumberOfDmas();

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make sure we have the expected number of resources.
    //
    if  (   (countIO != 1)
        ||  (countIRQ != 0)
        ||  (countDMA != 0)
        )
    {
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Get the port address.
        //
        m_PortBase = PUCHAR(ResourceList->FindTranslatedPort(0)->u.Port.Start.LowPart);
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Port Address = 0x%X", m_PortBase));
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiFM::NonDelegatingQueryInterface()
// Obtains an interface.  This function works just like a COM QueryInterface
// call and is used if the object is not being aggregated.
// ==============================================================================
STDMETHODIMP CMiniportMidiFM::NonDelegatingQueryInterface
(
REFIID  Interface,
PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::NonDelegatingQueryInterface"));

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORT(this)));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IMiniportMidi))
    {
        *Object = PVOID(PMINIPORTMIDI(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IPowerNotify))
    {
        *Object = PVOID(PPOWERNOTIFY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN((PMINIPORT)*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg()
// ==============================================================================
// CMiniportMidiFM::~CMiniportMidiFM()
// Destructor.
// ==============================================================================
CMiniportMidiFM::~CMiniportMidiFM
(
void
)
{
    KIRQL   oldIrql;
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::~CMiniportMidiFM"));

    KeAcquireSpinLock(&m_SpinLock,&oldIrql);
    // Set silence on the device
    Opl3_BoardReset();

    KeReleaseSpinLock(&m_SpinLock,oldIrql);

    if (m_Port)
    {
        m_Port->Release();
    }
}

#pragma code_seg()
// ==============================================================================
// CMiniportMidiFM::Init()
// Initializes a the miniport.
// ==============================================================================
STDMETHODIMP
CMiniportMidiFM::
Init
(
    IN      PUNKNOWN        UnknownAdapter  OPTIONAL,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTMIDI       Port_,
    OUT     PSERVICEGROUP * ServiceGroup
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }
    ASSERT(Port_);
    ASSERT(ServiceGroup);

    int i;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::init"));

    //
    // AddRef() is required because we are keeping this pointer.
    //
    m_Port = Port_;
    m_Port->AddRef();

    //
    // m_fStreamExists is not explicitly set to FALSE because C++ zeros 
    // them out on a 'new'
    //

    KeInitializeSpinLock(&m_SpinLock);
    //
    // We want the IAdapterCommon interface on the adapter common object,
    // which is given to us as a IUnknown.  The QueryInterface call gives us
    // an AddRefed pointer to the interface we want.
    //
    NTSTATUS ntStatus = ProcessResources(ResourceList);

    if (NT_SUCCESS(ntStatus))
    {
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_SpinLock,&oldIrql);

        for (i = 0; i < 0x200; i++)    // initialize the shadow registers, used
           m_SavedRegValues[i] = 0x00; // in case of power-down during playback

        // Initialize the hardware.
        // 1. First check to see if an opl device is present.
        // 2. Then determine if it is an opl2 or opl3. Bail if opl2.
        // 3. Call Opl3_BoardReset to silence and reset the device.
        if (SoundSynthPresent(m_PortBase, m_PortBase))
        {
            // Now check if the device is an opl2 or opl3 type.
            // The patches are already declared for opl3. So Init() is not defined.
            // For opl2 we have to go through an init and load the patches structure.
            if (SoundMidiIsOpl3())
            {
                _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiFM::Init Type = OPL3"));
                // now silence the device and reset the board.
                Opl3_BoardReset();

                *ServiceGroup = NULL;
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiFM::Init Type = OPL2"));
                ntStatus = STATUS_NOT_IMPLEMENTED;                
            }

        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiFM::Init SoundSynthPresent failed"));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        KeReleaseSpinLock(&m_SpinLock,oldIrql);
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiFM::Init ProcessResources failed"));
    }

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiFM::Init returning 0x%X", ntStatus));

    if (!NT_SUCCESS(ntStatus))
    {
        //
        // clean up our mess
        //

        // release the port
        m_Port->Release();
        m_Port = NULL;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
// ==============================================================================
// NewStream()
// Creates a new stream.
// ==============================================================================
STDMETHODIMP 
CMiniportMidiFM::
NewStream
(
    OUT     PMINIPORTMIDISTREAM *   Stream,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   Pin,
    IN      BOOLEAN                 Capture,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP *         ServiceGroup
)
{
    PAGED_CODE();

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (m_fStreamExists)
    {
        _DbgPrintF(DEBUGLVL_TERSE,("CMiniportMidiFM::NewStream stream already exists"));
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::NewStream"));
        CMiniportMidiStreamFM *pStream =
            new(PoolType) CMiniportMidiStreamFM(OuterUnknown);

        if (pStream)
        {
            pStream->AddRef();

            ntStatus = pStream->Init(this,m_PortBase);

            if (NT_SUCCESS(ntStatus))
            {
                *Stream = PMINIPORTMIDISTREAM(pStream);
                (*Stream)->AddRef();

                *ServiceGroup = NULL;
                m_fStreamExists = TRUE;
            }

            pStream->Release();
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("CMiniportMidiFM::NewStream failed, no memory"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*----------------------------------------------------------------------------
 FUNCTION NAME- CMiniportMidiFM::PowerChangeNotify()
 ENTRY      --- IN  POWER_STATE     NewState
                        power management status
 RETURN     --- void
 *------------------------------------------------------------------------- */
STDMETHODIMP_(void) CMiniportMidiFM::PowerChangeNotify(
    IN  POWER_STATE     PowerState
) 
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::PowerChangeNotify(%d)",PowerState));

    switch (PowerState.DeviceState)
    {
        case PowerDeviceD0:
            if (m_PowerState.DeviceState != PowerDeviceD0) // check for power state delta
            {
                MiniportMidiFMResume();
            }
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
        default:
            //  Don't need to do anything special, we always remember where we are.
            break;
    }
    m_PowerState.DeviceState = PowerState.DeviceState;
}

#pragma code_seg()
// ==========================================================================
// ==========================================================================
void
CMiniportMidiFM::
MiniportMidiFMResume()
{
    KIRQL   oldIrql;
    BYTE    i;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::MiniportMidiFMResume"));
    KeAcquireSpinLock(&m_SpinLock,&oldIrql);
    //  We never touch these--set them to the default value anyway.
    //  AD_LSI
    SoundMidiSendFM(m_PortBase, AD_LSI, m_SavedRegValues[AD_LSI]);
    //  AD_LSI2
    SoundMidiSendFM(m_PortBase, AD_LSI2, m_SavedRegValues[AD_LSI2]);
    //  AD_TIMER1
    SoundMidiSendFM(m_PortBase, AD_TIMER1, m_SavedRegValues[AD_TIMER1]);
    //  AD_TIMER2
    SoundMidiSendFM(m_PortBase, AD_TIMER2, m_SavedRegValues[AD_TIMER2]);

    //  AD_MASK
    SoundMidiSendFM(m_PortBase, AD_MASK, m_SavedRegValues[AD_MASK]);
    
    //  AD_CONNECTION
    SoundMidiSendFM(m_PortBase, AD_CONNECTION, m_SavedRegValues[AD_CONNECTION]);

    //  AD_NEW
    SoundMidiSendFM(m_PortBase, AD_NEW, m_SavedRegValues[AD_NEW]);
    
    //  AD_NTS
    SoundMidiSendFM(m_PortBase, AD_NTS, m_SavedRegValues[AD_NTS]);
  
    //  AD_DRUM
    SoundMidiSendFM(m_PortBase, AD_DRUM, m_SavedRegValues[AD_DRUM]);
  
    for (i = 0; i <= 0x15; i++) 
    {
        if ((i & 0x07) <= 0x05)
        {
            //  AD_MULT
            //  AD_MULT2
            SoundMidiSendFM(m_PortBase, AD_MULT + i, m_SavedRegValues[AD_MULT + i]);
            SoundMidiSendFM(m_PortBase, AD_MULT2 + i, m_SavedRegValues[AD_MULT2 + i]);

            //  AD_LEVEL
            //  AD_LEVEL2
            //  turn off all the oscillators
            SoundMidiSendFM(m_PortBase, AD_LEVEL + i, m_SavedRegValues[AD_LEVEL + i]);
            SoundMidiSendFM(m_PortBase, AD_LEVEL2 + i, m_SavedRegValues[AD_LEVEL2 + i]);

            //  AD_AD
            //  AD_AD2
            SoundMidiSendFM(m_PortBase, AD_AD + i, m_SavedRegValues[AD_AD + i]);
            SoundMidiSendFM(m_PortBase, AD_AD2 + i, m_SavedRegValues[AD_AD2 + i]);

            //  AD_SR
            //  AD_SR2
            SoundMidiSendFM(m_PortBase, AD_SR + i, m_SavedRegValues[AD_SR + i]);
            SoundMidiSendFM(m_PortBase, AD_SR2 + i, m_SavedRegValues[AD_SR2 + i]);

            //  AD_WAVE
            //  AD_WAVE2
            SoundMidiSendFM(m_PortBase, AD_WAVE + i, m_SavedRegValues[AD_WAVE + i]);
            SoundMidiSendFM(m_PortBase, AD_WAVE2 + i, m_SavedRegValues[AD_WAVE2 + i]);
        }
    }
    
    for (i = 0; i <= 0x08; i++) 
    {
        //  AD_FNUMBER
        //  AD_FNUMBER2
        SoundMidiSendFM(m_PortBase, AD_FNUMBER + i, m_SavedRegValues[AD_FNUMBER + i]);
        SoundMidiSendFM(m_PortBase, AD_FNUMBER2 + i, m_SavedRegValues[AD_FNUMBER2 + i]);

        //  AD_FEEDBACK
        //  AD_FEEDBACK2
        SoundMidiSendFM(m_PortBase, AD_FEEDBACK + i, m_SavedRegValues[AD_FEEDBACK + i]);
        SoundMidiSendFM(m_PortBase, AD_FEEDBACK2 + i, m_SavedRegValues[AD_FEEDBACK2 + i]);

        //  AD_BLOCK
        //  AD_BLOCK2
        SoundMidiSendFM(m_PortBase, AD_BLOCK + i, m_SavedRegValues[AD_BLOCK + i]);
        SoundMidiSendFM(m_PortBase, AD_BLOCK2 + i, m_SavedRegValues[AD_BLOCK2 + i]);
    }
    KeReleaseSpinLock(&m_SpinLock,oldIrql);

    _DbgPrintF(DEBUGLVL_VERBOSE,("Done with CMiniportMidiFM::MiniportMidiFMResume"));
}

#pragma code_seg()
void 
CMiniportMidiFM::
Opl3_BoardReset()
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    BYTE i;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::Opl3_BoardReset"));
    /* ---- silence the chip -------- */

    /* tell the FM chip to use 4-operator mode, and
    fill in any other random variables */
    SoundMidiSendFM(m_PortBase, AD_NEW, 0x01);
    SoundMidiSendFM(m_PortBase, AD_MASK, 0x60);
    SoundMidiSendFM(m_PortBase, AD_CONNECTION, 0x00);
    SoundMidiSendFM(m_PortBase, AD_NTS, 0x00);

    /* turn off the drums, and use high vibrato/modulation */
    SoundMidiSendFM(m_PortBase, AD_DRUM, 0xc0);

    /* turn off all the oscillators */
    for (i = 0; i <= 0x15; i++) 
    {
        if ((i & 0x07) <= 0x05)
        {
            SoundMidiSendFM(m_PortBase, AD_LEVEL + i, 0x3f);
            SoundMidiSendFM(m_PortBase, AD_LEVEL2 + i, 0x3f);
        }
    };

    /* turn off all the voices */
    for (i = 0; i <= 0x08; i++) 
    {
        SoundMidiSendFM(m_PortBase, AD_BLOCK + i, 0x00);
        SoundMidiSendFM(m_PortBase, AD_BLOCK2 + i, 0x00);
    };
}


// ==============================================================================
// PinDataRangesStream
// Structures indicating range of valid format values for streaming pins.
// ==============================================================================
static
KSDATARANGE_MUSIC PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_MUSIC),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
        },
        STATICGUIDOF(KSMUSIC_TECHNOLOGY_FMSYNTH),
        NUM2VOICES,
        NUM2VOICES,
        0xffffffff
    }
};

// ==============================================================================
// PinDataRangePointersStream
// List of pointers to structures indicating range of valid format values
// for streaming pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

// ==============================================================================
// PinDataRangesBridge
// Structures indicating range of valid format values for bridge pins.
// ==============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI_BUS),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

// ==============================================================================
// PinDataRangePointersBridge
// List of pointers to structures indicating range of valid format values
// for bridge pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

// ==============================================================================
// MiniportPins
// List of pins.
// ==============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    {
        1,1,1,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStream),   // DataRangesCount
            PinDataRangePointersStream,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &KSNODETYPE_SYNTHESIZER,           // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
};

/*****************************************************************************
 * PropertiesVolume
 *****************************************************************************
 * Properties for volume controls.
 */
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_VOLUMELEVEL,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Level
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationVolume
 *****************************************************************************
 * Automation table for volume controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume,PropertiesVolume);

// ==============================================================================
// MiniportNodes
// List of nodes.
// ==============================================================================
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    {
            // synth node, #0
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_SYNTHESIZER,// Type
        NULL                    // Name TODO: fill in with correct GUID
    },
    {
            // volume node, #1
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        NULL                    // Name TODO: fill in with correct GUID
    }
};

// ==============================================================================
// MiniportConnections
// List of connections.
// ==============================================================================

/*****************************************************************************
 *      Table of topology unit connections.
 *
 * Pin numbering is technically arbitrary, but the convention established here
 * is to number a solitary output pin 0 (looks like an 'o') and a solitary
 * input pin 1 (looks like an 'i').  Even destinations, which have no output,
 * have an input pin numbered 1 and no pin 0.
 *
 * Nodes are more likely to have multiple ins than multiple outs, so the more
 * general rule would be that inputs are numbered >=1.  If a node has multiple
 * outs, none of these conventions apply.
 *
 * Nodes have at most one control value.  Mixers are therefore simple summing
 * nodes with no per-pin levels.  Rather than assigning a unique pin to each
 * input to a mixer, all inputs are connected to pin 1.  This is acceptable
 * because there is no functional distinction between the inputs.
 *
 * There are no multiplexers in this topology, so there is no opportunity to
 * give an example of a multiplexer.  A multiplexer should have a single
 * output pin (0) and multiple input pins (1..n).  Its control value is an
 * integer in the range 1..n indicating which input is connected to the
 * output.
 *
 * In the case of connections to pins, as opposed to connections to nodes, the
 * node is identified as PCFILTER_NODE and the pin number identifies the
 * particular filter pin.
 *****************************************************************************
 */
enum {
    eFMSynthNode  = 0,
    eFMVolumeNode
};

enum {
    eFMNodeOutput = 0,
    eFMNodeInput  = 1
};

enum {
    eFilterInput = eFMNodeOutput,
    eBridgeOutput = eFMNodeInput
};

static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    //  FromNode,       FromPin,        ToNode,         ToPin
    {   PCFILTER_NODE,  eFilterInput,   eFMSynthNode,   eFMNodeInput }, // Stream in to synth.
    {   eFMSynthNode,   eFMNodeOutput,  PCFILTER_NODE,  eBridgeOutput } // Synth to bridge out.
};

// different connection struct for volume version
static
PCCONNECTION_DESCRIPTOR MiniportWithVolConnections[] =
{
    //  FromNode,       FromPin,        ToNode,         ToPin
    {   PCFILTER_NODE,  eFilterInput,   eFMSynthNode,   eFMNodeInput }, // Stream in to synth.
    {   eFMSynthNode,   eFMNodeOutput,  eFMVolumeNode,  eFMNodeInput }, // Synth to volume.
    {   eFMVolumeNode,  eFMNodeOutput,  PCFILTER_NODE,  eBridgeOutput } // volume to bridge out.
};

// ==============================================================================
// MiniportDescription
// Complete description of the miniport.
// ==============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    1,                                  // NodeCount - no volume node
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories
};

static
PCFILTER_DESCRIPTOR MiniportFilterWithVolDescriptor =
{
    0,                                          // Version
    NULL,                                       // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),                   // PinSize
    SIZEOF_ARRAY(MiniportPins),                 // PinCount
    MiniportPins,                               // Pins
    sizeof(PCNODE_DESCRIPTOR),                  // NodeSize
    2,                                          // NodeCount - extra volume node
    MiniportNodes,                              // Nodes
    SIZEOF_ARRAY(MiniportWithVolConnections),   // ConnectionCount
    MiniportWithVolConnections,                 // Connections
    0,                                          // CategoryCount
    NULL                                        // Categories
};

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiFM::GetDescription()
// Gets the topology.
// Pass back appropriate descriptor, depending on whether volume node is needed.
// ==============================================================================
STDMETHODIMP
CMiniportMidiFM::
GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::GetDescription"));

    if (m_volNodeNeeded)
    {
        *OutFilterDescriptor = &MiniportFilterWithVolDescriptor;
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Getting descriptor of new FM miniport with volume node"));
    }
    else
    {
        *OutFilterDescriptor = &MiniportFilterDescriptor;
    }

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::NonDelegatingQueryInterface()
// Obtains an interface.  This function works just like a COM QueryInterface
// call and is used if the object is not being aggregated.
// ==============================================================================
STDMETHODIMP CMiniportMidiStreamFM::NonDelegatingQueryInterface
(
REFIID  Interface,
PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::NonDelegatingQueryInterface"));

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORT(this)));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportMidiStream))
    {
        *Object = PVOID(PMINIPORTMIDISTREAM(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(PMINIPORT(*Object))->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::~CMiniportMidiStreamFM()
// Destructor.
// ==============================================================================
CMiniportMidiStreamFM::~CMiniportMidiStreamFM
(
void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::~CMiniportMidiStreamFM"));

    Opl3_AllNotesOff();

    if (m_Miniport)
    {
        m_Miniport->m_fStreamExists = FALSE;
        m_Miniport->Release();
    }
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::Init()
// Initializes a the miniport.
// ==============================================================================
NTSTATUS
CMiniportMidiStreamFM::
Init
(
    IN      CMiniportMidiFM *   Miniport,
    IN      PUCHAR              PortBase
)
{
    PAGED_CODE();

    ASSERT(Miniport);
    ASSERT(PortBase);

    int i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::Init"));

    //
    // AddRef() is required because we are keeping this pointer.
    //
    m_Miniport = Miniport;
    m_Miniport->AddRef();

    m_PortBase = PortBase;

    // init some members
    m_dwCurTime = 1;    /* for note on/off */
    /* volume */
    m_wSynthAttenL = 0;        /* in 1.5dB steps */
    m_wSynthAttenR = 0;        /* in 1.5dB steps */

    m_MinVolValue  = 0xFFD0C000;    //  minimum -47.25(dB) * 0x10000
    m_MaxVolValue  = 0x00000000;    //  maximum  0    (dB) * 0x10000
    m_VolStepDelta = 0x0000C000;    //  steps of 0.75 (dB) * 0x10000
    m_SavedVolValue[CHAN_LEFT] = m_SavedVolValue[CHAN_RIGHT] = 0;

    /* start attenuations at -3 dB, which is 90 MIDI level */
    for (i = 0; i < NUMCHANNELS; i++) 
    {
        m_bChanAtten[i] = 4;
        m_bStereoMask[i] = 0xff;
    };

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::SetState()
// Sets the transport state.
// ==============================================================================
STDMETHODIMP
CMiniportMidiStreamFM::
SetState
(
    IN      KSSTATE     NewState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::SetState"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    switch (NewState)
    {
    case KSSTATE_STOP:
    case KSSTATE_ACQUIRE:
    case KSSTATE_PAUSE:
        Opl3_AllNotesOff();
        break;

    case KSSTATE_RUN:
        break;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::SetFormat()
// Sets the format.
// ==============================================================================
STDMETHODIMP
CMiniportMidiStreamFM::
SetFormat
(
    IN      PKSDATAFORMAT   Format
)
{
    PAGED_CODE();

    ASSERT(Format);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::SetFormat"));

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * BasicSupportHandler()
 *****************************************************************************
 * Assists in BASICSUPPORT accesses on level properties - 
 * this is declared as a friend method in the header file.
 */
static
NTSTATUS BasicSupportHandler
(
    IN  PPCPROPERTY_REQUEST PropertyRequest
)
{
    PAGED_CODE();
    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("BasicSupportHandler"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    if (PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
    {
        // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
        PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);

        PropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                KSPROPERTY_TYPE_GET |
                                KSPROPERTY_TYPE_SET;
        PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION) +
                                      sizeof(KSPROPERTY_MEMBERSHEADER) +
                                      sizeof(KSPROPERTY_STEPPING_LONG);
        PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        PropDesc->PropTypeSet.Id    = VT_I4;
        PropDesc->PropTypeSet.Flags = 0;
        PropDesc->MembersListCount  = 1;
        PropDesc->Reserved          = 0;

        // if return buffer can also hold a range description, return it too
        if (PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION) +
                                           sizeof(KSPROPERTY_MEMBERSHEADER) +
                                           sizeof(KSPROPERTY_STEPPING_LONG)))
        {
            // fill in the members header
            PKSPROPERTY_MEMBERSHEADER Members = PKSPROPERTY_MEMBERSHEADER(PropDesc + 1);

            Members->MembersFlags   = KSPROPERTY_MEMBER_STEPPEDRANGES;
            Members->MembersSize    = sizeof(KSPROPERTY_STEPPING_LONG);
            Members->MembersCount   = 1;
            Members->Flags          = 0;

            // fill in the stepped range
            PKSPROPERTY_STEPPING_LONG Range = PKSPROPERTY_STEPPING_LONG(Members + 1);

            switch (PropertyRequest->Node)
            {
                case eFMVolumeNode:
                    CMiniportMidiStreamFM *that = (CMiniportMidiStreamFM *)PropertyRequest->MinorTarget;

                    if (that)
                    {
                        Range->Bounds.SignedMinimum = that->m_MinVolValue;
                        Range->Bounds.SignedMaximum = that->m_MaxVolValue;
                        Range->SteppingDelta        = that->m_VolStepDelta;
                        break;
                    }
                    else
                    {
                        return STATUS_INVALID_PARAMETER;
                    }
            }

            Range->Reserved = 0;

            _DbgPrintF(DEBUGLVL_VERBOSE, ("---Node: %d  Max: 0x%X  Min: 0x%X  Step: 0x%X",PropertyRequest->Node,
                                       Range->Bounds.SignedMaximum,
                                       Range->Bounds.SignedMinimum,
                                       Range->SteppingDelta));

            // set the return value size
            PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION) +
                                         sizeof(KSPROPERTY_MEMBERSHEADER) +
                                         sizeof(KSPROPERTY_STEPPING_LONG);
        }
        else
        {
            // set the return value size
            PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
        }
        ntStatus = STATUS_SUCCESS;

    }
    else if (PropertyRequest->ValueSize >= sizeof(ULONG))
    {
        // if return buffer can hold a ULONG, return the access flags
        PULONG AccessFlags = PULONG(PropertyRequest->Value);

        *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                       KSPROPERTY_TYPE_GET |
                       KSPROPERTY_TYPE_SET;

        // set the return value size
        PropertyRequest->ValueSize = sizeof(ULONG);
        ntStatus = STATUS_SUCCESS;

    }
    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PropertyHandler_Level()
 *****************************************************************************
 * Accesses a KSAUDIO_LEVEL property.
 */
static
NTSTATUS PropertyHandler_Level
(
    IN  PPCPROPERTY_REQUEST PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Level"));


    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    LONG            channel;

    // validate node
    if (PropertyRequest->Node == eFMVolumeNode)
    {
        if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            // get the instance channel parameter
            if (PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));

                // only support get requests on either mono/left(0) or right(1) channels
                if ((channel == CHAN_LEFT) || (channel == CHAN_RIGHT))
                {
                    // validate and get the output parameter
                    if (PropertyRequest->ValueSize >= sizeof(LONG))
                    {
                        PLONG Level = (PLONG)PropertyRequest->Value;

                        // check if volume property request
                        if (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                        {
                            CMiniportMidiStreamFM *that = (CMiniportMidiStreamFM *)PropertyRequest->MinorTarget;
                            if (that)
                            {
                                *Level = that->GetFMAtten(channel);
                                PropertyRequest->ValueSize = sizeof(LONG);
                                ntStatus = STATUS_SUCCESS;
                            }
                            //  if (!that) return STATUS_INVALID_PARAMETER

                        }   // (PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                    }     // (ValueSize >= sizeof(LONG))
                }       // ((channel == CHAN_LEFT) || (channel == CHAN_RIGHT))
            }         // (InstanceSize >= sizeof(LONG))
        }           // (Verb & KSPROPERTY_TYPE_GET)

        else if (PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
        {
            // get the instance channel parameter
            if (PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));

                // only support get requests on either mono/left (0), right (1), or master (-1) channels
                if ((channel == CHAN_LEFT) || (channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
                {
                    // validate and get the input parameter
                    if (PropertyRequest->ValueSize == sizeof(LONG))
                    {
                        PLONG level = (PLONG)PropertyRequest->Value;

                        if (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                        {
                            CMiniportMidiStreamFM *that = (CMiniportMidiStreamFM *)PropertyRequest->MinorTarget;
                            if (that)
                            {
                                that->SetFMAtten(channel,*level);
                                ntStatus = STATUS_SUCCESS;
                            }
                            //  if (!that) return STATUS_INVALID_PARAMETER

                        }   // (PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                    }     // (ValueSize == sizeof(LONG))
                }       // ((channel == CHAN_LEFT) || (channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
            }         // (InstanceSize >= sizeof(LONG))
        }           // (Verb & KSPROPERTY_TYPE_SET)

        else if (PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            if (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
            {
                ntStatus = BasicSupportHandler(PropertyRequest);
            }
        }   // (Verb & KSPROPERTY_TYPE_BASICSUPPORT) 
    }     // (Node == eFMVolumeNode)

    return ntStatus;
}

#pragma code_seg()
// convert from 16.16 dB to [0,63], set m_wSynthAttenR
void 
CMiniportMidiStreamFM::
SetFMAtten
(
    IN LONG channel, 
    IN LONG level
)
{
    KIRQL   oldIrql;
    if ((channel == CHAN_LEFT) || (channel == CHAN_MASTER))
    {
        m_SavedVolValue[CHAN_LEFT] = level;

        if (level > m_MaxVolValue)
            m_wSynthAttenL = 0;
        else if (level < m_MinVolValue)
            m_wSynthAttenL = 63;
        else
            m_wSynthAttenL = WORD(-level / (LONG)m_VolStepDelta);
    }
    if ((channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
    {
        m_SavedVolValue[CHAN_RIGHT] = level;
    
        if (level > m_MaxVolValue)
            m_wSynthAttenR = 0;
        else if (level < m_MinVolValue)
            m_wSynthAttenR = 63;
        else
            m_wSynthAttenR = WORD(-level / (LONG)m_VolStepDelta);
    }
#ifdef USE_KDPRINT
    KdPrint(("'StreamFM::SetFMAtten: channel: 0x%X, level: 0x%X, m_wSynthAttenL: 0x%X, m_wSynthAttenR: 0x%X \n",
                                     channel,       level,       m_wSynthAttenL,       m_wSynthAttenR));
#else   //  USE_KDPRINT
    _DbgPrintF(DEBUGLVL_VERBOSE,("StreamFM::SetFMAtten: channel: 0x%X, level: 0x%X, m_wSynthAttenL: 0x%X, m_wSynthAttenR: 0x%X \n",
                                                        channel,       level,       m_wSynthAttenL,       m_wSynthAttenR));
#endif  //  USE_KDPRINT

    KeAcquireSpinLock(&m_Miniport->m_SpinLock,&oldIrql);
    Opl3_SetVolume(0xFF); //  0xFF means all channels
    KeReleaseSpinLock(&m_Miniport->m_SpinLock,oldIrql);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PropertyHandler_CpuResources()
 *****************************************************************************
 * Processes a KSPROPERTY_AUDIO_CPU_RESOURCES request
 */
static
NTSTATUS PropertyHandler_CpuResources
(
    IN  PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_CpuResources"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    // validate node
    if(PropertyRequest->Node == eFMVolumeNode)
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            if(PropertyRequest->ValueSize >= sizeof(LONG))
            {
                *(PLONG(PropertyRequest->Value)) = KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU;
                PropertyRequest->ValueSize = sizeof(LONG);
                ntStatus = STATUS_SUCCESS;
            } 
            else
            {
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_CpuResources failed, buffer too small"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
        }
    }
    return ntStatus;
}

#pragma code_seg()
// ==============================================================================
// SoundMidiSendFM
//  Writes out to the device.
//  Called from DPC code (Write->WriteMidiData->Opl3_NoteOn->Opl3_FMNote->here)
// ==============================================================================
void 
CMiniportMidiFM::
SoundMidiSendFM
(
IN    PUCHAR PortBase,
IN    ULONG Address,
IN    UCHAR Data
)
{
    ASSERT(Address < 0x200);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    // these delays need to be 23us at least for old opl2 chips, even
    // though new chips can handle 1 us delays.

#ifdef USE_KDPRINT
    KdPrint(("'SoundMidiSendFM(%02x %02x) \n",Address,Data));
#else   //  USE_KDPRINT
    _DbgPrintF(DEBUGLVL_VERBOSE, ("%X\t%X", Address,Data));
#endif  //  USE_KDPRINT
    WRITE_PORT_UCHAR(PortBase + (Address < 0x100 ? 0 : 2), (UCHAR)Address);
    KeStallExecutionProcessor(23);

    WRITE_PORT_UCHAR(PortBase + (Address < 0x100 ? 1 : 3), Data);
    KeStallExecutionProcessor(23);

    m_SavedRegValues[Address] = Data;
}


#pragma code_seg()
// ==============================================================================
// Service()
// DPC-mode service call from the port.
// ==============================================================================
STDMETHODIMP_(void) 
CMiniportMidiFM::
Service
(   void
)
{
}

#pragma code_seg()
// ==============================================================================
// CMiniportMidiStreamFM::Read()
// Reads incoming MIDI data.
// ==============================================================================
STDMETHODIMP
CMiniportMidiStreamFM::
Read
(
    IN      PVOID   BufferAddress,
    IN      ULONG   Length,
    OUT     PULONG  BytesRead
)
{
    return STATUS_NOT_IMPLEMENTED;
}

#pragma code_seg()
// ==============================================================================
// CMiniportMidiStreamFM::Write()
// Writes outgoing MIDI data.  
// 
// N.B.!!!
// THIS DATA SINK ASSUMES THAT DATA COMES IN ONE MESSAGE AT A TIME!!!
// IF LENGTH IS MORE THAN THREE BYTES, SUCH AS SYSEX OR MULTIPLE MIDI 
// MESSAGES, ALL THE DATA IS DROPPED UNCEREMONIOUSLY ON THE FLOOR!!!
// ALSO DOES NOT PLAY WELL WITH RUNNING STATUS!!!
// 
// CLEARLY, THIS MINIPORT HAS SOME "ISSUES".
//
// ==============================================================================
STDMETHODIMP
CMiniportMidiStreamFM::
Write
(
    IN      PVOID   BufferAddress,  // pointer to Midi Data.
    IN      ULONG   Length,
    OUT     PULONG  BytesWritten
)
{
    ASSERT(BufferAddress);
    ASSERT(BytesWritten);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiStreamFM::Write"));

    BYTE    statusByte = *(PBYTE)BufferAddress & 0xF0;
    *BytesWritten = Length;
    
    if (statusByte < 0x80)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiStreamFM::Write requires first byte to be status -- ignored"));
    }
    else if (statusByte == 0xF0)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("StreamFM::Write doesn't handle System messages -- ignored"));
    }
    else if (statusByte == 0xA0)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("StreamFM::Write doesn't handle Polyphonic key pressure/Aftertouch messages -- ignored"));
    }
    else if (statusByte == 0xD0)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("StreamFM::Write doesn't handle Channel pressure/Aftertouch messages -- ignored"));
    }
    else if (Length < 4)
    {
        WriteMidiData(*(DWORD *)BufferAddress);
    }
    else 
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("StreamFM::Write doesn't handle Length > 3."));
    }   
    return STATUS_SUCCESS;
}

// ==============================================================================
// ==============================================================================
// Private Methods of CMiniportMidiFM
// ==============================================================================
// ==============================================================================


#pragma code_seg()
// =================================================================
// SoundMidiIsOpl3
// Checks if the midi synthesizer is Opl3 compatible or just adlib-compatible.
// returns:  TRUE if OPL3-compatible chip. FALSE otherwise.
//
// NOTE: This has been taken as is from the nt driver code.
// =================================================================
BOOL CMiniportMidiFM::
SoundMidiIsOpl3(void)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    BOOL bIsOpl3 = FALSE;

    /*
     * theory: an opl3-compatible synthesizer chip looks
     * exactly like two separate 3812 synthesizers (for left and right
     * channels) until switched into opl3 mode. Then, the timer-control
     * register for the right half is replaced by a channel connection register
     * (among other changes).
     *
     * We can detect 3812 synthesizers by starting a timer and looking for
     * timer overflow. So if we find 3812s at both left and right addresses,
     * we then switch to opl3 mode and look again for the right-half. If we
     * still find it, then the switch failed and we have an old synthesizer
     * if the right half disappeared, we have a new opl3 synthesizer.
     *
     * NB we use either monaural base-level synthesis, or stereo opl3
     * synthesis. If we discover two 3812s (as on early SB Pro and
     * PAS), we ignore one of them.
     */

    /*
     * nice theory - but wrong. The timer on the right half of the
     * opl3 chip reports its status in the left-half status register.
     * There is no right-half status register on the opl3 chip.
     */


    /* ensure base mode */
    SoundMidiSendFM(m_PortBase, AD_NEW, 0x00);
    KeStallExecutionProcessor(20);

    /* look for right half of chip */
    if (SoundSynthPresent(m_PortBase + 2, m_PortBase))
    {
        /* yes - is this two separate chips or a new opl3 chip ? */
        /* switch to opl3 mode */
        SoundMidiSendFM(m_PortBase, AD_NEW, 0x01);
        KeStallExecutionProcessor(20);

        if (!SoundSynthPresent(m_PortBase + 2, m_PortBase))
        {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiFM: In SoundMidiIsOpl3 right half disappeared"));
            /* right-half disappeared - so opl3 */
            bIsOpl3 = TRUE;
        }
    }

    if (!bIsOpl3)
    {
        /* reset to 3812 mode */
        SoundMidiSendFM(m_PortBase, AD_NEW, 0x00);
        KeStallExecutionProcessor(20);
    }

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiFM: In SoundMidiIsOpl3 returning bIsOpl3 = 0x%X", bIsOpl3));
    return(bIsOpl3);
}

#pragma code_seg()
// ==============================================================================
// SoundSynthPresent
//
// Detect the presence or absence of a 3812 (opl2/adlib-compatible) synthesizer
// at the given i/o address by starting the timer and looking for an
// overflow. Can be used to detect left and right synthesizers separately.
//
// Returns: True if a synthesiser is present at that address and false if not.
//
// NOTE: This and has been taken as is from the nt driver code.
// ==============================================================================
BOOL
CMiniportMidiFM::
SoundSynthPresent
(
IN PUCHAR   base,
IN PUCHAR inbase
)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    UCHAR t1, t2;
    // check if the chip is present
    SoundMidiSendFM(base, 4, 0x60);             // mask T1 & T2
    SoundMidiSendFM(base, 4, 0x80);             // reset IRQ

    t1 = READ_PORT_UCHAR((PUCHAR)inbase);       // read status register

    SoundMidiSendFM(base, 2, 0xff);             // set timer - 1 latch
    SoundMidiSendFM(base, 4, 0x21);             // unmask & start T1

    // this timer should go off in 80 us. It sometimes
    // takes more than 100us, but will always have expired within
    // 200 us if it is ever going to.
    KeStallExecutionProcessor(200);

    t2 = READ_PORT_UCHAR((PUCHAR)inbase);       // read status register

    SoundMidiSendFM(base, 4, 0x60);
    SoundMidiSendFM(base, 4, 0x80);

    if (!((t1 & 0xE0) == 0) || !((t2 & 0xE0) == 0xC0))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("SoundSynthPresent: returning false"));
        return(FALSE);
    }
    _DbgPrintF(DEBUGLVL_VERBOSE, ("SoundSynthPresent: returning true"));
    return TRUE;
}


// ==============================================================================
// this array gives the offsets of the slots within an opl2
// chip. This is needed to set the attenuation for all slots to max,
// to ensure that the chip is silenced completely - switching off the
// voices alone will not do this.
// ==============================================================================
BYTE offsetSlot[] =
{
    0, 1, 2, 3, 4, 5,
    8, 9, 10, 11, 12, 13,
    16, 17, 18, 19, 20, 21
};

#pragma code_seg()
// =========================================================================
// WriteMidiData
//      Converts a MIDI atom into the corresponding FM transaction.
// =========================================================================
void
CMiniportMidiStreamFM::
WriteMidiData(DWORD dwData)
{
    BYTE    bMsgType,bChannel, bVelocity, bNote;
    WORD    wTemp;
    KIRQL   oldIrql;

    bMsgType = (BYTE) dwData & (BYTE)0xf0;
    bChannel = (BYTE) dwData & (BYTE)0x0f;
    bNote = (BYTE) ((WORD) dwData >> 8) & (BYTE)0x7f;
    bVelocity = (BYTE) (dwData >> 16) & (BYTE)0x7f;
    
#ifdef USE_KDPRINT
    KdPrint(("'StreamFM::WriteMidiData: (%x %x %x) \n",bMsgType+bChannel,bNote,bVelocity));
#else   //  USE_KDPRINT
    _DbgPrintF(DEBUGLVL_VERBOSE,("StreamFM::WriteMidiData: (%x %x %x) \n",bMsgType+bChannel,bNote,bVelocity));
#endif  //  USE_KDPRINT
    KeAcquireSpinLock(&m_Miniport->m_SpinLock,&oldIrql);
    switch (bMsgType)
    {
        case 0x90:      /* turn key on, or key off if volume == 0 */
            if (bVelocity)
            {
                if (bChannel == DRUMCHANNEL)
                {
                    Opl3_NoteOn((BYTE)(bNote + 128),bNote,bChannel,bVelocity,(short)m_iBend[bChannel]);
                }
                else
                {
                    Opl3_NoteOn((BYTE)m_bPatch[bChannel],bNote,bChannel,bVelocity,(short) m_iBend[bChannel]);
                }
                break;
            } // if bVelocity.
            //NOTE: no break specified here. On an else case we want to continue through and turn key off

        case 0x80:
            /* turn key off */
            //  we don't care what the velocity is on note off
            if (bChannel == DRUMCHANNEL)
            {
                Opl3_NoteOff((BYTE) (bNote + 128),bNote, bChannel, 0);
            }
            else
            {
                Opl3_NoteOff ((BYTE) m_bPatch[bChannel],bNote, bChannel, m_bSustain[ bChannel ]);
            }
            break;

        case 0xb0:
            /* change control */
            switch (bNote) 
            {
                case 7:
                    /* change channel volume */
                    Opl3_ChannelVolume(bChannel,gbVelocityAtten[bVelocity >> 1]);
                    break;

                case 8:
                case 10:
                    /* change the pan level */
                    Opl3_SetPan(bChannel, bVelocity);
                    break;

                case 64:
                    /* Change the sustain level */
                    Opl3_SetSustain(bChannel, bVelocity);
                    break;

                default:
                    if (bNote >= 120)        /* Channel mode messages */
                    {
                        Opl3_ChannelNotesOff(bChannel);
                    }
                    //  else unknown controller
            };
            break;

        case 0xc0:
            if (bChannel != DRUMCHANNEL)
            {
               m_bPatch[ bChannel ] = bNote ;

            }
            break;

        case 0xe0:  // pitch bend
            wTemp = ((WORD) bVelocity << 9) | ((WORD) bNote << 2);
            m_iBend[bChannel] = (short) (WORD) (wTemp + 0x8000);
            Opl3_PitchBend(bChannel, m_iBend[bChannel]);

            break;
    };
    KeReleaseSpinLock(&m_Miniport->m_SpinLock,oldIrql);
    
    return;
}

// ========================= opl3 specific methods ============================
#pragma code_seg()
// ==========================================================================
// Opl3_AllNotesOff - turn off all notes
// ==========================================================================
void 
CMiniportMidiStreamFM::
Opl3_AllNotesOff()
{
    BYTE i;
    KIRQL   oldIrql;

    KeAcquireSpinLock(&m_Miniport->m_SpinLock,&oldIrql);
    for (i = 0; i < NUM2VOICES; i++) 
    {
        Opl3_NoteOff(m_Voice[i].bPatch, m_Voice[i].bNote, m_Voice[i].bChannel, 0);
    }
    KeReleaseSpinLock(&m_Miniport->m_SpinLock,oldIrql);
}

#pragma code_seg()
// ==========================================================================
//  void Opl3_NoteOff
//
//  Description:
//     This turns off a note, including drums with a patch
//     # of the drum note + 128, but the first drum instrument is at MIDI note _35_.
//
//  Parameters:
//     BYTE bPatch
//        MIDI patch
//
//     BYTE bNote
//        MIDI note
//
//     BYTE bChannel
//        MIDI channel
//
//  Return Value:
//     Nothing.
//
//
// ==========================================================================
void 
CMiniportMidiStreamFM::
Opl3_NoteOff
(
    BYTE            bPatch,
    BYTE            bNote,
    BYTE            bChannel,
    BYTE            bSustain
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   patchStruct FAR  *lpPS ;
   WORD             wOffset, wTemp ;

   // Find the note slot
   wTemp = Opl3_FindFullSlot( bNote, bChannel ) ;

   if (wTemp != 0xffff)
   {
      if (bSustain)
      {
          // This channel is sustained, don't really turn the note off,
          // just flag it.
          //
          m_Voice[ wTemp ].bSusHeld = 1;
          
          return;
      }
      
      // get a pointer to the patch
      lpPS = glpPatch + (BYTE) m_Voice[ wTemp ].bPatch ;

      // shut off the note portion
      // we have the note slot, turn it off.
      wOffset = wTemp;
      if (wTemp >= (NUM2VOICES / 2))
         wOffset += (0x100 - (NUM2VOICES / 2));

      m_Miniport->SoundMidiSendFM(m_PortBase, AD_BLOCK + wOffset,
                  (BYTE)(m_Voice[ wTemp ].bBlock[ 0 ] & 0x1f) ) ;

      // Note this...
      m_Voice[ wTemp ].bOn = FALSE ;
      m_Voice[ wTemp ].bBlock[ 0 ] &= 0x1f ;
      m_Voice[ wTemp ].bBlock[ 1 ] &= 0x1f ;
      m_Voice[ wTemp ].dwTime = m_dwCurTime ;
   }
}

#pragma code_seg()
// ==========================================================================
//  WORD Opl3_FindFullSlot
//
//  Description:
//     This finds a slot with a specific note, and channel.
//     If it is not found then 0xFFFF is returned.
//
//  Parameters:
//     BYTE bNote
//        MIDI note number
//
//     BYTE bChannel
//        MIDI channel #
//
//  Return Value:
//     WORD
//        note slot #, or 0xFFFF if can't find it
//
//
// ==========================================================================
WORD 
CMiniportMidiStreamFM::
Opl3_FindFullSlot
(
    BYTE            bNote,
    BYTE            bChannel
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD  i ;

   for (i = 0; i < NUM2VOICES; i++)
   {
      if ((bChannel == m_Voice[ i ].bChannel) 
            && (bNote == m_Voice[ i ].bNote) 
            && (m_Voice[ i ].bOn))
      {
            return ( i ) ;
      }
   // couldn't find it
   }
   return ( 0xFFFF ) ;
} 


#pragma code_seg()
//------------------------------------------------------------------------
//  void Opl3_FMNote
//
//  Description:
//     Turns on an FM-synthesizer note.
//
//  Parameters:
//     WORD wNote
//        the note number from 0 to NUMVOICES
//
//     noteStruct FAR *lpSN
//        structure containing information about what
//        is to be played.
//
//  Return Value:
//     Nothing.
//------------------------------------------------------------------------
void 
CMiniportMidiStreamFM::
Opl3_FMNote
(
    WORD                wNote,
    noteStruct FAR *    lpSN
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD            i ;
   WORD            wOffset ;
   operStruct FAR  *lpOS ;

   // write out a note off, just to make sure...

   wOffset = wNote;
   if (wNote >= (NUM2VOICES / 2))
      wOffset += (0x100 - (NUM2VOICES / 2));

   m_Miniport->SoundMidiSendFM(m_PortBase, AD_BLOCK + wOffset, 0 ) ;

   // writing the operator information

//   for (i = 0; i < (WORD)((wNote < NUM4VOICES) ? NUMOPS : 2); i++)
   for (i = 0; i < 2; i++)
   {
      lpOS = &lpSN -> op[ i ] ;
      wOffset = gw2OpOffset[ wNote ][ i ] ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0x20 + wOffset, lpOS -> bAt20) ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0x40 + wOffset, lpOS -> bAt40) ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0x60 + wOffset, lpOS -> bAt60) ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0x80 + wOffset, lpOS -> bAt80) ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0xE0 + wOffset, lpOS -> bAtE0) ;

   }

   // write out the voice information
   wOffset = (wNote < 9) ? wNote : (wNote + 0x100 - 9) ;
   m_Miniport->SoundMidiSendFM(m_PortBase, 0xa0 + wOffset, lpSN -> bAtA0[ 0 ] ) ;
   m_Miniport->SoundMidiSendFM(m_PortBase, 0xc0 + wOffset, lpSN -> bAtC0[ 0 ] ) ;

   // Note on...
   m_Miniport->SoundMidiSendFM(m_PortBase, 0xb0 + wOffset,
               (BYTE)(lpSN -> bAtB0[ 0 ] | 0x20) ) ;

} // end of Opl3_FMNote()

#pragma code_seg()
//=======================================================================
//  WORD Opl3_NoteOn
//
//  Description:
//     This turns on a note, including drums with a patch # of the
//     drum note + 0x80.  The first GM drum instrument is mapped to note 35 instead of zero, though, so
//     we expect 0 as the first drum patch (acoustic kick) if note 35 comes in.
//
//  Parameters:
//     BYTE bPatch
//        MIDI patch
//
//     BYTE bNote
//        MIDI note
//
//     BYTE bChannel
//        MIDI channel
//
//     BYTE bVelocity
//        velocity value
//
//     short iBend
//        current pitch bend from -32768 to 32767
//
//  Return Value:
//     WORD
//        note slot #, or 0xFFFF if it is inaudible
//=======================================================================
void 
CMiniportMidiStreamFM::
Opl3_NoteOn
(
    BYTE            bPatch,
    BYTE            bNote,
    BYTE            bChannel,
    BYTE            bVelocity,
    short           iBend
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD             wTemp, i, j ;
   BYTE             b4Op, bTemp, bMode, bStereo ;
   patchStruct FAR  *lpPS ;
   DWORD            dwBasicPitch, dwPitch[ 2 ] ;
   noteStruct       NS ;

   // Get a pointer to the patch
   lpPS = glpPatch + bPatch ;

   // Find out the basic pitch according to our
   // note value.  This may be adjusted because of
   // pitch bends or special qualities for the note.

   dwBasicPitch = gdwPitch[ bNote % 12 ] ;
   bTemp = bNote / (BYTE) 12 ;
   if (bTemp > (BYTE) (60 / 12))
      dwBasicPitch = AsLSHL( dwBasicPitch, (BYTE)(bTemp - (BYTE)(60/12)) ) ;
   else if (bTemp < (BYTE) (60/12))
      dwBasicPitch = AsULSHR( dwBasicPitch, (BYTE)((BYTE) (60/12) - bTemp) ) ;

   // Copy the note information over and modify
   // the total level and pitch according to
   // the velocity, midi volume, and tuning.

   RtlCopyMemory( (LPSTR) &NS, (LPSTR) &lpPS -> note, sizeof( noteStruct ) ) ;
   b4Op = (BYTE)(NS.bOp != PATCH_1_2OP) ;

   for (j = 0; j < 2; j++)
   {
      // modify pitch
      dwPitch[ j ] = dwBasicPitch ;
      bTemp = (BYTE)((NS.bAtB0[ j ] >> 2) & 0x07) ;
      if (bTemp > 4)
         dwPitch[ j ] = AsLSHL( dwPitch[ j ], (BYTE)(bTemp - (BYTE)4) ) ;
      else if (bTemp < 4)
         dwPitch[ j ] = AsULSHR( dwPitch[ j ], (BYTE)((BYTE)4 - bTemp) ) ;

      wTemp = Opl3_CalcFAndB( Opl3_CalcBend( dwPitch[ j ], iBend ) ) ;
      NS.bAtA0[ j ] = (BYTE) wTemp ;
      NS.bAtB0[ j ] = (BYTE) 0x20 | (BYTE) (wTemp >> 8) ;
   }

   // Modify level for each operator, but only
   // if they are carrier waves

   bMode = (BYTE) ((NS.bAtC0[ 0 ] & 0x01) * 2 + 4) ;

   for (i = 0; i < 2; i++)
   {
      wTemp = (BYTE) 
          Opl3_CalcVolume(  (BYTE)(NS.op[ i ].bAt40 & (BYTE) 0x3f),
                            bChannel, 
                            bVelocity, 
                            (BYTE) i, 
                            bMode ) ;
      NS.op[ i ].bAt40 = (NS.op[ i ].bAt40 & (BYTE)0xc0) | (BYTE) wTemp ;
   }

   // Do stereo panning, but cutting off a left or
   // right channel if necessary...

   bStereo = Opl3_CalcStereoMask( bChannel ) ;
   NS.bAtC0[ 0 ] &= bStereo ;

   // Find an empty slot, and use it...
   wTemp = Opl3_FindEmptySlot( bPatch ) ;

   Opl3_FMNote(wTemp, &NS ) ;
   m_Voice[ wTemp ].bNote = bNote ;
   m_Voice[ wTemp ].bChannel = bChannel ;
   m_Voice[ wTemp ].bPatch = bPatch ;
   m_Voice[ wTemp ].bVelocity = bVelocity ;
   m_Voice[ wTemp ].bOn = TRUE ;
   m_Voice[ wTemp ].dwTime = m_dwCurTime++ ;
   m_Voice[ wTemp ].dwOrigPitch[0] = dwPitch[ 0 ] ;  // not including bend
   m_Voice[ wTemp ].dwOrigPitch[1] = dwPitch[ 1 ] ;  // not including bend
   m_Voice[ wTemp ].bBlock[0] = NS.bAtB0[ 0 ] ;
   m_Voice[ wTemp ].bBlock[1] = NS.bAtB0[ 1 ] ;
   m_Voice[ wTemp ].bSusHeld = 0;


} // end of Opl3_NoteOn()

#pragma code_seg()
//=======================================================================
//Opl3_CalcFAndB - Calculates the FNumber and Block given a frequency.
//
//inputs
//       DWORD   dwPitch - pitch
//returns
//        WORD - High byte contains the 0xb0 section of the
//                        block and fNum, and the low byte contains the
//                        0xa0 section of the fNumber
//=======================================================================
WORD 
CMiniportMidiStreamFM::
Opl3_CalcFAndB(DWORD dwPitch)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    BYTE    bBlock;

    /* bBlock is like an exponential to dwPitch (or FNumber) */
    for (bBlock = 1; dwPitch >= 0x400; dwPitch >>= 1, bBlock++)
        ;

    if (bBlock > 0x07)
        bBlock = 0x07;  /* we cant do anything about this */

    /* put in high two bits of F-num into bBlock */
    return ((WORD) bBlock << 10) | (WORD) dwPitch;
}

#pragma code_seg()
//=======================================================================
//Opl3_CalcBend - This calculates the effects of pitch bend
//        on an original value.
//
//inputs
//        DWORD   dwOrig - original frequency
//        short   iBend - from -32768 to 32768, -2 half steps to +2
//returns
//        DWORD - new frequency
//=======================================================================
DWORD 
CMiniportMidiStreamFM::
Opl3_CalcBend (DWORD dwOrig, short iBend)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DWORD   dw;
  
    /* do different things depending upon positive or
        negative bend */
    if (iBend > 0)
    {
        dw = (DWORD)((iBend * (LONG)(256.0 * (EQUAL * EQUAL - 1.0))) >> 8);
        dwOrig += (DWORD)(AsULMUL(dw, dwOrig) >> 15);
    }
    else if (iBend < 0)
    {
        dw = (DWORD)(((-iBend) * (LONG)(256.0 * (1.0 - 1.0 / EQUAL / EQUAL))) >> 8);
        dwOrig -= (DWORD)(AsULMUL(dw, dwOrig) >> 15);
    }

    return dwOrig;
}


#pragma code_seg()
//=======================================================================
// Opl3_CalcVolume - This calculates the attenuation for an operator.
//
//inputs
//        BYTE    bOrigAtten - original attenuation in 0.75 dB units
//        BYTE    bChannel - MIDI channel
//        BYTE    bVelocity - velocity of the note
//        BYTE    bOper - operator number (from 0 to 3)
//        BYTE    bMode - voice mode (from 0 through 7 for
//                                modulator/carrier selection)
//returns
//        BYTE - new attenuation in 0.75 dB units, maxing out at 0x3f.
//=======================================================================
BYTE 
CMiniportMidiStreamFM::
Opl3_CalcVolume(BYTE bOrigAtten,BYTE bChannel,BYTE bVelocity,BYTE bOper,BYTE bMode)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    BYTE        bVolume;
    WORD        wTemp;
    WORD        wMin;

    switch (bMode) {
        case 0:
                bVolume = (BYTE)(bOper == 3);
                break;
        case 1:
                bVolume = (BYTE)((bOper == 1) || (bOper == 3));
                break;
        case 2:
                bVolume = (BYTE)((bOper == 0) || (bOper == 3));
                break;
        case 3:
                bVolume = (BYTE)(bOper != 1);
                break;
        case 4:
                bVolume = (BYTE)((bOper == 1) || (bOper == 3));
                break;
        case 5:
                bVolume = (BYTE)(bOper >= 1);
                break;
        case 6:
                bVolume = (BYTE)(bOper <= 2);
                break;
        case 7:
                bVolume = TRUE;
                break;
        };
    if (!bVolume)
        return bOrigAtten; /* this is a modulator wave */

    wMin =(m_wSynthAttenL < m_wSynthAttenR) ? m_wSynthAttenL : m_wSynthAttenR;
    wTemp = bOrigAtten + 
            ((wMin << 1) +
            m_bChanAtten[bChannel] + 
            gbVelocityAtten[bVelocity >> 1]);
    return (wTemp > 0x3f) ? (BYTE) 0x3f : (BYTE) wTemp;
}

#pragma code_seg()
// ===========================================================================
// Opl3_ChannelNotesOff - turn off all notes on a channel
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_ChannelNotesOff(BYTE bChannel)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    int i;

    for (i = 0; i < NUM2VOICES; i++) 
    {
       if ((m_Voice[ i ].bOn) && (m_Voice[ i ].bChannel == bChannel)) 
       {
          Opl3_NoteOff(m_Voice[i].bPatch, m_Voice[i].bNote,m_Voice[i].bChannel, 0) ;
       }
    }
}

#pragma code_seg()
// ===========================================================================
/* Opl3_ChannelVolume - set the volume level for an individual channel.
 *
 * inputs
 *      BYTE    bChannel - channel number to change
 *      WORD    wAtten  - attenuation in 1.5 db units
 *
 * returns
 *      none
 */
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_ChannelVolume(BYTE bChannel, WORD wAtten)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    m_bChanAtten[bChannel] = (BYTE)wAtten;

    Opl3_SetVolume(bChannel);
}

#pragma code_seg()
// ===========================================================================
//  void Opl3_SetVolume
//
//  Description:
//     This should be called if a volume level has changed.
//     This will adjust the levels of all the playing voices.
//
//  Parameters:
//     BYTE bChannel
//        channel # of 0xFF for all channels
//
//  Return Value:
//     Nothing.
//
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_SetVolume
(
    BYTE   bChannel
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD            i, j, wTemp, wOffset ;
   noteStruct FAR  *lpPS ;
   BYTE            bMode, bStereo ;

   // Make sure that we are actually open...
   if (!glpPatch)
      return ;

   // Loop through all the notes looking for the right
   // channel.  Anything with the right channel gets
   // its pitch bent.
   for (i = 0; i < NUM2VOICES; i++)
   {
      if ((m_Voice[ i ].bChannel == bChannel) || (bChannel == 0xff))
      {
         // Get a pointer to the patch
         lpPS = &(glpPatch + m_Voice[ i ].bPatch) -> note ;

         // Modify level for each operator, IF they are carrier waves...
         bMode = (BYTE) ( (lpPS->bAtC0[0] & 0x01) * 2 + 4);

         for (j = 0; j < 2; j++)
         {
            wTemp = (BYTE) Opl3_CalcVolume(
               (BYTE) (lpPS -> op[j].bAt40 & (BYTE) 0x3f),
               m_Voice[i].bChannel, m_Voice[i].bVelocity, 
               (BYTE) j,            bMode ) ;

            // Write new value.
            wOffset = gw2OpOffset[ i ][ j ] ;
            m_Miniport->SoundMidiSendFM(
               m_PortBase, 0x40 + wOffset,
               (BYTE) ((lpPS -> op[j].bAt40 & (BYTE)0xc0) | (BYTE) wTemp) ) ;
         }

         // Do stereo pan, but cut left or right channel if needed.
         bStereo = Opl3_CalcStereoMask( m_Voice[ i ].bChannel ) ;
         wOffset = i;
         if (i >= (NUM2VOICES / 2))
             wOffset += (0x100 - (NUM2VOICES / 2));
         m_Miniport->SoundMidiSendFM(m_PortBase, 0xc0 + wOffset, (BYTE)(lpPS -> bAtC0[ 0 ] & bStereo) ) ;
      }
   }
} // end of Opl3_SetVolume

#pragma code_seg()
// ===========================================================================
// Opl3_SetPan - set the left-right pan position.
//
// inputs
//      BYTE    bChannel - channel number to alter
//      BYTE    bPan     - 0-47 for left, 81-127 for right, or somewhere in the middle.
//
// returns - none
//
//  As a side note, I think it's odd that (since 64 = CENTER, 127 = RIGHT and 0 = LEFT)
//  there are 63 intermediate gradations for the left side, but 62 for the right.
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_SetPan(BYTE bChannel, BYTE bPan)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    /* change the pan level */
    if (bPan > (64 + 16))
            m_bStereoMask[bChannel] = 0xef;      /* let only right channel through */
    else if (bPan < (64 - 16))
            m_bStereoMask[bChannel] = 0xdf;      /* let only left channel through */
    else
            m_bStereoMask[bChannel] = 0xff;      /* let both channels */

    /* change any curently playing patches */
    Opl3_SetVolume(bChannel);
}


#pragma code_seg()
// ===========================================================================
//  void Opl3_PitchBend
//
//  Description:
//     This pitch bends a channel.
//
//  Parameters:
//     BYTE bChannel
//        channel
//
//     short iBend
//        values from -32768 to 32767, being -2 to +2 half steps
//
//  Return Value:
//     Nothing.
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_PitchBend
(
    BYTE        bChannel,
    short        iBend
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD   i, wTemp[ 2 ], wOffset, j ;
   DWORD  dwNew ;

   // Remember the current bend..
   m_iBend[ bChannel ] = iBend ;

   // Loop through all the notes looking for 
   // the correct channel.  Anything with the 
   // correct channel gets its pitch bent...
   for (i = 0; i < NUM2VOICES; i++)
      if (m_Voice[ i ].bChannel == bChannel)
      {
         j = 0 ;
         dwNew = Opl3_CalcBend( m_Voice[ i ].dwOrigPitch[ j ], iBend ) ;
         wTemp[ j ] = Opl3_CalcFAndB( dwNew ) ;
         m_Voice[ i ].bBlock[ j ] =
            (m_Voice[ i ].bBlock[ j ] & (BYTE) 0xe0) |
               (BYTE) (wTemp[ j ] >> 8) ;

         wOffset = i;
         if (i >= (NUM2VOICES / 2))
             wOffset += (0x100 - (NUM2VOICES / 2));

         m_Miniport->SoundMidiSendFM(m_PortBase, AD_BLOCK + wOffset, m_Voice[ i ].bBlock[ 0 ] ) ;
         m_Miniport->SoundMidiSendFM(m_PortBase, AD_FNUMBER + wOffset, (BYTE) wTemp[ 0 ] ) ;
      }
} // end of Opl3_PitchBend


#pragma code_seg()
// ===========================================================================
//  Opl3_CalcStereoMask - This calculates the stereo mask.
//
//  inputs
//            BYTE  bChannel - MIDI channel
//  returns
//            BYTE  mask (for register 0xc0-c8) for eliminating the
//                  left/right/both channels
// ===========================================================================
BYTE 
CMiniportMidiStreamFM::
Opl3_CalcStereoMask(BYTE bChannel)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    WORD        wLeft, wRight;

    /* figure out the basic levels of the 2 channels */
    wLeft = (m_wSynthAttenL << 1) + m_bChanAtten[bChannel];
    wRight = (m_wSynthAttenR << 1) + m_bChanAtten[bChannel];

    /* if both are too quiet then mask to nothing */
    if ((wLeft > 0x3f) && (wRight > 0x3f))
        return 0xcf;

    /* if one channel is significantly quieter than the other than
        eliminate it */
    if ((wLeft + 8) < wRight)
        return (BYTE)(0xef & m_bStereoMask[bChannel]);   /* right is too quiet so eliminate */
    else if ((wRight + 8) < wLeft)
        return (BYTE)(0xdf & m_bStereoMask[bChannel]);   /* left too quiet so eliminate */
    else
        return (BYTE)(m_bStereoMask[bChannel]);  /* use both channels */
}

#pragma code_seg()
//------------------------------------------------------------------------
//  WORD Opl3_FindEmptySlot
//
//  Description:
//     This finds an empty note-slot for a MIDI voice.
//     If there are no empty slots then this looks for the oldest
//     off note.  If this doesn't work then it looks for the oldest
//     on-note of the same patch.  If all notes are still on then
//     this finds the oldests turned-on-note.
//
//  Parameters:
//     BYTE bPatch
//        MIDI patch that will replace it.
//
//  Return Value:
//     WORD
//        note slot #
//
//
//------------------------------------------------------------------------
WORD 
CMiniportMidiStreamFM::
Opl3_FindEmptySlot(BYTE bPatch)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD   i, found ;
   DWORD  dwOldest ;

   // First, look for a slot with a time == 0
   for (i = 0;  i < NUM2VOICES; i++)
      if (!m_Voice[ i ].dwTime)
         return ( i ) ;

   // Now, look for a slot of the oldest off-note
   dwOldest = 0xffffffff ;
   found = 0xffff ;

   for (i = 0; i < NUM2VOICES; i++)
      if (!m_Voice[ i ].bOn && (m_Voice[ i ].dwTime < dwOldest))
      {
         dwOldest = m_Voice[ i ].dwTime ;
         found = i ;
      }
   if (found != 0xffff)
      return ( found ) ;

   // Now, look for a slot of the oldest note with
   // the same patch
   dwOldest = 0xffffffff ;
   found = 0xffff ;
   for (i = 0; i < NUM2VOICES; i++)
      if ((m_Voice[ i ].bPatch == bPatch) && (m_Voice[ i ].dwTime < dwOldest))
      {
         dwOldest = m_Voice[ i ].dwTime ;
         found = i ;
      }
   if (found != 0xffff)
      return ( found ) ;

   // Now, just look for the oldest voice
   found = 0 ;
   dwOldest = m_Voice[ found ].dwTime ;
   for (i = (found + 1); i < NUM2VOICES; i++)
      if (m_Voice[ i ].dwTime < dwOldest)
      {
         dwOldest = m_Voice[ i ].dwTime ;
         found = i ;
      }

   return ( found ) ;

} // end of Opl3_FindEmptySlot()

#pragma code_seg()
//------------------------------------------------------------------------
//  WORD Opl3_SetSustain
//
//  Description:
//     Set the sustain controller on the current channel.
//
//  Parameters:
//     BYTE bSusLevel
//        The new sustain level 
//
//
//------------------------------------------------------------------------
VOID
CMiniportMidiStreamFM::
Opl3_SetSustain(BYTE bChannel,BYTE bSusLevel)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    WORD            i;

    if (m_bSustain[ bChannel ] && !bSusLevel)
    {
        // Sustain has just been turned off for this channel
        // Go through and turn off all notes that are being held for sustain
        //
        for (i = 0; i < NUM2VOICES; i++)
        {
            if ((bChannel == m_Voice[ i ].bChannel) &&
                m_Voice[ i ].bSusHeld)
            {
                Opl3_NoteOff(m_Voice[i].bPatch, m_Voice[i].bNote, m_Voice[i].bChannel, 0);
            }
        }
    }
    m_bSustain[ bChannel ] = bSusLevel;
}

#pragma code_seg("PAGE")
// ===========================================================================
// CpuNEC98TypeCheck - Check CPU Type. Return TRUE if CPU = NEC_98
// ===========================================================================
BOOLEAN CpuNEC98TypeCheck(VOID)
{
    PAGED_CODE();
    BOOLEAN isNEC98 = FALSE;

    NTSTATUS ntStatus;
    UNICODE_STRING Identifier;
    RTL_QUERY_REGISTRY_TABLE Table[2];

    RtlInitUnicodeString( &Identifier, NULL );
    RtlZeroMemory( Table, sizeof(Table) );

    Table[0].Flags        = RTL_QUERY_REGISTRY_DIRECT;
    Table[0].Name         = L"Identifier";
    Table[0].EntryContext = &Identifier;
    Table[0].DefaultType  = REG_SZ;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_ABSOLUTE,
                L"\\Registry\\MACHINE\\HARDWARE\\DESCRIPTION\\System",
                Table,
                NULL,
                NULL );

    if( NT_SUCCESS( ntStatus ) && _wcsicmp( Identifier.Buffer, L"NEC PC-98" ) == 0 )
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CpuNEC98TypeCheck; CPU=NEC_98"));
        isNEC98 = TRUE;
    }

    RtlFreeUnicodeString( &Identifier );

    return isNEC98;
}

#pragma code_seg("PAGE")
// ===========================================================================
// InitNEC98 - Change OPN to OPL for NEC98
// ===========================================================================
void InitNEC98(void)
{
/* NEC Original IO */
#define SI_REG                          (0x0F4A)
#define NS_REG_CS                       (0x148E)
#define NS_REG_YMF                      (0x548E)
#define SOUNDID_REG                     (0xA460)
#define OPL_REG                         (0x1488)

    PAGED_CODE();
    UCHAR mode;
    UCHAR WssID;
    //
    // OPN -> OPL
    //
    if ( (READ_PORT_UCHAR((PUCHAR)NS_REG_CS)) != 0xFF )
    {
        //
        //Read WSS Sound ID of NS register for type of built in CS4231 machine.
        //
        WRITE_PORT_UCHAR((PUCHAR)NS_REG_CS, 0x00);
        WssID = READ_PORT_UCHAR((PUCHAR)NS_REG_CS + 1);
    }
    else if ( (READ_PORT_UCHAR((PUCHAR)NS_REG_YMF)) != 0xFF )
    {
        //
        //Read WSS Sound ID of NS register for type of built in YMF7xx machine.
        //
        WRITE_PORT_UCHAR((PUCHAR)NS_REG_YMF, 0x00);
        WssID = READ_PORT_UCHAR((PUCHAR)NS_REG_YMF + 1);
    }
    else
    {
        //
        // Doesn't exist sound device.
        //
        return;
    }
    //
    // Change OPN to OPL when OPL exists.
    //
    if ( (WssID & 0x02) == 0x00 )
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("NEC98 Change OPN to OPL"));
        //
        // Enable OPL I/O.
        //
        mode = READ_PORT_UCHAR((PUCHAR)SOUNDID_REG);
        mode = (mode & 0xf0) | 0x03;
        WRITE_PORT_UCHAR((PUCHAR)SOUNDID_REG, mode);

        //
        // Cancel YMF297 COM.
        //
        WRITE_PORT_UCHAR((PUCHAR)(SI_REG + 0), 0x01);
        WRITE_PORT_UCHAR((PUCHAR)(SI_REG + 1), 0x00);

        //
        // Initialize OPL.
        //
        WRITE_PORT_UCHAR((PUCHAR)(OPL_REG + 2), 0x05);
        WRITE_PORT_UCHAR((PUCHAR)(OPL_REG + 3), 0x05);
        WRITE_PORT_UCHAR((PUCHAR)(OPL_REG + 2), 0x08);
        WRITE_PORT_UCHAR((PUCHAR)(OPL_REG + 3), 0x04);
        KeStallExecutionProcessor(90);                      // Wait 90us
        WRITE_PORT_UCHAR((PUCHAR)(OPL_REG + 3), 0x00);

        //
        // Set OPL Index value.
        //
        WRITE_PORT_UCHAR((PUCHAR)(OPL_REG)    , 0xF7);
        WRITE_PORT_UCHAR((PUCHAR)(OPL_REG + 1), 0x00);

    }
}


#pragma code_seg("PAGE")
// ===========================================================================
//  NEC98PreAdapterPowerNotify
//  NEC98 Wishes to be notified of power notifications before the adapter.
//  Specifically, if power is resuming from hibernation, change OPN -> OPL.
// ===========================================================================
void NEC98PreAdapterPowerNotify(DEVICE_POWER_STATE oldState,DEVICE_POWER_STATE newState)
{
    switch (oldState)
    {
        case PowerDeviceD0:
        case PowerDeviceD1:
            //  D0->D?/D1->D? not restore
            break;
        case PowerDeviceD2:
        case PowerDeviceD3:
            switch (newState)
            {
                case PowerDeviceD0:
                case PowerDeviceD1:
                    InitNEC98();
                    break;
                case PowerDeviceD2:
                case PowerDeviceD3:
                    //  D2/D3->D2/D3 not restore
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
}

#pragma code_seg("PAGE")

=== fmsynth/miniport.h ===
// Copyright (c) 1997-1999 Microsoft Corporation.  All rights reserved.
// ======================================================================
//  miniport.h
//      defines globals used by miniport.cpp
//
// ======================================================================
/* MIDI defines */
#define NUMCHANNELS                     (16)
#define NUMPATCHES                      (256)
#define DRUMCHANNEL                     (9)     /* midi channel 10 */


#define BCODE
#define fEnabled TRUE



#define AsULMUL(a, b) ((DWORD)((DWORD)(a) * (DWORD)(b)))
#define AsLSHL(a, b) ((DWORD)((DWORD)(a) << (DWORD)(b)))
#define AsULSHR(a, b) ((DWORD)((DWORD)(a) >> (DWORD)(b)))

#define AsMemCopy CopyMemory

// indexed FM registers

#define AD_LSI                          (0x000)
#define AD_LSI2                         (0x101)
#define AD_TIMER1                       (0x001)
#define AD_TIMER2                       (0x002)
#define AD_MASK                         (0x004)
#define AD_CONNECTION                   (0x104)
#define AD_NEW                          (0x105)
#define AD_NTS                          (0x008)
#define AD_MULT                         (0x020)
#define AD_MULT2                        (0x120)
#define AD_LEVEL                        (0x040)
#define AD_LEVEL2                       (0x140)
#define AD_AD                           (0x060)
#define AD_AD2                          (0x160)
#define AD_SR                           (0x080)
#define AD_SR2                          (0x180)
#define AD_FNUMBER                      (0x0a0)
#define AD_FNUMBER2                     (0x1a0)
#define AD_BLOCK                        (0x0b0)
#define AD_BLOCK2                       (0x1b0)
#define AD_DRUM                         (0x0bd)
#define AD_FEEDBACK                     (0x0c0)
#define AD_FEEDBACK2                    (0x1c0)
#define AD_WAVE                         (0x0e0)
#define AD_WAVE2                        (0x1e0)

/* transformation of linear velocity value to
        logarithmic attenuation */
BYTE gbVelocityAtten[64] = {
        40, 37, 35, 33, 31, 29, 27, 25, 24, 22, 21, 20, 19, 18, 17, 16,
        16, 15, 14, 14, 13, 13, 12, 12, 11, 11, 10, 10, 9,  9,  8,  8,
        7,  7,  6,  6,  6,  5,  5,  5,  4,  4,  4,  4,  3,  3,  3,  3,
        2,  2,  2,  2,  2,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0 };
/*
                                        o
                                     o
                                   o
                                 o
                               o
                             o
                           o
                         o
                        o
                      o
                     o
                    o
                   o
                  o
                 o
                o
                o
               o
              o
              o
             o
             o
            o
            o
           o
           o
          o
          o
         o
         o
        o
        o
       o
       o
      o
      o
      o
     o
     o
     o
    o
    o
    o
    o
   o
   o
   o
   o
  o
  o
  o
  o
  o
 o
 o
 o
 o
 o
o
o
o
o
o
o
*/

BYTE BCODE gbPercMap[53][2] =
{
   {  0, 35 },
   {  0, 35 },
   {  2, 52 },
   {  3, 48 },
   {  4, 58 },
   {  5, 60 },
   {  6, 47 },
   {  7, 43 },
   {  6, 49 },
   {  9, 43 },
   {  6, 51 },
   { 11, 43 },
   {  6, 54 },
   {  6, 57 },
   { 14, 72 },
   {  6, 60 },
   { 16, 76 },
   { 17, 84 },
   { 18, 36 },
   { 19, 76 },
   { 20, 84 },
   { 21, 83 },
   { 22, 84 },
   { 23, 24 },
   { 16, 77 },
   { 25, 60 },
   { 26, 65 },
   { 27, 59 },
   { 28, 51 },
   { 29, 45 },
   { 30, 71 },
   { 31, 60 },
   { 32, 58 },
   { 33, 53 },
   { 34, 64 },
   { 35, 71 },
   { 36, 61 },
   { 37, 61 },
   { 38, 48 },
   { 39, 48 },
   { 40, 69 },
   { 41, 68 },
   { 42, 63 },
   { 43, 74 },
   { 44, 60 },
   { 45, 80 },
   { 46, 64 },
   { 47, 69 },
   { 48, 73 },
   { 49, 75 },
   { 50, 68 },
   { 51, 48 },
   { 52, 53 }
} ;


/* typedefs for MIDI patches */
#define PATCH_1_4OP             (0) /* use 4-operator patch */
#define PATCH_2_2OP             (1) /* use two 2-operator patches */
#define PATCH_1_2OP             (2) /* use one 2-operator patch */

#define NUM2VOICES   18
#define NUMOPS      4

#pragma pack (1)

typedef struct _operStruct {
    BYTE    bAt20;              /* flags which are send to 0x20 on fm */
    BYTE    bAt40;              /* flags seet to 0x40 */
                                /* the note velocity & midi velocity affect total level */
    BYTE    bAt60;              /* flags sent to 0x60 */
    BYTE    bAt80;              /* flags sent to 0x80 */
    BYTE    bAtE0;              /* flags send to 0xe0 */
} operStruct;

typedef struct _noteStruct {
    operStruct op[NUMOPS];      /* operators */
    BYTE    bAtA0[2];           /* send to 0xA0, A3 */
    BYTE    bAtB0[2];           /* send to 0xB0, B3 */
                                /* use in a patch, the block should be 4 to indicate
                                    normal pitch, 3 => octave below, etc. */
    BYTE    bAtC0[2];           /* sent to 0xc0, C3 */
    BYTE    bOp;                /* see PATCH_??? */
    BYTE    bDummy;             /* place holder */
} noteStruct;


typedef struct _patchStruct {
    noteStruct note;            /* note. This is all in the structure at the moment */
} patchStruct;


#include "patch.h"

#pragma pack()

/* MIDI */

typedef struct _voiceStruct {
        BYTE    bNote;                  /* note played */
        BYTE    bChannel;               /* channel played on */
        BYTE    bPatch;                 /* what patch is the note,
                                           drums patch = drum note + 128 */
        BYTE    bOn;                    /* TRUE if note is on, FALSE if off */
        BYTE    bVelocity;              /* velocity */
        BYTE    bJunk;                  /* filler */
        DWORD   dwTime;                 /* time that was turned on/off;
                                           0 time indicates that its not in use */
        DWORD   dwOrigPitch[2];         /* original pitch, for pitch bend */
        BYTE    bBlock[2];              /* value sent to the block */
        BYTE    bSusHeld;               /* turned off, but held on by sustain */
} voiceStruct;


/* a bit of tuning information */
#define FSAMP                           (50000.0)     /* sampling frequency */
#define PITCH(x)                        ((DWORD)((x) * (double) (1L << 19) / FSAMP))
                            /* x is the desired frequency,
                                == FNUM at b=1 */
#define EQUAL                           (1.059463094359)
#ifdef EUROPE
#       define  A                                                       (442.0)
#else
#       define  A                           (440.0)
#endif
#define ASHARP                          (A * EQUAL)
#define B                               (ASHARP * EQUAL)
#define C                               (B * EQUAL / 2.0)
#define CSHARP                          (C * EQUAL)
#define D                               (CSHARP * EQUAL)
#define DSHARP                          (D * EQUAL)
#define E                               (DSHARP * EQUAL)
#define F                               (E * EQUAL)
#define FSHARP                          (F * EQUAL)
#define G                               (FSHARP * EQUAL)
#define GSHARP                          (G * EQUAL)


/* operator offset location */
static WORD BCODE gw2OpOffset[ NUM2VOICES ][ 2 ] =
   {
     { 0x000,0x003 },
     { 0x001,0x004 },
     { 0x002,0x005 },
     { 0x008,0x00b },
     { 0x009,0x00c },
     { 0x00a,0x00d },
     { 0x010,0x013 },
     { 0x011,0x014 },
     { 0x012,0x015 },

     { 0x100,0x103 },
     { 0x101,0x104 },
     { 0x102,0x105 },
     { 0x108,0x10b },
     { 0x109,0x10c },
     { 0x10a,0x10d },
     { 0x110,0x113 },
     { 0x111,0x114 },
     { 0x112,0x115 },
   } ;

/* pitch values, from middle c, to octave above it */
static DWORD BCODE gdwPitch[12] = {
        PITCH(C), PITCH(CSHARP), PITCH(D), PITCH(DSHARP),
        PITCH(E), PITCH(F), PITCH(FSHARP), PITCH(G),
        PITCH(GSHARP), PITCH(A), PITCH(ASHARP), PITCH(B)};


=== fmsynth/patch.h ===
//   Copyright (c) 1996-1999 Microsoft Corporation.  All rights reserved.
// ==============================================
// This file is generated programmatically from
// a RIFF file synth.pat. 

// Please do not edit this file.
// ==============================================
patchStruct glpPatch[] = 
{
    {   //  1st patch struct
        0x01,0x8f,0xf2,0xf4,0x00,0x01,0x06,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  2nd patch struct
        0x01,0x4b,0xf2,0xf4,0x00,0x01,0x00,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  3rd patch struct
        0x01,0x49,0xf2,0xf4,0x00,0x01,0x00,0xf2,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  4th patch struct
        0x81,0x12,0xf2,0xf7,0x00,0x41,0x00,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  5th patch struct
        0x01,0x57,0xf1,0xf7,0x00,0x01,0x00,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  6th patch struct
        0x01,0x93,0xf1,0xf7,0x00,0x01,0x00,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  7th patch struct
        0x01,0x80,0xa1,0xf2,0x00,0x16,0x0e,0xf2,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  8th patch struct
        0x01,0x92,0xc2,0xf8,0x00,0x01,0x00,0xc2,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  9th patch struct
        0x0c,0x5c,0xf6,0xf4,0x00,0x81,0x00,0xf3,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  10th patch struct
        0x07,0x97,0xf3,0xf2,0x00,0x11,0x80,0xf2,0xf1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  11th patch struct
        0x17,0x21,0x54,0xf4,0x00,0x01,0x00,0xf4,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  12th patch struct
        0x98,0x62,0xf3,0xf6,0x00,0x81,0x00,0xf2,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  13th patch struct
        0x18,0x23,0xf6,0xf6,0x00,0x01,0x00,0xe7,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  14th patch struct
        0x15,0x91,0xf6,0xf6,0x00,0x01,0x00,0xf6,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  15th patch struct
        0x45,0x59,0xd3,0xf3,0x00,0x81,0x80,0xa3,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  16th patch struct
        0x03,0x49,0x75,0xf5,0x01,0x81,0x80,0xb5,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  17th patch struct
        0x71,0x92,0xf6,0x14,0x00,0x31,0x00,0xf1,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  18th patch struct
        0x72,0x14,0xc7,0x58,0x00,0x30,0x00,0xc7,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  19th patch struct
        0x70,0x44,0xaa,0x18,0x00,0xb1,0x00,0x8a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  20th patch struct
        0x23,0x93,0x97,0x23,0x01,0xb1,0x00,0x55,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  21th patch struct
        0x61,0x13,0x97,0x04,0x01,0xb1,0x80,0x55,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  22th patch struct
        0x24,0x48,0x98,0x2a,0x01,0xb1,0x00,0x46,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  23th patch struct
        0x61,0x13,0x91,0x06,0x01,0x21,0x00,0x61,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  24th patch struct
        0x21,0x13,0x71,0x06,0x00,0xa1,0x89,0x61,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  25th patch struct
        0x02,0x9c,0xf3,0x94,0x01,0x41,0x80,0xf3,0xc8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  26th patch struct
        0x03,0x54,0xf3,0x9a,0x01,0x11,0x00,0xf1,0xe7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  27th patch struct
        0x23,0x5f,0xf1,0x3a,0x00,0x21,0x00,0xf2,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  28th patch struct
        0x03,0x87,0xf6,0x22,0x01,0x21,0x80,0xf3,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  29th patch struct
        0x03,0x47,0xf9,0x54,0x00,0x21,0x00,0xf6,0x3a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  30th patch struct
        0x23,0x4a,0x91,0x41,0x01,0x21,0x05,0x84,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  31th patch struct
        0x23,0x4a,0x95,0x19,0x01,0x21,0x00,0x94,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  32th patch struct
        0x09,0xa1,0x20,0x4f,0x00,0x84,0x80,0xd1,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  33th patch struct
        0x21,0x1e,0x94,0x06,0x00,0xa2,0x00,0xc3,0xa6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  34th patch struct
        0x31,0x12,0xf1,0x28,0x00,0x31,0x00,0xf1,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  35th patch struct
        0x31,0x8d,0xf1,0xe8,0x00,0x31,0x00,0xf1,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  36th patch struct
        0x31,0x5b,0x51,0x28,0x00,0x32,0x00,0x71,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  37th patch struct
        0x01,0x8b,0xa1,0x9a,0x00,0x21,0x40,0xf2,0xdf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  38th patch struct
        0x21,0x8b,0xa2,0x16,0x00,0x21,0x08,0xa1,0xdf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  39th patch struct
        0x31,0x8b,0xf4,0xe8,0x00,0x31,0x00,0xf1,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  40th patch struct
        0x31,0x12,0xf1,0x28,0x00,0x31,0x00,0xf1,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  41th patch struct
        0x31,0x15,0xdd,0x13,0x01,0x21,0x00,0x56,0x26,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  42th patch struct
        0x31,0x16,0xdd,0x13,0x01,0x21,0x00,0x66,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  43th patch struct
        0x71,0x49,0xd1,0x1c,0x01,0x31,0x00,0x61,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  44th patch struct
        0x21,0x4d,0x71,0x12,0x01,0x23,0x80,0x72,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  45th patch struct
        0xf1,0x40,0xf1,0x21,0x01,0xe1,0x00,0x6f,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  46th patch struct
        0x02,0x1a,0xf5,0x75,0x01,0x01,0x80,0x85,0x35,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  47th patch struct
        0x02,0x1d,0xf5,0x75,0x01,0x01,0x80,0xf3,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  48th patch struct
        0x10,0x41,0xf5,0x05,0x01,0x11,0x00,0xf2,0xc3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  49th patch struct
        0x21,0x9b,0xb1,0x25,0x01,0xa2,0x01,0x72,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  50th patch struct
        0xa1,0x98,0x7f,0x03,0x01,0x21,0x00,0x3f,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  51st patch struct
        0xa1,0x93,0xc1,0x12,0x00,0x61,0x00,0x4f,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  52th patch struct
        0x21,0x18,0xc1,0x22,0x00,0x61,0x00,0x4f,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  53th patch struct
        0x31,0x5b,0xf4,0x15,0x00,0x72,0x83,0x8a,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  54th patch struct
        0xa1,0x90,0x74,0x39,0x00,0x61,0x00,0x71,0x67,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  55th patch struct
        0x71,0x57,0x54,0x05,0x00,0x72,0x00,0x7a,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  56th patch struct
        0x90,0x00,0x54,0x63,0x00,0x41,0x00,0xa5,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  57th patch struct
        0x21,0x92,0x85,0x17,0x00,0x21,0x01,0x8f,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  58th patch struct
        0x21,0x94,0x75,0x17,0x00,0x21,0x05,0x8f,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  59th patch struct
        0x21,0x94,0x76,0x15,0x00,0x61,0x00,0x82,0x37,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  60th patch struct
        0x31,0x43,0x9e,0x17,0x01,0x21,0x00,0x62,0x2c,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  61th patch struct
        0x21,0x9b,0x61,0x6a,0x00,0x21,0x00,0x7f,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  62th patch struct
        0x61,0x8a,0x75,0x1f,0x00,0x22,0x06,0x74,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  63th patch struct
        0xa1,0x86,0x72,0x55,0x01,0x21,0x83,0x71,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  64th patch struct
        0x21,0x4d,0x54,0x3c,0x00,0x21,0x00,0xa6,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  65th patch struct
        0x31,0x8f,0x93,0x02,0x01,0x61,0x00,0x72,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  66th patch struct
        0x31,0x8e,0x93,0x03,0x01,0x61,0x00,0x72,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x31,0x91,0x93,0x03,0x01,0x61,0x00,0x82,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x31,0x8e,0x93,0x0f,0x01,0x61,0x00,0x72,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x4b,0xaa,0x16,0x01,0x21,0x00,0x8f,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  70th patch struct
        0x31,0x90,0x7e,0x17,0x01,0x21,0x00,0x8b,0x0c,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  71th patch struct
        0x31,0x81,0x75,0x19,0x01,0x32,0x00,0x61,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  72th patch struct
        0x32,0x90,0x9b,0x21,0x00,0x21,0x00,0x72,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  73th patch struct
        0xe1,0x1f,0x85,0x5f,0x00,0xe1,0x00,0x65,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  74th patch struct
        0xe1,0x46,0x88,0x5f,0x00,0xe1,0x00,0x65,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  75th patch struct
        0xa1,0x9c,0x75,0x1f,0x00,0x21,0x00,0x75,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  76th patch struct
        0x31,0x8b,0x84,0x58,0x00,0x21,0x00,0x65,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  77th patch struct
        0xe1,0x4c,0x66,0x56,0x00,0xa1,0x00,0x65,0x26,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  78th patch struct
        0x62,0xcb,0x76,0x46,0x00,0xa1,0x00,0x55,0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  79th patch struct
        0x62,0x99,0x57,0x07,0x00,0xa1,0x00,0x56,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3b,0x00,0x02,0x00
    },{ //  80th patch struct
        0x62,0x93,0x77,0x07,0x00,0xa1,0x00,0x76,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3b,0x00,0x02,0x00
    },{ //  th patch struct
        0x22,0x59,0xff,0x03,0x02,0x21,0x00,0xff,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x0e,0xff,0x0f,0x01,0x21,0x00,0xff,0x0f,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x22,0x46,0x86,0x55,0x00,0x21,0x80,0x64,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x45,0x66,0x12,0x00,0xa1,0x00,0x96,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  85th patch struct
        0x21,0x8b,0x92,0x2a,0x01,0x22,0x00,0x91,0x2a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0xa2,0x9e,0xdf,0x05,0x00,0x61,0x40,0x6f,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  th patch struct
        0x20,0x1a,0xef,0x01,0x00,0x60,0x00,0x8f,0x06,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x8f,0xf1,0x29,0x00,0x21,0x80,0xf4,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x77,0xa5,0x53,0x94,0x00,0xa1,0x00,0xa0,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  90th patch struct
        0x61,0x1f,0xa8,0x11,0x00,0xb1,0x80,0x25,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x61,0x17,0x91,0x34,0x00,0x61,0x00,0x55,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  th patch struct
        0x71,0x5d,0x54,0x01,0x00,0x72,0x00,0x6a,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x97,0x21,0x43,0x00,0xa2,0x00,0x42,0x35,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0xa1,0x1c,0xa1,0x77,0x01,0x21,0x00,0x31,0x47,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  95th patch struct
        0x21,0x89,0x11,0x33,0x00,0x61,0x03,0x42,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0xa1,0x15,0x11,0x47,0x01,0x21,0x00,0xcf,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x3a,0xce,0xf8,0xf6,0x00,0x51,0x00,0x86,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x15,0x21,0x23,0x01,0x21,0x00,0x41,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x06,0x5b,0x74,0x95,0x00,0x01,0x00,0xa5,0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  100th patch struct
        0x22,0x92,0xb1,0x81,0x00,0x61,0x83,0xf2,0x26,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  th patch struct
        0x41,0x4d,0xf1,0x51,0x01,0x42,0x00,0xf2,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x61,0x94,0x11,0x51,0x01,0xa3,0x80,0x11,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x61,0x8c,0x11,0x31,0x00,0xa1,0x80,0x1d,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0xa4,0x4c,0xf3,0x73,0x01,0x61,0x00,0x81,0x23,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  105th patch struct
        0x02,0x85,0xd2,0x53,0x00,0x07,0x03,0xf2,0xf6,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x11,0x0c,0xa3,0x11,0x01,0x13,0x80,0xa2,0xe5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x11,0x06,0xf6,0x41,0x01,0x11,0x00,0xf2,0xe6,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x93,0x91,0xd4,0x32,0x00,0x91,0x00,0xeb,0x11,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x04,0x4f,0xfa,0x56,0x00,0x01,0x00,0xc2,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  110th patch struct
        0x21,0x49,0x7c,0x20,0x00,0x22,0x00,0x6f,0x0c,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x31,0x85,0xdd,0x33,0x01,0x21,0x00,0x56,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x20,0x04,0xda,0x05,0x02,0x21,0x81,0x8f,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x05,0x6a,0xf1,0xe5,0x00,0x03,0x80,0xc3,0xe5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x07,0x15,0xec,0x26,0x00,0x02,0x00,0xf8,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  115th patch struct
        0x05,0x9d,0x67,0x35,0x00,0x01,0x00,0xdf,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x18,0x96,0xfa,0x28,0x00,0x12,0x00,0xf8,0xe5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x10,0x86,0xa8,0x07,0x00,0x00,0x03,0xfa,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x11,0x41,0xf8,0x47,0x02,0x10,0x03,0xf3,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x01,0x8e,0xf1,0x06,0x02,0x10,0x00,0xf3,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  120th patch struct
        0x0e,0x00,0x1f,0x00,0x00,0xc0,0x00,0x1f,0xff,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x06,0x80,0xf8,0x24,0x00,0x03,0x88,0x56,0x84,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf8,0x00,0x00,0xd0,0x05,0x34,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf6,0x00,0x00,0xc0,0x00,0x1f,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0xd5,0x95,0x37,0xa3,0x00,0xda,0x40,0x56,0x37,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  125th patch struct
        0x35,0x5c,0xb2,0x61,0x02,0x14,0x08,0xf4,0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  126th patch struct
        0x0e,0x00,0xf6,0x00,0x00,0xd0,0x00,0x4f,0xf5,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  127th patch struct
        0x26,0x00,0xff,0x01,0x00,0xe4,0x00,0x12,0x16,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  128th patch struct
        0x00,0x00,0xf3,0xf0,0x00,0x00,0x00,0xf6,0xc9,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  129th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  130th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  133th patch struct 
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  135th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  138th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  140th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  143th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  145th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  148th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  150th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  153th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  155th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  158th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  160th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  164th patch struct    FIRST DRUM patch. note 35
        0x10,0x44,0xf8,0x77,0x02,0x11,0x00,0xf3,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  165th patch struct
        0x10,0x44,0xf8,0x77,0x02,0x11,0x00,0xf3,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x02,0x07,0xf9,0xff,0x00,0x11,0x00,0xf8,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x00,0xfc,0x05,0x02,0x00,0x00,0xfa,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x02,0xff,0x07,0x00,0x01,0x00,0xff,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x00,0xfc,0x05,0x02,0x00,0x00,0xfa,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  170th patch struct
        0x00,0x00,0xf6,0x0c,0x00,0x00,0x00,0xf6,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x0c,0x00,0xf6,0x08,0x00,0x12,0x00,0xfb,0x47,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x0c,0x00,0xf6,0x08,0x00,0x12,0x05,0x7b,0x47,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  175th patch struct
        0x0c,0x00,0xf6,0x02,0x00,0x12,0x00,0xcb,0x43,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf6,0x00,0x00,0xd0,0x00,0x9f,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  180th patch struct
        0x0e,0x08,0xf8,0x42,0x00,0x07,0x4a,0xf4,0xe4,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf5,0x30,0x00,0xd0,0x0a,0x9f,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x0a,0xe4,0xe4,0x03,0x07,0x5d,0xf5,0xe5,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x02,0x03,0xb4,0x04,0x00,0x05,0x0a,0x97,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x4e,0x00,0xf6,0x00,0x00,0x9e,0x00,0x9f,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  185th patch struct
        0x11,0x45,0xf8,0x37,0x02,0x10,0x08,0xf3,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf6,0x00,0x00,0xd0,0x00,0x9f,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x80,0x00,0xff,0x03,0x03,0x10,0x0d,0xff,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  th patch struct note 59
        0x0e,0x08,0xf8,0x42,0x00,0x07,0x51,0xf4,0xe4,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct note 60
        0x06,0x0b,0xf5,0x0c,0x00,0x02,0x00,0xf5,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  190th patch struct note 61
        0x01,0x00,0xfa,0xbf,0x00,0x02,0x00,0xc8,0x97,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x37,0x00,0x02,0x00
    },{ //  th patch struct note 62
        0x01,0x51,0xfa,0x87,0x00,0x01,0x00,0xfa,0xb7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct note 63
        0x01,0x54,0xfa,0x8d,0x00,0x02,0x00,0xf8,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct note 64
        0x01,0x59,0xfa,0x88,0x00,0x02,0x00,0xf8,0xb6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct note 65
        0x01,0x00,0xf9,0x0a,0x03,0x00,0x00,0xfa,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  195th patch struct note 66
        0x00,0x80,0xf9,0x89,0x03,0x00,0x00,0xf6,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct note 67
        0x03,0x80,0xf8,0x88,0x03,0x0c,0x08,0xf6,0xb6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3f,0x00,0x02,0x00
    },{ //  th patch struct note 68
        0x03,0x85,0xf8,0x88,0x03,0x0c,0x00,0xf6,0xb6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3f,0x00,0x02,0x00
    },{ //  th patch struct note 69
        0x0e,0x40,0x76,0x4f,0x00,0x00,0x08,0x77,0x18,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct note 70
        0x0e,0x40,0xc8,0x49,0x00,0x03,0x00,0x9b,0x69,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  200th patch struct note 71
        0xd7,0xdc,0xad,0x05,0x03,0xc7,0x00,0x8d,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  201th patch struct note 72
        0xd7,0xdc,0xa8,0x04,0x03,0xc7,0x00,0x88,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  202th patch struct note 73
        0x80,0x00,0xf6,0x06,0x03,0x11,0x00,0x67,0x17,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  203th patch struct note 74
        0x80,0x00,0xf5,0x05,0x02,0x11,0x09,0x46,0x16,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  204th patch struct note 75
        0x06,0x3f,0x00,0xf4,0x00,0x15,0x00,0xf7,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x31,0x00,0x02,0x00
    },{ //  205th patch struct     42nd DRUM patch note 76
        0x06,0x3f,0x00,0xf4,0x03,0x12,0x00,0xf7,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  206th patch struct note 77 (low wood block from 60 high bongo)
        0x06,0x0b,0xf5,0x0c,0x00,0x02,0x00,0xf5,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x36,0x00,0x02,0x00
//        0x06,0x0b,0xf5,0x0c,0x00,0x02,0x00,0xf5,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  207th patch struct note 78 (mute cuica from 62 mute hi conga)
        0x01,0x51,0xfa,0x87,0x00,0x01,0x00,0xfa,0xb7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x36,0x00,0x02,0x00
//        0x01,0x51,0xfa,0x87,0x00,0x01,0x00,0xfa,0xb7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  208th patch struct note 79 (open cuica from 63 open hi conga)
        0x01,0x54,0xfa,0x8d,0x00,0x02,0x00,0xf8,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x36,0x00,0x02,0x00
//        0x01,0x54,0xfa,0x8d,0x00,0x02,0x00,0xf8,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  209th patch struct note 80 (mute triangle from NT - note 53 ride bell)
        0x01,0x2E,0xF5,0xF5,0x05,0x11,0x02,0xA5,0x34,0x00,0x0E,0x08,0xF1,0xF1,0x02,0x18,0x05,0xC9,0xA6,0x02,0x9A,0x67,0x14,0x10,0x30,0x7E,0x01,0x9A 
//        0x01,0x2E,0xF5,0xF5,0x05,0x11,0x02,0xA5,0x34,0x00,0x0E,0x08,0xF1,0xF1,0x02,0x18,0x05,0xC9,0xA6,0x02,0x9A,0x67,0x10,0x10,0x30,0x7E,0x01,0x9A 
    },{ //  210th patch struct note 81 (open triangle from NT - note 81)
        0x29,0x27,0xF1,0x41,0x00,0x04,0x00,0xF7,0x43,0x00,0x9A,0xFE,0x05,0x00,0x00,0x52,0x50,0x9A,0x1E,0x06,0x00,0x00,0x1C,0x10,0x32,0x5A,0x02,0x6A
//        0x29,0x27,0xF1,0x41,0x00,0x04,0x00,0xF7,0x43,0x00,0x9A,0xFE,0x05,0x00,0x00,0x52,0x50,0x9A,0x1E,0x06,0x00,0x00,0x18,0x10,0x32,0x5A,0x02,0x6A
    },{ //  211th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  212th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  213th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  214th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  215th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  216th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  221th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  226th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  231th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  236th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  240th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  245th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  246th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  247th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  248th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  249th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  250th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  251th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  252th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  253th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  254th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  255th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  256th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    }
};

=== fmsynth/private.h ===
/*****************************************************************************
 * private.h - FM synth miniport private definitions
 *****************************************************************************
 * Copyright (c) 1997-1999 Microsoft Corporation.  All rights reserved.
 */

#ifndef _FMSYNTH_PRIVATE_H_
#define _FMSYNTH_PRIVATE_H_

#include "portcls.h"
#include "stdunk.h"
#include "ksdebug.h"

#include "miniport.h"

enum {
    CHAN_MASTER = (-1),
    CHAN_LEFT = 0,
    CHAN_RIGHT = 1
};

BOOLEAN CpuNEC98TypeCheck(VOID);

VOID InitNEC98(VOID);

/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportMidiFM
 *****************************************************************************
 * FM miniport.  This object is associated with the device and is
 * created when the device is started.  The class inherits IMiniportMidi
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportMidiFM
:   public IMiniportMidi,
    public IPowerNotify,
    public CUnknown
{
private:
    PPORTMIDI       m_Port;                 // Callback interface.
    PUCHAR          m_PortBase;             // Base port address.
    BOOLEAN         m_BoardNotResponsive;   // Indicates dead hardware.
    BOOLEAN         m_bInit;                // true if we have already done init.
    BOOLEAN         m_fStreamExists;        // True if we have a stream.

    BYTE            m_SavedRegValues[0x200]; // Shadow copies of the FM registers.
    POWER_STATE     m_PowerState;            // Saved power state (D0 = full power, D3 = off)
    BOOLEAN         m_volNodeNeeded;         // Whether we need to furnish a volume node.
    KSPIN_LOCK      m_SpinLock;              // Protects writes to hardware.

    /*************************************************************************
     * CMiniportMidiFM methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     *
     */
    NTSTATUS 
    ProcessResources
    (
        IN      PRESOURCELIST   ResourceList
    );

    void SoundMidiSendFM(PUCHAR PortBase, ULONG Address, UCHAR Data); // low-level--write registers

    BOOL SoundSynthPresent(IN PUCHAR base, IN PUCHAR inbase);   // detect if synth is present.
    BOOL SoundMidiIsOpl3(VOID);     // returns true if the device is an opl3 and false if not.
    VOID Opl3_BoardReset(VOID);
    VOID MiniportMidiFMResume(VOID);

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();

//  expand constructor to take bool for whether to include volume
    CMiniportMidiFM(PUNKNOWN pUnknownOuter,int createVolNode)
    :   CUnknown(pUnknownOuter)
    {
        m_volNodeNeeded = (createVolNode != 0);
    };

    ~CMiniportMidiFM();

    /*************************************************************************
     * IMiniport methods
     */
    STDMETHODIMP 
    GetDescription
    (   OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );
    STDMETHODIMP 
    DataRangeIntersection
    (   IN      ULONG           PinId
    ,   IN      PKSDATARANGE    DataRange
    ,   IN      PKSDATARANGE    MatchingDataRange
    ,   IN      ULONG           OutputBufferLength
    ,   OUT     PVOID           ResultantFormat
    ,   OUT     PULONG          ResultantFormatLength
    )
    {
        return STATUS_NOT_IMPLEMENTED;
    }

    /*************************************************************************
     * IMiniportMidi methods
     */
    STDMETHODIMP Init
    (
        IN      PUNKNOWN        UnknownNotUsed  OPTIONAL,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTMIDI       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    );
    STDMETHODIMP NewStream
    (
        OUT     PMINIPORTMIDISTREAM *   Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   Pin,
        IN      BOOLEAN                 Capture,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP *         ServiceGroup
    );
    STDMETHODIMP_(void) Service
    (   void
    );

    /*************************************************************************
     * IPowerNotify methods
     */
    STDMETHODIMP_(void) PowerChangeNotify(
        IN  POWER_STATE     PowerState
    );

    
/*************************************************************************
     * Friends
     */
    friend class CMiniportMidiStreamFM;

};

/*****************************************************************************
 * CMiniportMidiStreamFM
 *****************************************************************************
 * FM miniport stream.  This object is associated with a pin and is created
 * when the pin is instantiated.  The class inherits IMiniportMidiStream
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportMidiStreamFM
:   public IMiniportMidiStream,
    public CUnknown
{
private:
    CMiniportMidiFM *   m_Miniport;     // Parent miniport.
    PUCHAR              m_PortBase;     // Base port address.

    // midi stuff
    voiceStruct m_Voice[NUM2VOICES];  /* info on what voice is where */
    DWORD m_dwCurTime;    /* for note on/off */
    /* volume */
    WORD    m_wSynthAttenL;        /* in 1.5dB steps */
    WORD    m_wSynthAttenR;        /* in 1.5dB steps */

    /* support for volume property */
    LONG    m_MinVolValue;      // Minimum value for volume controller
    LONG    m_MaxVolValue;      // Maximum value for volume controller
    ULONG   m_VolStepDelta;     // Correlation between controller and actual decibels
    LONG    m_SavedVolValue[2]; // Saved value for volume controller

    /* channel volumes */
    BYTE    m_bChanAtten[NUMCHANNELS];       /* attenuation of each channel, in .75 db steps */
    BYTE    m_bStereoMask[NUMCHANNELS];              /* mask for left/right for stereo midi files */

    short   m_iBend[NUMCHANNELS];    /* bend for each channel */
    BYTE    m_bPatch[NUMCHANNELS];   /* patch number mapped to */
    BYTE    m_bSustain[NUMCHANNELS];   /* Is sustain in effect on this channel? */

    /*************************************************************************
     * CMiniportMidiStreamFM methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     */

    VOID WriteMidiData(DWORD dwData);
    // opl3 processing methods.
    VOID Opl3_ChannelVolume(BYTE bChannel, WORD wAtten);
    VOID Opl3_SetPan(BYTE bChannel, BYTE bPan);
    VOID Opl3_PitchBend(BYTE bChannel, short iBend);
    VOID Opl3_NoteOn(BYTE bPatch,BYTE bNote, BYTE bChannel, BYTE bVelocity,short iBend);
    VOID Opl3_NoteOff (BYTE bPatch,BYTE bNote, BYTE bChannel, BYTE bSustain);
    VOID Opl3_AllNotesOff(VOID);
    VOID Opl3_ChannelNotesOff(BYTE bChannel);
    WORD Opl3_FindFullSlot(BYTE bNote, BYTE bChannel);
    WORD Opl3_CalcFAndB (DWORD dwPitch);
    DWORD Opl3_CalcBend (DWORD dwOrig, short iBend);
    BYTE Opl3_CalcVolume (BYTE bOrigAtten, BYTE bChannel,BYTE bVelocity, BYTE bOper, BYTE bMode);
    BYTE Opl3_CalcStereoMask (BYTE bChannel);
    WORD Opl3_FindEmptySlot(BYTE bPatch);
    VOID Opl3_SetVolume(BYTE bChannel);
    VOID Opl3_FMNote(WORD wNote, noteStruct FAR * lpSN);
    VOID Opl3_SetSustain(BYTE bChannel, BYTE bSusLevel);

    void SetFMAtten(LONG channel, LONG level);
    LONG GetFMAtten(LONG channel)    {   return m_SavedVolValue[channel];    };

public:
    NTSTATUS
    Init
    (
        IN      CMiniportMidiFM *   Miniport,
        IN      PUCHAR              PortBase
    );

    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportMidiStreamFM);

    ~CMiniportMidiStreamFM();

    /*************************************************************************
     * IMiniportMidiStream methods
     */
    STDMETHODIMP SetFormat
    (
        IN      PKSDATAFORMAT   DataFormat
    );
    STDMETHODIMP SetState
    (
        IN      KSSTATE     State
    );
    STDMETHODIMP Read
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BufferLength,
        OUT     PULONG      BytesRead
    );
    STDMETHODIMP Write
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BytesToWrite,
        OUT     PULONG      BytesWritten
    );

/*************************************************************************
     * Friends
     */
    friend
    NTSTATUS BasicSupportHandler
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

    friend
    NTSTATUS PropertyHandler_Level
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

    friend
    NTSTATUS PropertyHandler_CpuResources
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

};

#endif
=== fmsynth/sources ===
# Copyright (c) 1997-1999 Microsoft Corporation.  All rights reserved.

TARGETNAME=fmsynth
TARGETTYPE=LIBRARY
TARGETPATH=..\lib


C_DEFINES=-D_WIN32 -DUNICODE -D_UNICODE -DUNDER_NT -DDEBUG_LEVEL=DEBUGLVL_TERSE

LINKER_FLAGS=-map

INCLUDES=..\inc

MSC_WARNING_LEVEL=-W3 -WX

SOURCES= miniport.cpp

=== inc/punknown.h ===
/*****************************************************************************
 * punknown.h - IUnknown definitions
 *****************************************************************************
 * Copyright (c) 1996-1999 Microsoft Corporation.  All rights reserved.
 */

#ifndef _UNKNOWN_H_
#define _UNKNOWN_H_

#ifdef __cplusplus
extern "C" {
#include <wdm.h>
}
#else
#include <wdm.h>
#endif

#include <windef.h>
#define COM_NO_WINDOWS_H
#include <basetyps.h>
#ifdef PUT_GUIDS_HERE
#include <initguid.h>
#endif


DEFINE_GUID(IID_IUnknown,
0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x46);

/*****************************************************************************
 * IUnknown
 *****************************************************************************
 * Base interface for otherwise unknown objects.
 */
#undef INTERFACE
#define INTERFACE IUnknown
DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD(QueryInterface)
    (   THIS_
        IN      REFIID,
        OUT     PVOID *
    )   PURE;

    STDMETHOD_(ULONG,AddRef)
    (   THIS
    )   PURE;

    STDMETHOD_(ULONG,Release)
    (   THIS
    )   PURE;
};
#undef INTERFACE

typedef IUnknown *PUNKNOWN;

/*****************************************************************************
 * PFNCREATEINSTANCE
 *****************************************************************************
 * Type for object create function.
 */
typedef
HRESULT
(*PFNCREATEINSTANCE)
(
    OUT PUNKNOWN *  Unknown,
    IN  REFCLSID    ClassId,
    IN  PUNKNOWN    OuterUnknown,
    IN  POOL_TYPE   PoolType
);





#endif

=== inc/stdunk.h ===
/*****************************************************************************
 * stdunk.h - standard IUnknown implementaton definitions
 *****************************************************************************
 * Copyright (c) 1997-1999 Microsoft Corporation.  All rights reserved.
 */

#ifndef _STDUNK_H_
#define _STDUNK_H_

#include "punknown.h"





/*****************************************************************************
 * Interfaces
 */

/*****************************************************************************
 * INonDelegatingUnknown
 *****************************************************************************
 * Non-delegating unknown interface.
 */
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD(NonDelegatingQueryInterface)  
    (   THIS_ 
        IN      REFIID, 
        OUT     PVOID *
    )   PURE;

    STDMETHOD_(ULONG,NonDelegatingAddRef)  
    (   THIS
    )   PURE;

    STDMETHOD_(ULONG,NonDelegatingRelease) 
    (   THIS
    )   PURE;
};

typedef INonDelegatingUnknown *PNONDELEGATINGUNKNOWN;





/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CUnknown
 *****************************************************************************
 * Base INonDelegatingUnknown implementation.
 */
class CUnknown : public INonDelegatingUnknown
{
private:

    LONG            m_lRefCount;        // Reference count.
    PUNKNOWN        m_pUnknownOuter;    // Outer IUnknown.

public:
	
    /*************************************************************************
	 * CUnknown methods.
     */
    CUnknown(PUNKNOWN pUnknownOuter);
	virtual ~CUnknown(void);
    PUNKNOWN GetOuterUnknown(void)
    {
        return m_pUnknownOuter;
    }

    /*************************************************************************
	 * INonDelegatingUnknown methods.
     */
	STDMETHODIMP_(ULONG) NonDelegatingAddRef
    (   void
    ); 
	STDMETHODIMP_(ULONG) NonDelegatingRelease
    (   void
    ); 
    STDMETHODIMP NonDelegatingQueryInterface	
	(
		REFIID		rIID, 
		PVOID *	    ppVoid
	);
};





/*****************************************************************************
 * Macros
 */

/*****************************************************************************
 * DECLARE_STD_UNKNOWN
 *****************************************************************************
 * Various declarations for standard objects based on CUnknown.
 */
#define DECLARE_STD_UNKNOWN()                                   \
    STDMETHODIMP NonDelegatingQueryInterface	                \
	(                                                           \
		REFIID		iid,                                        \
		PVOID *	    ppvObject                                   \
	);                                                          \
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv)        \
    {                                                           \
        return GetOuterUnknown()->QueryInterface(riid,ppv);     \
    };                                                          \
    STDMETHODIMP_(ULONG) AddRef()                               \
    {                                                           \
        return GetOuterUnknown()->AddRef();                     \
    };                                                          \
    STDMETHODIMP_(ULONG) Release()                              \
    {                                                           \
        return GetOuterUnknown()->Release();                    \
    };

#define DEFINE_STD_CONSTRUCTOR(Class)                           \
    Class(PUNKNOWN pUnknownOuter)                               \
    :   CUnknown(pUnknownOuter)                                 \
    {                                                           \
    }

#define QICAST(Type)                                            \
    PVOID((Type)(this))

#define QICASTUNKNOWN(Type)                                     \
    PVOID(PUNKNOWN((Type)(this)))

#define STD_CREATE_BODY_WITH_TAG_(Class,ppUnknown,pUnknownOuter,poolType,tag,base)   \
    NTSTATUS ntStatus;                                                  \
    Class *p = new(poolType,tag) Class(pUnknownOuter);                  \
    if (p)                                                              \
    {                                                                   \
        *ppUnknown = PUNKNOWN((base)(p));                               \
        (*ppUnknown)->AddRef();                                         \
        ntStatus = STATUS_SUCCESS;                                      \
    }                                                                   \
    else                                                                \
    {                                                                   \
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;                       \
    }                                                                   \
    return ntStatus

#define STD_CREATE_BODY_WITH_TAG(Class,ppUnknown,pUnknownOuter,poolType,tag) \
    STD_CREATE_BODY_WITH_TAG_(Class,ppUnknown,pUnknownOuter,poolType,tag,PUNKNOWN)

#define STD_CREATE_BODY_(Class,ppUnknown,pUnknownOuter,poolType,base) \
    STD_CREATE_BODY_WITH_TAG_(Class,ppUnknown,pUnknownOuter,poolType,'rCcP',base)

#define STD_CREATE_BODY(Class,ppUnknown,pUnknownOuter,poolType) \
    STD_CREATE_BODY_(Class,ppUnknown,pUnknownOuter,poolType,PUNKNOWN)






/*****************************************************************************
 * Functions
 */
#ifndef PC_KDEXT    // this is not needed for the KD extensions.
#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    size_t          iSize,
    POOL_TYPE       poolType
)
{
    PVOID result = ExAllocatePoolWithTag(poolType,iSize,'wNcP');

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    size_t          iSize,
    POOL_TYPE       poolType,
    ULONG           tag
)
{
    PVOID result = ExAllocatePoolWithTag(poolType,iSize,tag);

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

/*****************************************************************************
 * ::delete()
 *****************************************************************************
 * Delete function.
 */
inline void __cdecl operator delete
(
    PVOID pVoid
)
{
    ExFreePool(pVoid);
}


#endif //!_NEW_DELETE_OPERATORS_

#endif  // PC_KDEXT



#endif

=== mpu401/adapter.cpp ===
/*****************************************************************************
 * adapter.cpp - MPU401 adapter driver implementation.
 *****************************************************************************
 * Copyright (c) 1997-1999 Microsoft Corporation.  All rights reserved.
 *
 * Created 6/19/97, a-seemap
 *
 */

//
// All the GUIDS for all the miniports end up in this object.
//
#define PUT_GUIDS_HERE

#define STR_MODULENAME "MPU401Adapter: "
#define PC_NEW_NAMES 1

#define kUseDMusicMiniport 1

#include "portcls.h"
#include "ksdebug.h"

#if (kUseDMusicMiniport)
#include "dmusicks.h"
#endif  //  kUseDMusicMiniport

/*****************************************************************************
 * Defines
 */

#define MAX_MINIPORTS 1

#if (DBG)
#define SUCCEEDS(s) ASSERT(NT_SUCCESS(s))
#else
#define SUCCEEDS(s) (s)
#endif

/*****************************************************************************
 * Referenced forward
 */
extern "C"
NTSTATUS
AddDevice
(
        IN PVOID        Context1,
        IN PVOID        Context2
);

NTSTATUS
StartDevice
(
    IN      PDEVICE_OBJECT  pDeviceObject,  // Context for the class driver.
    IN      PIRP            pIrp,           // Context for the class driver.
    IN      PRESOURCELIST   ResourceList    // List of hardware resources.
);


#pragma code_seg("INIT")
/*****************************************************************************
 * DriverEntry()
 *****************************************************************************
 * This function is called by the operating system when the driver is loaded.
 * All adapter drivers can use this code without change.
 */
extern "C"
NTSTATUS
DriverEntry
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE, ("DriverEntry"));
//    _DbgPrintF(DEBUGLVL_ERROR, ("Starting breakpoint for debugging"));

    //
    // Tell the class driver to initialize the driver.
    //
    return PcInitializeAdapterDriver((PDRIVER_OBJECT)Context1,
                                     (PUNICODE_STRING)Context2,
                                     (PDRIVER_ADD_DEVICE)AddDevice);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * AddDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is added.
 * All adapter drivers can use this code without change.
 */
NTSTATUS
AddDevice
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE, ("AddDevice"));

    //
    // Tell the class driver to add the device.
    //
    return PcAddAdapterDevice((PDRIVER_OBJECT)Context1,(PDEVICE_OBJECT)Context2,StartDevice,MAX_MINIPORTS,0);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * InstallSubdevice()
 *****************************************************************************
 * This function creates and registers a subdevice consisting of a port
 * driver, a minport driver and a set of resources bound together.  It will
 * also optionally place a pointer to an interface on the port driver in a
 * specified location before initializing the port driver.  This is done so
 * that a common ISR can have access to the port driver during initialization,
 * when the ISR might fire.
 */
NTSTATUS
InstallSubdevice
(
    IN      PVOID               Context1,
    IN      PVOID               Context2,
    IN      PWCHAR              Name,
    IN      REFGUID             PortClassId,
    IN      REFGUID             MiniportClassId,
    IN      PUNKNOWN            UnknownAdapter      OPTIONAL,   //not used - null
    IN      PRESOURCELIST       ResourceList,                   //not optional, but can be EMPTY!
    IN      REFGUID             PortInterfaceId,
    OUT     PUNKNOWN *          OutPortInterface,   OPTIONAL    //not used - null
    OUT     PUNKNOWN *          OutPortUnknown      OPTIONAL    //not used - null
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE, ("InstallSubdevice"));

    ASSERT(Context1);
    ASSERT(Context2);
    ASSERT(Name);
    ASSERT(ResourceList);

    //
    // Create the port driver object
    //
    PPORT       port;
    NTSTATUS    ntStatus = PcNewPort(&port,PortClassId);

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Deposit the port somewhere if it's needed.
        //
        if (OutPortInterface)
        {
            //
            //  Failure here doesn't cause the entire routine to fail.
            //
            (void) port->QueryInterface
            (
                PortInterfaceId,
                (PVOID *) OutPortInterface
            );
        }

        PMINIPORT miniport;
        //
        // Create the miniport object
        //
        ntStatus = PcNewMiniport(&miniport,MiniportClassId);

        if (NT_SUCCESS(ntStatus))
        {
            //
            // Init the port driver and miniport in one go.
            //
            ntStatus = port->Init( (PDEVICE_OBJECT)Context1,
                                   (PIRP)Context2,
                                   miniport,
                                   NULL,   // interruptsync created in miniport.
                                   ResourceList);

            if (NT_SUCCESS(ntStatus))
            {
                //
                // Register the subdevice (port/miniport combination).
                //
                ntStatus = PcRegisterSubdevice( (PDEVICE_OBJECT)Context1,
                                                Name,
                                                port    );
#if DBG
                if (!(NT_SUCCESS(ntStatus)))
                {
                    _DbgPrintF(DEBUGLVL_TERSE, ("StartDevice: PcRegisterSubdevice failed"));
                }
#endif
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("InstallSubdevice: port->Init failed"));
            }

            //
            // We don't need the miniport any more.  Either the port has it,
            // or we've failed, and it should be deleted.
            //
            miniport->Release();
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("InstallSubdevice: PcNewMiniport failed"));
        }

        if (NT_SUCCESS(ntStatus))
        {
            //
            // Deposit the port as an unknown if it's needed.
            //
            if (OutPortUnknown)
            {
                //
                //  Failure here doesn't cause the entire routine to fail.
                //
                (void) port->QueryInterface
                (
                    IID_IUnknown,
                    (PVOID *) OutPortUnknown
                );
            }
        }
        else
        {
            //
            // Retract previously delivered port interface.
            //
            if (OutPortInterface && (*OutPortInterface))
            {
                (*OutPortInterface)->Release();
                *OutPortInterface = NULL;
            }
        }

        //
        // Release the reference which existed when PcNewPort() gave us the
        // pointer in the first place.  This is the right thing to do
        // regardless of the outcome.
        //
        port->Release();
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("InstallSubdevice: PcNewPort failed"));
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * StartDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is started.
 * It is responsible for starting the miniport. 
 * This code is specific to the adapter because it calls out miniports for  
 * functions that are specific to the adapter.
 */
NTSTATUS
StartDevice
(
    IN      PDEVICE_OBJECT  pDeviceObject,  // Context for the class driver.
    IN      PIRP            pIrp,           // Context for the class driver.
    IN      PRESOURCELIST   ResourceList    // List of hardware resources.
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);
    ASSERT(ResourceList);
    if (!ResourceList)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("StartDevice: NULL resource list"));
        return STATUS_INVALID_PARAMETER;
    }

    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    
    if (ResourceList->NumberOfEntries())
    {
#if (kUseDMusicMiniport)
        //
        // Start the UART miniport.
        //
        ntStatus = InstallSubdevice(
                                    pDeviceObject,
                                    pIrp,
                                    L"Uart",
                                    CLSID_PortDMus,
                                    CLSID_MiniportDriverDMusUART,
                                    NULL,
                                    ResourceList,
                                    IID_IPortDMus,
                                    NULL,
                                    NULL    // Not physically connected to anything.
                                    );
#else   //  (kUseDMusicMiniport)
        //
        // Start the UART miniport.
        //
        ntStatus = InstallSubdevice(
                                    pDeviceObject,
                                    pIrp,
                                    L"Uart",
                                    CLSID_PortMidi,
                                    CLSID_MiniportDriverUart,
                                    NULL,
                                    ResourceList,
                                    IID_IPortMidi,
                                    NULL,
                                    NULL    // Not physically connected to anything.
                                    );
#endif  //  (kUseDMusicMiniport)
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("StartDevice: no entries in resource list"));
    }
    return ntStatus;
}

=== mpu401/makefile ===
#############################################################################
#
#       Copyright (C) Microsoft Corporation 1991-1999
#       All Rights Reserved.
#
#       Makefile for wdm\audio\mpu401
#
#############################################################################

## Define WIN95_BUILD to build in the memphis
## build enviroment

!IFDEF WIN95_BUILD

ROOT = ..\..\..\..\..

IS_32   = TRUE
IS_OEM  = TRUE
DEVICEDIR = mpu401
COMMONMKFILE = $(DEVICEDIR).mk
DEPENDTARGETS = debug

!include $(ROOT)\dev\master.mk

## NT BUILD ENVIROMENT
!ELSE

#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT.
#
!INCLUDE $(NTMAKEENV)\makefile.def

!ENDIF

=== mpu401/mpu401.def ===
LIBRARY 	msmpu401.sys
DESCRIPTION	'MPU401 adapter driver'

=== mpu401/mpu401.htm ===
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-
1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>MPU-401 
</TITLE>
</HEAD>
<BODY LINK="#0000ff">

<FONT FACE="Verdana" SIZE=5><H2>MPU-401 
</H2>
</FONT><FONT FACE="Verdana" SIZE=2>
<P><span style="color:#FF0000;font-size:10pt;font-family:Arial">[This is preliminary 
documentation and subject to change.]</span></P>

<H3>SUMMARY</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
This WDM driver implements standard functionality for an MPU-401 device. The driver is extremely small 
because it leverages code built into PortCls. It simply specifies and connects the appropriate 
port and miniport, which already exist in PortCls. The Msmpu401 driver is used by audio devices when 
the MPU-401 hardware is on a separate devnode from other audio functionality.  If the MPU-401 shares 
a devnode with other subdevices (such as PCM wave, in the Sb16 device), the built-in DMusUART miniport
can still be used, but an adapter that handles multiple subdevices must be written.  The Sb16 sample 
illustrates how this can be done.

<P>
If the built-in miniport is insufficient, a custom miniport can be built to handle any additional 
functionality. There are a number of miniport samples in the DDK: the Dmusuart, Ddksynth, Fmsynth and 
Uart samples show how to build miniports that interface to the DMus and MIDI ports; Sb16 and Ac97 
include custom wave miniports. Additionally, the Ddksynth, Sb16 and Ac97 samples contain the necessary 
code to connect the custom miniport into the driver.  If you choose to pursue this, try to follow the 
sample as closely as possible.  You will prevent unnecessary complexity by taking advantage of what 
PortCls will do for you.

<P>
This sample is compliant with x86, Alpha, iA64, and AXP64 platforms. 
This driver builds properly with Microsoft&#174; Visual C&#174; 6.0. Since the driver is a PortCls client, it is compliant with Plug and Play and Power 
Management. There are no known issues with this driver.<P>

<H3>BUILDING THE SAMPLE</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>
To build this sample, enter the free or checked build environment and run <B>build</B> from the 98ddk\src\audio 
directory, rather than the mpu401 subdirectory. This sample links with Stdunk.lib, which is also built if you run 
build from 98ddk\src\audio. Once built, this sample produces msmpu401.sys. In addition to the files in the 
directory, the following files are needed to build this sample:<p>
Portcls.lib<br>
Libcntpr.lib<br>
Ksguid.lib<br>
Stdunk.lib<br>
Dmusicks.h<br>
Dmusprop.h<br>
Dmusbuff.h<br>
Ks.h<br>
Ksdebug.h<br>
Ksmedia.h<br>
Portcls.h<br>
Unknown.h<br>
Wdm.h<p>


<H3>CODE TOUR</H3>
<H4>File Manifest</H4>
</FONT><U><PRE>File&#9;&#9;Description
</U>
Adapter.cpp&#9;Source file 
Makefile&#9;Standard Windows NT makefile
Mpu401.rc&#9;Resource file 
Sources&#9;&#9;Dependency and include file

</FONT><P ALIGN="CENTER"><A HREF="#top"><FONT FACE="Verdana" SIZE=2>Top of page</FONT></A><FONT FACE="Verdana" SIZE=2> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 WIDTH=624>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff" HEIGHT=2>
<P></TD>
</TR>
</TABLE>

<FONT FACE="MS Sans Serif" SIZE=1><P>&copy; Microsoft Corporation 1999</FONT><FONT FACE="Verdana" SIZE=2> </P></FONT></BODY>
</HTML>

=== mpu401/mpu401.rc ===
/*      Copyright (c) Microsoft Corporation 1997-1999.  All rights reserved. */

#include <windows.h>

#include <ntverp.h>

#define VER_FILETYPE                VFT_DRV
#define VER_FILESUBTYPE             VFT2_DRV_SOUND
#define VER_FILEDESCRIPTION_STR     "MPU401 Adapter Driver"
#define VER_INTERNALNAME_STR	    "msmpu401.sys"
#define VER_ORIGINALFILENAME_STR    "msmpu401.sys"

#include "common.ver"

=== mpu401/sources ===
#   Copyright (c) 1996-1999 Microsoft Corporation.  All rights reserved.

TARGETNAME=msmpu401
TARGETTYPE=DRIVER
TARGETPATH=obj

TARGETLIBS= \
        $(SDK_LIB_PATH)\portcls.lib\
        $(SDK_LIB_PATH)\libcntpr.lib\
        $(SDK_LIB_PATH)\ksguid.lib\
        ..\lib\*\stdunk.lib

INCLUDES=..\inc

MSC_WARNING_LEVEL=-W3 -WX

C_DEFINES=-D_WIN32 -DUNICODE -D_UNICODE -DUNDER_NT -DDEBUG_LEVEL=DEBUGLVL_TERSE
LINKER_FLAGS=-map

SOURCES=\
        adapter.cpp     \
        mpu401.rc

=== sb16/adapter.cpp ===
/*****************************************************************************
 * adapter.cpp - SB16 adapter driver implementation.
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 *
 * This files does setup and resource allocation/verification for the SB16
 * card. It controls which miniports are started and which resources are
 * given to each miniport. It also deals with interrupt sharing between
 * miniports by hooking the interrupt and calling the correct DPC.
 */

//
// All the GUIDS for all the miniports end up in this object.
//
#define PUT_GUIDS_HERE

#define STR_MODULENAME "sb16Adapter: "

#include "common.h"





/*****************************************************************************
 * Defines
 */
#define MAX_MINIPORTS 5

#if (DBG)
#define SUCCEEDS(s) ASSERT(NT_SUCCESS(s))
#else
#define SUCCEEDS(s) (s)
#endif





/*****************************************************************************
 * Externals
 */
NTSTATUS
CreateMiniportWaveCyclicSB16
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);
NTSTATUS
CreateMiniportTopologySB16
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);





/*****************************************************************************
 * Referenced forward
 */
extern "C"
NTSTATUS
AddDevice
(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
);

NTSTATUS
StartDevice
(
    IN  PDEVICE_OBJECT  DeviceObject,   // Device object.
    IN  PIRP            Irp,            // IO request packet.
    IN  PRESOURCELIST   ResourceList    // List of hardware resources.
);

NTSTATUS
AssignResources
(
    IN  PRESOURCELIST   ResourceList,           // All resources.
    OUT PRESOURCELIST * ResourceListTopology,   // Topology resources.
    OUT PRESOURCELIST * ResourceListWave,       // Wave resources.
    OUT PRESOURCELIST * ResourceListWaveTable,  // Wave table resources.
    OUT PRESOURCELIST * ResourceListFmSynth,    // FM synth resources.
    OUT PRESOURCELIST * ResourceListUart,       // UART resources.
    OUT PRESOURCELIST * ResourceListAdapter     // a copy needed by the adapter
);

#ifdef DO_RESOURCE_FILTERING
extern "C"
NTSTATUS
AdapterDispatchPnp
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
);
#endif



#pragma code_seg("INIT")

/*****************************************************************************
 * DriverEntry()
 *****************************************************************************
 * This function is called by the operating system when the driver is loaded.
 * All adapter drivers can use this code without change.
 */
extern "C"
NTSTATUS
DriverEntry
(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
)
{
    PAGED_CODE();

    //
    // Tell the class driver to initialize the driver.
    //
    NTSTATUS ntStatus = PcInitializeAdapterDriver( DriverObject,
                                                   RegistryPathName,
                                                   AddDevice );

#ifdef DO_RESOURCE_FILTERING
    //
    // We want to do resource filtering, so we'll install our own PnP IRP handler.
    //
    if(NT_SUCCESS(ntStatus))
    {
        DriverObject->MajorFunction[IRP_MJ_PNP] = AdapterDispatchPnp;
    }
#endif

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * AddDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is added.
 * All adapter drivers can use this code without change.
 */
extern "C"
NTSTATUS
AddDevice
(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
)
{
    PAGED_CODE();

    //
    // Tell the class driver to add the device.
    //
    return PcAddAdapterDevice( DriverObject,
                               PhysicalDeviceObject,
                               PCPFNSTARTDEVICE( StartDevice ),
                               MAX_MINIPORTS,
                               0 );
}

/*****************************************************************************
 * InstallSubdevice()
 *****************************************************************************
 * This function creates and registers a subdevice consisting of a port
 * driver, a minport driver and a set of resources bound together.  It will
 * also optionally place a pointer to an interface on the port driver in a
 * specified location before initializing the port driver.  This is done so
 * that a common ISR can have access to the port driver during initialization,
 * when the ISR might fire.
 */
NTSTATUS
InstallSubdevice
(
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    IN      PWCHAR              Name,
    IN      REFGUID             PortClassId,
    IN      REFGUID             MiniportClassId,
    IN      PFNCREATEINSTANCE   MiniportCreate      OPTIONAL,
    IN      PUNKNOWN            UnknownAdapter      OPTIONAL,
    IN      PRESOURCELIST       ResourceList,
    IN      REFGUID             PortInterfaceId,
    OUT     PUNKNOWN *          OutPortInterface,   OPTIONAL
    OUT     PUNKNOWN *          OutPortUnknown      OPTIONAL
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE, ("InstallSubdevice"));

    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(Name);
    ASSERT(ResourceList);

    //
    // Create the port driver object
    //
    PPORT       port;
    NTSTATUS    ntStatus = PcNewPort(&port,PortClassId);

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Deposit the port somewhere if it's needed.
        //
        if (OutPortInterface)
        {
            //
            //  Failure here doesn't cause the entire routine to fail.
            //
            (void) port->QueryInterface
            (
                PortInterfaceId,
                (PVOID *) OutPortInterface
            );
        }

        PUNKNOWN miniport;
        if (NT_SUCCESS(ntStatus))
        {
            //
            // Create the miniport object
            //
            if (MiniportCreate)
            {
                ntStatus = MiniportCreate
                (
                    &miniport,
                    MiniportClassId,
                    NULL,
                    NonPagedPool
                );
            }
            else
            {
                ntStatus = PcNewMiniport((PMINIPORT*) &miniport,MiniportClassId);
            }
        }

        if (NT_SUCCESS(ntStatus))
        {
            //
            // Init the port driver and miniport in one go.
            //
            ntStatus = port->Init( DeviceObject,
                                   Irp,
                                   miniport,
                                   UnknownAdapter,
                                   ResourceList );

            if (NT_SUCCESS(ntStatus))
            {
                //
                // Register the subdevice (port/miniport combination).
                //
                ntStatus = PcRegisterSubdevice( DeviceObject,
                                                Name,
                                                port );
#if DBG
                if (!(NT_SUCCESS(ntStatus)))
                {
                    _DbgPrintF(DEBUGLVL_TERSE, ("StartDevice: PcRegisterSubdevice failed"));
                }
#endif
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("InstallSubdevice: port->Init failed"));
            }

            //
            // We don't need the miniport any more.  Either the port has it,
            // or we've failed, and it should be deleted.
            //
            miniport->Release();
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("InstallSubdevice: PcNewMiniport failed"));
        }

        if (NT_SUCCESS(ntStatus))
        {
            //
            // Deposit the port as an unknown if it's needed.
            //
            if (OutPortUnknown)
            {
                //
                //  Failure here doesn't cause the entire routine to fail.
                //
                (void) port->QueryInterface
                (
                    IID_IUnknown,
                    (PVOID *) OutPortUnknown
                );
            }
        }
        else
        {
            //
            // Retract previously delivered port interface.
            //
            if (OutPortInterface && (*OutPortInterface))
            {
                (*OutPortInterface)->Release();
                *OutPortInterface = NULL;
            }
        }

        //
        // Release the reference which existed when PcNewPort() gave us the
        // pointer in the first place.  This is the right thing to do
        // regardless of the outcome.
        //
        port->Release();
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("InstallSubdevice: PcNewPort failed"));
    }

    return ntStatus;
}

/*****************************************************************************
 * StartDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is started.
 * It is responsible for starting the miniports.  This code is specific to
 * the adapter because it calls out miniports for functions that are specific
 * to the adapter.
 */
NTSTATUS
StartDevice
(
    IN  PDEVICE_OBJECT  DeviceObject,   // Device object.
    IN  PIRP            Irp,            // IO request packet.
    IN  PRESOURCELIST   ResourceList    // List of hardware resources.
)
{
    PAGED_CODE();


    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ResourceList);

    //
    // These are the sub-lists of resources that will be handed to the
    // miniports.
    //
    PRESOURCELIST   resourceListTopology    = NULL;
    PRESOURCELIST   resourceListWave        = NULL;
    PRESOURCELIST   resourceListWaveTable   = NULL;
    PRESOURCELIST   resourceListFmSynth     = NULL;
    PRESOURCELIST   resourceListUart        = NULL;
    PRESOURCELIST   resourceListAdapter     = NULL;

    //
    // These are the port driver pointers we are keeping around for registering
    // physical connections.
    //
    PUNKNOWN    unknownTopology   = NULL;
    PUNKNOWN    unknownWave       = NULL;
    PUNKNOWN    unknownWaveTable  = NULL;
    PUNKNOWN    unknownFmSynth    = NULL;

    //
    // Assign resources to individual miniports.  Each sub-list is a copy
    // of the resources from the master list. Each sublist must be released.
    //
    NTSTATUS ntStatus = AssignResources( ResourceList,
                                         &resourceListTopology,
                                         &resourceListWave,
                                         &resourceListWaveTable,
                                         &resourceListFmSynth,
                                         &resourceListUart,
                                         &resourceListAdapter );

    //
    // if AssignResources succeeded...
    //
    if(NT_SUCCESS(ntStatus))
    {
        //
        // If the adapter has resources...
        //
        PADAPTERCOMMON pAdapterCommon = NULL;
        if (resourceListAdapter)
        {
            PUNKNOWN pUnknownCommon;

            // create a new adapter common object
            ntStatus = NewAdapterCommon( &pUnknownCommon,
                                         IID_IAdapterCommon,
                                         NULL,
                                         NonPagedPool );
            if (NT_SUCCESS(ntStatus))
            {
                ASSERT( pUnknownCommon );

                // query for the IAdapterCommon interface
                ntStatus = pUnknownCommon->QueryInterface( IID_IAdapterCommon,
                                                           (PVOID *)&pAdapterCommon );
                if (NT_SUCCESS(ntStatus))
                {
                    // Initialize the object
                    ntStatus = pAdapterCommon->Init( resourceListAdapter,
                                                     DeviceObject );
                    if (NT_SUCCESS(ntStatus))
                    {
                        // register with PortCls for power-managment services
                        ntStatus = PcRegisterAdapterPowerManagement( (PUNKNOWN)pAdapterCommon,
                                                                     DeviceObject );
                    }
                }

                // release the IUnknown on adapter common
                pUnknownCommon->Release();
            }

            // release the adapter common resource list
            resourceListAdapter->Release();
        }

        //
        // Start the topology miniport if it exists.
        //
        if (resourceListTopology)
        {
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = InstallSubdevice( DeviceObject,
                                             Irp,
                                             L"Topology",
                                             CLSID_PortTopology,
                                             CLSID_PortTopology, // not used
                                             CreateMiniportTopologySB16,
                                             pAdapterCommon,
                                             resourceListTopology,
                                             GUID_NULL,
                                             NULL,
                                             &unknownTopology );
            }

            // release the topology resource list
            resourceListTopology->Release();
        }

        //
        // Start the SB wave miniport if it exists.
        //
        if (resourceListWave)
        {
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = InstallSubdevice( DeviceObject,
                                             Irp,
                                             L"Wave",
                                             CLSID_PortWaveCyclic,
                                             CLSID_PortWaveCyclic,   // not used
                                             CreateMiniportWaveCyclicSB16,
                                             pAdapterCommon,
                                             resourceListWave,
                                             IID_IPortWaveCyclic,
                                             NULL,
                                             &unknownWave );
            }

            // release the wave resource list
            resourceListWave->Release();
        }

        // Start the wave table miniport if it exists.
        if (resourceListWaveTable)
        {
            //
            // NOTE: The wavetable is not currently supported in this sample driver.
            //

            // release the wavetable resource list
            resourceListWaveTable->Release();
        }

        //
        // Start the FM synth miniport if it exists.
        //
        if (resourceListFmSynth)
        {
            //
            // Synth not working yet.
            //

            if (NT_SUCCESS(ntStatus))
            {
                //
                // Failure here is not fatal.
                //
                InstallSubdevice( DeviceObject,
                                  Irp,
                                  L"FMSynth",
                                  CLSID_PortMidi,
                                  CLSID_MiniportDriverFmSynth,
                                  NULL,
                                  pAdapterCommon,
                                  resourceListFmSynth,
                                  GUID_NULL,
                                  NULL,
                                  &unknownFmSynth );
            }

            // release the FM synth resource list
            resourceListFmSynth->Release();
        }

        //
        // Start the UART miniport if it exists.
        //
        if (resourceListUart)
        {
            if (NT_SUCCESS(ntStatus))
            {
                //
                // Failure here is not fatal.
                //
                InstallSubdevice( DeviceObject,
                                  Irp,
                                  L"Uart",
                                  CLSID_PortDMus,
                                  CLSID_MiniportDriverDMusUART,
                                  NULL,
                                  pAdapterCommon->GetInterruptSync(),
                                  resourceListUart,
                                  IID_IPortDMus,
                                  NULL,     //  interface to port not needed
                                  NULL );   //  not physically connected to anything
            }

            resourceListUart->Release();
        }

        //
        // Establish physical connections between filters as shown.
        //
        //              +------+    +------+
        //              | Wave |    | Topo |
        //  Capture <---|0    1|<===|6    2|<--- CD
        //              |      |    |      |
        //   Render --->|2    3|===>|0    3|<--- Line In
        //              +------+    |      |
        //              +------+    |     4|<--- Mic
        //              |  FM  |    |      |
        //     MIDI --->|0    1|===>|1    5|---> Line Out
        //              +------+    +------+
        //
        if (unknownTopology)
        {
            if (unknownWave)
            {
                // register wave <=> topology connections
                PcRegisterPhysicalConnection( (PDEVICE_OBJECT)DeviceObject,
                                            unknownTopology,
                                            6,
                                            unknownWave,
                                            1 );
                PcRegisterPhysicalConnection( (PDEVICE_OBJECT)DeviceObject,
                                            unknownWave,
                                            3,
                                            unknownTopology,
                                            0 );
            }

            if (unknownFmSynth)
            {
                // register fmsynth <=> topology connection
                PcRegisterPhysicalConnection( (PDEVICE_OBJECT)DeviceObject,
                                            unknownFmSynth,
                                            1,
                                            unknownTopology,
                                            1 );
            }
        }

        //
        // Release the adapter common object.  It either has other references,
        // or we need to delete it anyway.
        //
        if (pAdapterCommon)
        {
            pAdapterCommon->Release();
        }

        //
        // Release the unknowns.
        //
        if (unknownTopology)
        {
            unknownTopology->Release();
        }
        if (unknownWave)
        {
            unknownWave->Release();
        }
        if (unknownWaveTable)
        {
            unknownWaveTable->Release();
        }
        if (unknownFmSynth)
        {
            unknownFmSynth->Release();
        }

    }

    return ntStatus;
}

/*****************************************************************************
 * AssignResources()
 *****************************************************************************
 * This function assigns the list of resources to the various functions on
 * the card.  This code is specific to the adapter.  All the non-NULL resource
 * lists handed back must be released by the caller.
 */
NTSTATUS
AssignResources
(
    IN      PRESOURCELIST   ResourceList,           // All resources.
    OUT     PRESOURCELIST * ResourceListTopology,   // Topology resources.
    OUT     PRESOURCELIST * ResourceListWave,       // Wave resources.
    OUT     PRESOURCELIST * ResourceListWaveTable,  // Wave table resources.
    OUT     PRESOURCELIST * ResourceListFmSynth,    // FM synth resources.
    OUT     PRESOURCELIST * ResourceListUart,       // Uart resources.
    OUT     PRESOURCELIST * ResourceListAdapter     // For the adapter
)
{
    BOOLEAN     detectedWaveTable   = FALSE;
    BOOLEAN     detectedUart        = FALSE;
    BOOLEAN     detectedFmSynth     = FALSE;

    //
    // Get counts for the types of resources.
    //
    ULONG countIO  = ResourceList->NumberOfPorts();
    ULONG countIRQ = ResourceList->NumberOfInterrupts();
    ULONG countDMA = ResourceList->NumberOfDmas();

    //
    // Determine the type of card based on port resources.
    // TODO:  Detect wave table.
    //
    NTSTATUS ntStatus = STATUS_SUCCESS;

    switch (countIO)
    {
    case 1:
        //
        // No FM synth or UART.
        //
        if  (   (ResourceList->FindTranslatedPort(0)->u.Port.Length < 16)
            ||  (countIRQ < 1)
            ||  (countDMA < 1)
            )
        {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        break;

    case 2:
        //
        // MPU-401 or FM synth, not both.
        //
        if  (   (ResourceList->FindTranslatedPort(0)->u.Port.Length < 16)
            ||  (countIRQ < 1)
            ||  (countDMA < 1)
            )
        {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        else
        {
            //
            // Length of second port indicates which function.
            //
            switch (ResourceList->FindTranslatedPort(1)->u.Port.Length)
            {
            case 2:
                detectedUart = TRUE;
                break;

            case 4:
                detectedFmSynth = TRUE;
                break;

            default:
                ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                break;
            }
        }
        break;

    case 3:
        //
        // Both MPU-401 and FM synth.
        //
        if  (   (ResourceList->FindTranslatedPort(0)->u.Port.Length < 16)
            ||  (ResourceList->FindTranslatedPort(1)->u.Port.Length != 2)
            ||  (ResourceList->FindTranslatedPort(2)->u.Port.Length != 4)
            ||  (countIRQ < 1)
            ||  (countDMA < 1)
            )
        {
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        else
        {
            detectedUart    = TRUE;
            detectedFmSynth = TRUE;
        }
        break;

    default:
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        break;
    }

    //
    // Build list of resources for the topology.
    //
    *ResourceListTopology = NULL;
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus =
            PcNewResourceSublist
            (
                ResourceListTopology,
                NULL,
                PagedPool,
                ResourceList,
                countIRQ + countDMA + 1
            );

        if (NT_SUCCESS(ntStatus))
        {
            SUCCEEDS((*ResourceListTopology)->
                AddPortFromParent(ResourceList,0));
        }
    }

    //
    // Build the resource list for the SB wave I/O.
    //
    *ResourceListWave = NULL;
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus =
            PcNewResourceSublist
            (
                ResourceListWave,
                NULL,
                PagedPool,
                ResourceList,
                countDMA + countIRQ + 1
            );

        if (NT_SUCCESS(ntStatus))
        {
            ULONG i;

            //
            // Add the base address
            //
            SUCCEEDS((*ResourceListWave)->
                AddPortFromParent(ResourceList,0));

            //
            // Add the DMA channel(s).
            //
            for (i = 0; i < countDMA; i++)
            {
                SUCCEEDS((*ResourceListWave)->
                    AddDmaFromParent(ResourceList,i));
            }

            //
            // Add the IRQ lines.
            //
            for (i = 0; i < countIRQ; i++)
            {
                SUCCEEDS((*ResourceListWave)->
                    AddInterruptFromParent(ResourceList,i));
            }
        }
    }

    //
    // Build list of resources for wave table.
    //
    *ResourceListWaveTable = NULL;
    if (NT_SUCCESS(ntStatus) && detectedWaveTable)
    {
        //
        // TODO:  Assign wave table resources.
        //
    }

    //
    // Build list of resources for UART.
    //
    *ResourceListUart = NULL;
    if (NT_SUCCESS(ntStatus) && detectedUart)
    {
        ntStatus =
            PcNewResourceSublist
            (
                ResourceListUart,
                NULL,
                PagedPool,
                ResourceList,
                2
            );

        if (NT_SUCCESS(ntStatus))
        {
            SUCCEEDS((*ResourceListUart)->
                AddPortFromParent(ResourceList,1));
            SUCCEEDS((*ResourceListUart)->
                AddInterruptFromParent(ResourceList,0));
        }
    }

    //
    // Build list of resources for FM synth.
    //
    *ResourceListFmSynth = NULL;
    if (NT_SUCCESS(ntStatus) && detectedFmSynth)
    {
        ntStatus =
            PcNewResourceSublist
            (
                ResourceListFmSynth,
                NULL,
                PagedPool,
                ResourceList,
                1
            );

        if (NT_SUCCESS(ntStatus))
        {
            SUCCEEDS((*ResourceListFmSynth)->
                AddPortFromParent(ResourceList,detectedUart ? 2 : 1));
        }
    }

    //
    // Build list of resources for the adapter.
    //
    *ResourceListAdapter = NULL;
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus =
            PcNewResourceSublist
            (
                ResourceListAdapter,
                NULL,
                PagedPool,
                ResourceList,
                3
            );

        if (NT_SUCCESS(ntStatus))
        {
            //
            // The interrupt to share.
            //
            SUCCEEDS((*ResourceListAdapter)->
                AddInterruptFromParent(ResourceList,0));

            //
            // The base IO port (to tell who's interrupt it is)
            //
            SUCCEEDS((*ResourceListAdapter)->
                AddPortFromParent(ResourceList,0));

            if (detectedUart)
            {
                //
                // The Uart port
                //
                SUCCEEDS((*ResourceListAdapter)->
                    AddPortFromParent(ResourceList,1));
            }
        }
    }

    //
    // Clean up if failure occurred.
    //
    if (! NT_SUCCESS(ntStatus))
    {
        if (*ResourceListWave)
        {
            (*ResourceListWave)->Release();
            *ResourceListWave = NULL;
        }
        if (*ResourceListWaveTable)
        {
            (*ResourceListWaveTable)->Release();
            *ResourceListWaveTable = NULL;
        }
        if (*ResourceListUart)
        {
            (*ResourceListUart)->Release();
            *ResourceListUart = NULL;
        }
        if (*ResourceListFmSynth)
        {
            (*ResourceListFmSynth)->Release();
            *ResourceListFmSynth = NULL;
        }
        if(*ResourceListAdapter)
        {
            (*ResourceListAdapter)->Release();
            *ResourceListAdapter = NULL;
        }
    }


    return ntStatus;
}

#ifdef DO_RESOURCE_FILTERING

#pragma code_seg("PAGE")
/*****************************************************************************
 * AdapterDispatchPnp()
 *****************************************************************************
 * Supplying your PnP resource filtering needs.
 */
extern "C"
NTSTATUS
AdapterDispatchPnp
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PIO_STACK_LOCATION pIrpStack =
        IoGetCurrentIrpStackLocation(pIrp);

    if( pIrpStack->MinorFunction == IRP_MN_FILTER_RESOURCE_REQUIREMENTS )
    {
        //
        // Do your resource requirements filtering here!!
        //
        _DbgPrintF(DEBUGLVL_VERBOSE,("[AdapterDispatchPnp] - IRP_MN_FILTER_RESOURCE_REQUIREMENTS"));

        // set the return status
        pIrp->IoStatus.Status = ntStatus;

    }

    //
    // Pass the IRPs on to PortCls
    //
    ntStatus = PcDispatchIrp( pDeviceObject,
                              pIrp );

    return ntStatus;
}

#endif

#pragma code_seg()

/*****************************************************************************
 * _purecall()
 *****************************************************************************
 * The C++ compiler loves me.
 * TODO: Figure out how to put this into portcls.sys
 */
int __cdecl
_purecall( void )
{
    ASSERT( !"Pure virutal function called" );
    return 0;
}


=== sb16/common.cpp ===
/*****************************************************************************
 * common.cpp - Common code used by all the sb16 miniports.
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 *
 * Implmentation of the common code object.  This class deals with interrupts
 * for the device, and is a collection of common code used by all the
 * miniports.
 */

#include "common.h"

#define STR_MODULENAME "sb16Adapter: "




/*****************************************************************************
 * CAdapterCommon
 
 *****************************************************************************
 * Adapter common object.
 */
class CAdapterCommon
:   public IAdapterCommon,
    public IAdapterPowerManagement,
    public CUnknown
    
{
private:
    PINTERRUPTSYNC          m_pInterruptSync;
    PUCHAR                  m_pWaveBase;
    PWAVEMINIPORTSB16       m_WaveMiniportSB16;
#ifdef EVENT_SUPPORT
    PTOPOMINIPORTSB16       m_TopoMiniportSB16;     // Topology miniport of SB16.
#endif
    PDEVICE_OBJECT          m_pDeviceObject;
    DEVICE_POWER_STATE      m_PowerState;
    BYTE                    MixerSettings[DSP_MIX_MAXREGS];

    void AcknowledgeIRQ
    (   void
    );

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CAdapterCommon);
    ~CAdapterCommon();

    /*****************************************************************************
     * IAdapterCommon methods
     */
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      PRESOURCELIST   ResourceList,
        IN      PDEVICE_OBJECT  DeviceObject
    );
    STDMETHODIMP_(PINTERRUPTSYNC) GetInterruptSync
    (   void
    );
    STDMETHODIMP_(void) SetWaveMiniport (IN PWAVEMINIPORTSB16 Miniport)
    {
        m_WaveMiniportSB16 = Miniport;
    }
    STDMETHODIMP_(BYTE) ReadController
    (   void
    );
    STDMETHODIMP_(BOOLEAN) WriteController
    (
        IN      BYTE    Value
    );
    STDMETHODIMP_(NTSTATUS) ResetController
    (   void
    );
    STDMETHODIMP_(void) MixerRegWrite
    (
        IN      BYTE    Index,
        IN      BYTE    Value
    );
    STDMETHODIMP_(BYTE) MixerRegRead
    (
        IN      BYTE    Index
    );
    STDMETHODIMP_(void) MixerReset
    (   void
    );
    STDMETHODIMP RestoreMixerSettingsFromRegistry
    (   void
    );
    STDMETHODIMP SaveMixerSettingsToRegistry
    (   void
    );
#ifdef EVENT_SUPPORT
    //
    // The topology miniport needs to tell us the pointer to the Event-interface.
    //
    STDMETHODIMP_(void) SetTopologyMiniport (IN PTOPOMINIPORTSB16 Miniport)
    {
        m_TopoMiniportSB16 = Miniport;
    };
#endif
    
    /*************************************************************************
     * IAdapterPowerManagement implementation
     *
     * This macro is from PORTCLS.H.  It lists all the interface's functions.
     */
    IMP_IAdapterPowerManagement;

    friend
    NTSTATUS
    InterruptServiceRoutine
    (
        IN      PINTERRUPTSYNC  InterruptSync,
        IN      PVOID           DynamicContext
    );
};

static
MIXERSETTING DefaultMixerSettings[] =
{
    { L"LeftMasterVol",   DSP_MIX_MASTERVOLIDX_L,     0xD8 },
    { L"RightMasterVol",  DSP_MIX_MASTERVOLIDX_R,     0xD8 },
    { L"LeftWaveVol",     DSP_MIX_VOICEVOLIDX_L,      0xD8 },
    { L"RightWaveVol",    DSP_MIX_VOICEVOLIDX_R,      0xD8 },
    { L"LeftMidiVol",     DSP_MIX_FMVOLIDX_L,         0xD8 },
    { L"RightMidiVol",    DSP_MIX_FMVOLIDX_R,         0xD8 },
    { L"LeftCDVol",       DSP_MIX_CDVOLIDX_L,         0xD8 },
    { L"RightCDVol",      DSP_MIX_CDVOLIDX_R,         0xD8 },
    { L"LeftLineInVol",   DSP_MIX_LINEVOLIDX_L,       0xD8 },
    { L"RightLineInVol",  DSP_MIX_LINEVOLIDX_R,       0xD8 },
    { L"MicVol",          DSP_MIX_MICVOLIDX,          0xD8 },
    { L"PcSpkrVol",       DSP_MIX_SPKRVOLIDX,         0x00 },
    { L"OutputMixer",     DSP_MIX_OUTMIXIDX,          0x1E },
    { L"LeftInputMixer",  DSP_MIX_ADCMIXIDX_L,        0x55 },
    { L"RightInputMixer", DSP_MIX_ADCMIXIDX_R,        0x2B },
    { L"LeftInputGain",   DSP_MIX_INGAINIDX_L,        0x00 },
    { L"RightInputGain",  DSP_MIX_INGAINIDX_R,        0x00 },
    { L"LeftOutputGain",  DSP_MIX_OUTGAINIDX_L,       0x80 },
    { L"RightOutputGain", DSP_MIX_OUTGAINIDX_R,       0x80 },
    { L"MicAGC",          DSP_MIX_AGCIDX,             0x01 },
    { L"LeftTreble",      DSP_MIX_TREBLEIDX_L,        0x80 },
    { L"RightTreble",     DSP_MIX_TREBLEIDX_R,        0x80 },
    { L"LeftBass",        DSP_MIX_BASSIDX_L,          0x80 },
    { L"RightBass",       DSP_MIX_BASSIDX_R,          0x80 },
};



#pragma code_seg("PAGE")

/*****************************************************************************
 * NewAdapterCommon()
 *****************************************************************************
 * Create a new adapter common object.
 */
NTSTATUS
NewAdapterCommon
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY_
    (
        CAdapterCommon,
        Unknown,
        UnknownOuter,
        PoolType,
        PADAPTERCOMMON
    );
}   


/*****************************************************************************
 * CAdapterCommon::Init()
 *****************************************************************************
 * Initialize an adapter common object.
 */
NTSTATUS
CAdapterCommon::
Init
(
    IN      PRESOURCELIST   ResourceList,
    IN      PDEVICE_OBJECT  DeviceObject
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    ASSERT(DeviceObject);

    //
    // Make sure we have the resources we expect
    //
    if ((ResourceList->NumberOfPorts() < 1) ||
        (ResourceList->NumberOfInterrupts() != 1))
    {
        _DbgPrintF (DEBUGLVL_TERSE, ("unknown configuration; check your code!"));
        // Bail out.
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    m_pDeviceObject = DeviceObject;
    m_WaveMiniportSB16 = NULL;
#ifdef EVENT_SUPPORT
    m_TopoMiniportSB16 = NULL;
#endif

    //
    // Get the base address for the wave device.
    //
    ASSERT(ResourceList->FindTranslatedPort(0));
    m_pWaveBase = PUCHAR(ResourceList->FindTranslatedPort(0)->u.Port.Start.LowPart);

    //
    // Set initial device power state
    //
    m_PowerState = PowerDeviceD0;

    //
    // Reset the hardware.
    //
    NTSTATUS ntStatus = ResetController();

    if(NT_SUCCESS(ntStatus))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("ResetController Succeeded"));
        AcknowledgeIRQ();
    
        //
        // Hook up the interrupt.
        //
        ntStatus = PcNewInterruptSync(                              // See portcls.h
                                        &m_pInterruptSync,          // Save object ptr
                                        NULL,                       // OuterUnknown(optional).
                                        ResourceList,               // He gets IRQ from ResourceList.
                                        0,                          // Resource Index
                                        InterruptSyncModeNormal     // Run ISRs once until we get SUCCESS
                                     );
        if (NT_SUCCESS(ntStatus) && m_pInterruptSync)
        {                                                                       //  run this ISR first
            ntStatus = m_pInterruptSync->RegisterServiceRoutine(InterruptServiceRoutine,PVOID(this),FALSE);
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_pInterruptSync->Connect();
            }

            // if we could not connect or register the ISR, release the object.
            if (!NT_SUCCESS (ntStatus))
            {
                m_pInterruptSync->Release();
                m_pInterruptSync = NULL;
            }
        }
    } else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("ResetController Failure"));
    }

    return ntStatus;
}

/*****************************************************************************
 * CAdapterCommon::~CAdapterCommon()
 *****************************************************************************
 * Destructor.
 */
CAdapterCommon::
~CAdapterCommon
(   void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CAdapterCommon::~CAdapterCommon]"));

    if (m_pInterruptSync)
    {
        m_pInterruptSync->Disconnect();
        m_pInterruptSync->Release();
        m_pInterruptSync = NULL;
    }
}

/*****************************************************************************
 * CAdapterCommon::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP
CAdapterCommon::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PADAPTERCOMMON(this)));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IAdapterCommon))
    {
        *Object = PVOID(PADAPTERCOMMON(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IAdapterPowerManagment))
    {
        *Object = PVOID(PADAPTERPOWERMANAGMENT(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CAdapterCommon::GetInterruptSync()
 *****************************************************************************
 * Get a pointer to the interrupt synchronization object.
 */
STDMETHODIMP_(PINTERRUPTSYNC)
CAdapterCommon::
GetInterruptSync
(   void
)
{
    PAGED_CODE();

    return m_pInterruptSync;
}

#pragma code_seg()

/*****************************************************************************
 * CAdapterCommon::ReadController()
 *****************************************************************************
 * Read a byte from the controller.
 */
STDMETHODIMP_(BYTE)
CAdapterCommon::
ReadController
(   void
)
{
    BYTE returnValue = BYTE(-1);

    ASSERT(m_pWaveBase);

    ULONGLONG startTime = PcGetTimeInterval(0);

    do
    {
        if
        (   READ_PORT_UCHAR
            (
                m_pWaveBase + DSP_REG_DATAAVAIL
            )
        &   0x80
        )
        {
            returnValue =
                READ_PORT_UCHAR
                (
                    m_pWaveBase + DSP_REG_READ
                );
        }
    } while ((PcGetTimeInterval(startTime) < GTI_MILLISECONDS(20)) &&
             (BYTE(-1) == returnValue));


    ASSERT((BYTE(-1) != returnValue) || !"ReadController timeout!");

    return returnValue;
}

/*****************************************************************************
 * CAdapterCommon::WriteController()
 *****************************************************************************
 * Write a byte to the controller.
 */
STDMETHODIMP_(BOOLEAN)
CAdapterCommon::
WriteController
(
    IN      BYTE    Value
)
{
    ASSERT(m_pWaveBase);

    BOOLEAN     returnValue = FALSE;
    ULONGLONG   startTime   = PcGetTimeInterval(0);

    do
    {

        BYTE status =
            READ_PORT_UCHAR
            (
                m_pWaveBase + DSP_REG_WRITE
            );

        if ((status & 0x80) == 0)
        {
            WRITE_PORT_UCHAR
            (
                m_pWaveBase + DSP_REG_WRITE,
                Value
            );

            returnValue = TRUE;
        }
    } while ((PcGetTimeInterval(startTime) < GTI_MILLISECONDS(20)) &&
              ! returnValue);


    ASSERT(returnValue || !"WriteController timeout");

    return returnValue;
}

/*****************************************************************************
 * CAdapterCommon::MixerRegWrite()
 *****************************************************************************
 * Writes a mixer register.
 */
STDMETHODIMP_(void)
CAdapterCommon::
MixerRegWrite
(
    IN      BYTE    Index,
    IN      BYTE    Value
)
{
    ASSERT( m_pWaveBase );
    BYTE actualIndex;

    // only hit the hardware if we're in an acceptable power state
    if( m_PowerState <= PowerDeviceD1 )
    {
        actualIndex = (BYTE) ((Index < 0x80) ? (Index + DSP_MIX_BASEIDX) : Index);
    
        WRITE_PORT_UCHAR
        (
            m_pWaveBase + DSP_REG_MIXREG,
            actualIndex
        );
    
        WRITE_PORT_UCHAR
        (
            m_pWaveBase + DSP_REG_MIXDATA,
            Value
        );
    }

    if(Index < DSP_MIX_MAXREGS)
    {
        MixerSettings[Index] = Value;
    }
}

/*****************************************************************************
 * CAdapterCommon::MixerRegRead()
 *****************************************************************************
 * Reads a mixer register.
 */
STDMETHODIMP_(BYTE)
CAdapterCommon::
MixerRegRead
(
    IN      BYTE    Index
)
{
    if(Index < DSP_MIX_MAXREGS)
    {
        return MixerSettings[Index];
    }

    //
    // Not in the cache? Read from HW directly.
    //
    // We need to make sure that we can access the HW directly for
    // the volumes that can change externally.
    // This is done here with passing an index outside of the cache.
    // Since the an index=0 is actually DSP_MIX_BASEIDX which is less
    // than the cache size (DSP_MIX_MAXREGS), you can access any volume
    // directly with passing DSP_MIX_BASEIDX + index.
    // You could also pass a flag - but we want to keep the changes
    // minimal - or create a new function like MixerRegReadDirect().
    //
    WRITE_PORT_UCHAR (m_pWaveBase + DSP_REG_MIXREG, Index);
    return READ_PORT_UCHAR (m_pWaveBase + DSP_REG_MIXDATA);
}

/*****************************************************************************
 * CAdapterCommon::MixerReset()
 *****************************************************************************
 * Resets the mixer
 */
STDMETHODIMP_(void)
CAdapterCommon::
MixerReset
(   void
)
{
    ASSERT(m_pWaveBase);

    WRITE_PORT_UCHAR
    (
        m_pWaveBase + DSP_REG_MIXREG,
        DSP_MIX_DATARESETIDX
    );

    WRITE_PORT_UCHAR
    (
        m_pWaveBase + DSP_REG_MIXDATA,
        0
    );

    RestoreMixerSettingsFromRegistry();
}

/*****************************************************************************
 * CAdapterCommon::AcknowledgeIRQ()
 *****************************************************************************
 * Acknowledge interrupt request.
 */
void
CAdapterCommon::
AcknowledgeIRQ
(   void
)
{
    ASSERT(m_pWaveBase);
    READ_PORT_UCHAR(m_pWaveBase + DSP_REG_ACK16BIT);
    READ_PORT_UCHAR(m_pWaveBase + DSP_REG_ACK8BIT);
}

/*****************************************************************************
 * CAdapterCommon::ResetController()
 *****************************************************************************
 * Resets the controller.
 */
STDMETHODIMP_(NTSTATUS)
CAdapterCommon::
ResetController(void)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    // write a 1 to the reset bit
    WRITE_PORT_UCHAR(m_pWaveBase + DSP_REG_RESET,1);

    // wait for  at least 3 microseconds
    KeStallExecutionProcessor( 5L );    // okay, 5us

    // write a 0 to the reset bit
    WRITE_PORT_UCHAR(m_pWaveBase + DSP_REG_RESET,0);

    // hang out for 100us
    KeStallExecutionProcessor( 100L );
    
    // read the controller
    BYTE ReadVal = ReadController();

    // check return value
    if( ReadVal == BYTE(0xAA) )
    {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

/*****************************************************************************
 * CAdapterCommon::RestoreMixerSettingsFromRegistry()
 *****************************************************************************
 * Restores the mixer settings based on settings stored in the registry.
 */
STDMETHODIMP
CAdapterCommon::
RestoreMixerSettingsFromRegistry
(   void
)
{
    PREGISTRYKEY    DriverKey;
    PREGISTRYKEY    SettingsKey;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[RestoreMixerSettingsFromRegistry]"));
    
    // open the driver registry key
    NTSTATUS ntStatus = PcNewRegistryKey( &DriverKey,               // IRegistryKey
                                          NULL,                     // OuterUnknown
                                          DriverRegistryKey,        // Registry key type
                                          KEY_ALL_ACCESS,           // Access flags
                                          m_pDeviceObject,          // Device object
                                          NULL,                     // Subdevice
                                          NULL,                     // ObjectAttributes
                                          0,                        // Create options
                                          NULL );                   // Disposition
    if(NT_SUCCESS(ntStatus))
    {
        UNICODE_STRING  KeyName;
        ULONG           Disposition;
        
        // make a unicode strong for the subkey name
        RtlInitUnicodeString( &KeyName, L"Settings" );



        // open the settings subkey
        ntStatus = DriverKey->NewSubKey( &SettingsKey,              // Subkey
                                         NULL,                      // OuterUnknown
                                         KEY_ALL_ACCESS,            // Access flags
                                         &KeyName,                  // Subkey name
                                         REG_OPTION_NON_VOLATILE,   // Create options
                                         &Disposition );
        if(NT_SUCCESS(ntStatus))
        {
            ULONG   ResultLength;

            if(Disposition == REG_CREATED_NEW_KEY)
            {
                // copy default settings
                for(ULONG i = 0; i < SIZEOF_ARRAY(DefaultMixerSettings); i++)
                {
                    MixerRegWrite( DefaultMixerSettings[i].RegisterIndex,
                                   DefaultMixerSettings[i].RegisterSetting );
                }
            } else
            {
                // allocate data to hold key info
                PVOID KeyInfo = ExAllocatePool(PagedPool, sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD));
                if(NULL != KeyInfo)
                {
                    // loop through all mixer settings
                    for(UINT i = 0; i < SIZEOF_ARRAY(DefaultMixerSettings); i++)
                    {
                        // init key name
                        RtlInitUnicodeString( &KeyName, DefaultMixerSettings[i].KeyName );
        
                        // query the value key
                        ntStatus = SettingsKey->QueryValueKey( &KeyName,
                                                               KeyValuePartialInformation,
                                                               KeyInfo,
                                                               sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD),
                                                               &ResultLength );
                        if(NT_SUCCESS(ntStatus))
                        {
                            PKEY_VALUE_PARTIAL_INFORMATION PartialInfo = PKEY_VALUE_PARTIAL_INFORMATION(KeyInfo);
    
                            if(PartialInfo->DataLength == sizeof(DWORD))
                            {
                                // set mixer register to registry value
                                MixerRegWrite( DefaultMixerSettings[i].RegisterIndex,
                                               BYTE(*(PDWORD(PartialInfo->Data))) );
                            }
                        } else
                        {
                            // if key access failed, set to default
                            MixerRegWrite( DefaultMixerSettings[i].RegisterIndex,
                                           DefaultMixerSettings[i].RegisterSetting );
                        }
                    }
    
                    // free the key info
                    ExFreePool(KeyInfo);
                } else
                {
                    // copy default settings
                    for(ULONG i = 0; i < SIZEOF_ARRAY(DefaultMixerSettings); i++)
                    {
                        MixerRegWrite( DefaultMixerSettings[i].RegisterIndex,
                                       DefaultMixerSettings[i].RegisterSetting );
                    }

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            // release the settings key
            SettingsKey->Release();
        }

        // release the driver key
        DriverKey->Release();

    }

    return ntStatus;
}

/*****************************************************************************
 * CAdapterCommon::SaveMixerSettingsToRegistry()
 *****************************************************************************
 * Saves the mixer settings to the registry.
 */
STDMETHODIMP
CAdapterCommon::
SaveMixerSettingsToRegistry
(   void
)
{
    PREGISTRYKEY    DriverKey;
    PREGISTRYKEY    SettingsKey;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[SaveMixerSettingsToRegistry]"));
    
    // open the driver registry key
    NTSTATUS ntStatus = PcNewRegistryKey( &DriverKey,               // IRegistryKey
                                          NULL,                     // OuterUnknown
                                          DriverRegistryKey,        // Registry key type
                                          KEY_ALL_ACCESS,           // Access flags
                                          m_pDeviceObject,          // Device object
                                          NULL,                     // Subdevice
                                          NULL,                     // ObjectAttributes
                                          0,                        // Create options
                                          NULL );                   // Disposition
    if(NT_SUCCESS(ntStatus))
    {
        UNICODE_STRING  KeyName;
        
        // make a unicode strong for the subkey name
        RtlInitUnicodeString( &KeyName, L"Settings" );

        // open the settings subkey
        ntStatus = DriverKey->NewSubKey( &SettingsKey,              // Subkey
                                         NULL,                      // OuterUnknown
                                         KEY_ALL_ACCESS,            // Access flags
                                         &KeyName,                  // Subkey name
                                         REG_OPTION_NON_VOLATILE,   // Create options
                                         NULL );
        if(NT_SUCCESS(ntStatus))
        {
            // loop through all mixer settings
            for(UINT i = 0; i < SIZEOF_ARRAY(MixerSettings); i++)
            {
                // init key name
                RtlInitUnicodeString( &KeyName, DefaultMixerSettings[i].KeyName );

                // set the key
                DWORD KeyValue = DWORD(MixerSettings[DefaultMixerSettings[i].RegisterIndex]);
                ntStatus = SettingsKey->SetValueKey( &KeyName,                 // Key name
                                                     REG_DWORD,                // Key type
                                                     PVOID(&KeyValue),
                                                     sizeof(DWORD) );
                if(!NT_SUCCESS(ntStatus))
                {
                    break;
                }
            }

            // release the settings key
            SettingsKey->Release();
        }

        // release the driver key
        DriverKey->Release();

    }

    return ntStatus;
}

/*****************************************************************************
 * CAdapterCommon::PowerChangeState()
 *****************************************************************************
 * Change power state for the device.
 */
STDMETHODIMP_(void)
CAdapterCommon::
PowerChangeState
(
    IN      POWER_STATE     NewState
)
{
    UINT i;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[CAdapterCommon::PowerChangeState]"));

    // is this actually a state change??
    if( NewState.DeviceState != m_PowerState )
    {
        // switch on new state
        switch( NewState.DeviceState )
        {
            case PowerDeviceD0:
                // Insert your code here for entering the full power state (D0).
                // This code may be a function of the current power state.  Note that
                // property accesses such as volume and mute changes may occur when
                // the device is in a sleep state (D1-D3) and should be cached in
                // the driver to be restored upon entering D0.  However, it should
                // also be noted that new miniport and new streams will only be
                // attempted at D0 (portcls will place the device in D0 prior to the
                // NewStream call).

                // Save the new state.  This local value is used to determine when to cache
                // property accesses and when to permit the driver from accessing the hardware.
                m_PowerState = NewState.DeviceState;

                // restore mixer settings
                for(i = 0; i < DSP_MIX_MAXREGS - 1; i++)
                {
                    if( i != DSP_MIX_MICVOLIDX )
                    {
                        MixerRegWrite( BYTE(i), MixerSettings[i] );
                    }
                }

            case PowerDeviceD1:
                // This sleep state is the lowest latency sleep state with respect to the
                // latency time required to return to D0.  The driver can still access
                // the hardware in this state if desired.  If the driver is not being used
                // an inactivity timer in portcls will place the driver in this state after
                // a timeout period controllable via the registry.
                
            case PowerDeviceD2:
                // This is a medium latency sleep state.  In this state the device driver
                // cannot assume that it can touch the hardware so any accesses need to be
                // cached and the hardware restored upon entering D0 (or D1 conceivably).
                
            case PowerDeviceD3:
                // This is a full hibernation state and is the longest latency sleep state.
                // The driver cannot access the hardware in this state and must cache any
                // hardware accesses and restore the hardware upon returning to D0 (or D1).
                
                // Save the new state.
                m_PowerState = NewState.DeviceState;

                _DbgPrintF(DEBUGLVL_VERBOSE,("  Entering D%d",ULONG(m_PowerState)-ULONG(PowerDeviceD0)));
                break;
    
            default:
                _DbgPrintF(DEBUGLVL_VERBOSE,("  Unknown Device Power State"));
                break;
        }
    }
}

/*****************************************************************************
 * CAdapterCommon::QueryPowerChangeState()
 *****************************************************************************
 * Query to see if the device can
 * change to this power state
 */
STDMETHODIMP_(NTSTATUS)
CAdapterCommon::
QueryPowerChangeState
(
    IN      POWER_STATE     NewStateQuery
)
{
    _DbgPrintF( DEBUGLVL_TERSE, ("[CAdapterCommon::QueryPowerChangeState]"));

    // Check here to see of a legitimate state is being requested
    // based on the device state and fail the call if the device/driver
    // cannot support the change requested.  Otherwise, return STATUS_SUCCESS.
    // Note: A QueryPowerChangeState() call is not guaranteed to always preceed
    // a PowerChangeState() call.

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CAdapterCommon::QueryDeviceCapabilities()
 *****************************************************************************
 * Called at startup to get the caps for the device.  This structure provides
 * the system with the mappings between system power state and device power
 * state.  This typically will not need modification by the driver.
 * 
 */
STDMETHODIMP_(NTSTATUS)
CAdapterCommon::
QueryDeviceCapabilities
(
    IN      PDEVICE_CAPABILITIES    PowerDeviceCaps
)
{
    _DbgPrintF( DEBUGLVL_TERSE, ("[CAdapterCommon::QueryDeviceCapabilities]"));

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * InterruptServiceRoutine()
 *****************************************************************************
 * ISR.
 */
NTSTATUS
InterruptServiceRoutine
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    ASSERT(InterruptSync);
    ASSERT(DynamicContext);

    CAdapterCommon *that = (CAdapterCommon *) DynamicContext;

    //
    // We are here because the MPU tried and failed, so
    // must be a wave interrupt.
    //
    ASSERT(that->m_pWaveBase);

    //
    // Read the Interrupt status register.
    //
    BYTE IntrStatus = that->MixerRegRead (0x82);

    //
    // In case we really read the interrupt status register, we should
    // also USE it and make sure that we really have a wave interrupt
    // and not something else!
    //
    if (IntrStatus & 0x03)      // Voice8 or Voice16 Interrupt
    {
        //
        // Make sure there is a wave miniport.
        //
        if (that->m_WaveMiniportSB16)
        {
            //
            // Tell it it needs to do some work.
            //
            that->m_WaveMiniportSB16->ServiceWaveISR ();
        }
    
        //
        // ACK the ISR.
        //
        that->AcknowledgeIRQ();
    }
    
#ifdef EVENT_SUPPORT
    //
    // This code will fire a volume event in case the HW volume has changed.
    //
    else if (IntrStatus & 0x10)      // Volume interrupt on C16X-mixers
    {
        //
        // Ack vol interrupt
        //
        IntrStatus &= ~0x10;
        that->MixerRegWrite (0x82, IntrStatus);

        //
        // Generate an event for the master volume (as an example)
        //
        if (that->m_TopoMiniportSB16)
        {
            that->m_TopoMiniportSB16->ServiceEvent ();
        }
    }
#endif
    
    return STATUS_SUCCESS;
}


=== sb16/common.h ===
/*****************************************************************************
 * common.h - Common code used by all the sb16 miniports.
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 *
 * A combination of random functions that are used by all the miniports.
 * This class also handles all the interrupts for the card.
 *
 */

/*
 * THIS IS A BIT BROKEN FOR NOW.  IT USES A SINGLETON OBJECT FOR WHICH THERE
 * IS ONLY ONE INSTANCE PER DRIVER.  THIS MEANS THERE CAN ONLY ONE CARD
 * SUPPORTED IN ANY GIVEN MACHINE.  THIS WILL BE FIXED.
 */

#ifndef _COMMON_H_
#define _COMMON_H_

#include "stdunk.h"
#include "portcls.h"
#include "DMusicKS.h"
#include "ksdebug.h"
#include "kcom.h"




/*****************************************************************************
 * Constants
 */

//
// DSP/DMA constants
// 
#define MAXLEN_DMA_BUFFER       0x4000

#define DSP_REG_CMSD0           0x00
#define DSP_REG_CMSR0           0x01
#define DSP_REG_CMSD1           0x02
#define DSP_REG_CMSR1           0x03
#define DSP_REG_MIXREG          0x04
#define DSP_REG_MIXDATA         0x05
#define DSP_REG_RESET           0x06
#define DSP_REG_FMD0            0x08
#define DSP_REG_FMR0            0x09
#define DSP_REG_READ            0x0A
#define DSP_REG_WRITE           0x0C
#define DSP_REG_DATAAVAIL       0x0E

#define DSP_REG_ACK8BIT         0x0E
#define DSP_REG_ACK16BIT        0x0F

//
// controller commands
//
#define DSP_CMD_WAVEWRPIO       0x10  // wave output (programmed I/O)
#define DSP_CMD_WAVEWR          0x14  // interrupt-driven 8 bit linear wave output
#define DSP_CMD_WAVEWRA         0x1C  // auto mode 8 bit out
#define DSP_CMD_WAVERD          0x24  // interrupt-driven 8 bit linear wave input
#define DSP_CMD_WAVERDA         0x2C  // auto mode 8 bit in
#define DSP_CMD_WAVEWRHS        0x90  // high speed mode write
#define DSP_CMD_WAVERDHS        0x98  // high speed mode read
#define DSP_CMD_SETSAMPRATE     0x40  // set sample rate
#define DSP_CMD_SETBLCKSIZE     0x48  // set block size
#define DSP_CMD_SPKRON          0xD1  // speaker on
#define DSP_CMD_SPKROFF         0xD3  // speaker off
#define DSP_CMD_SPKRSTATUS      0xD8  // speaker status (0=off, FF=on)
#define DSP_CMD_PAUSEDMA        0xD0  // pause DMA
#define DSP_CMD_CONTDMA         0xD4  // continue DMA
#define DSP_CMD_HALTAUTODMA     0xDA  // stop DMA autoinit mode
#define DSP_CMD_INVERTER        0xE0  // byte inverter
#define DSP_CMD_GETDSPVER       0xE1  // get dsp version
#define DSP_CMD_GENERATEINT     0xF2  // cause sndblst to generate an interrupt.

//
// SB-16 support
//
#define DSP_CMD_SETDACRATE      0x41  // set SBPro-16 DAC rate
#define DSP_CMD_SETADCRATE      0x42  // set SBPro-16 ADC rate
#define DSP_CMD_STARTDAC16      0xB6  // start 16-bit DAC
#define DSP_CMD_STARTADC16      0xBE  // start 16-bit ADC
#define DSP_CMD_STARTDAC8       0xC6  // start 8-bit DAC
#define DSP_CMD_STARTADC8       0xCE  // start 8-bit ADC
#define DSP_CMD_PAUSEDMA16      0xD5  // pause 16-bit DMA
#define DSP_CMD_CONTDMA16       0xD6  // continue 16-bit DMA
#define DSP_CMD_HALTAUTODMA16   0xD9  // halt 16-bit DMA

//
// Indexed mixer registers
//
#define DSP_MIX_DATARESETIDX    0x00

#define DSP_MIX_MASTERVOLIDX_L  0x00
#define DSP_MIX_MASTERVOLIDX_R  0x01
#define DSP_MIX_VOICEVOLIDX_L   0x02
#define DSP_MIX_VOICEVOLIDX_R   0x03
#define DSP_MIX_FMVOLIDX_L      0x04
#define DSP_MIX_FMVOLIDX_R      0x05
#define DSP_MIX_CDVOLIDX_L      0x06
#define DSP_MIX_CDVOLIDX_R      0x07
#define DSP_MIX_LINEVOLIDX_L    0x08
#define DSP_MIX_LINEVOLIDX_R    0x09
#define DSP_MIX_MICVOLIDX       0x0A
#define DSP_MIX_SPKRVOLIDX      0x0B
#define DSP_MIX_OUTMIXIDX       0x0C
#define DSP_MIX_ADCMIXIDX_L     0x0D
#define DSP_MIX_ADCMIXIDX_R     0x0E
#define DSP_MIX_INGAINIDX_L     0x0F
#define DSP_MIX_INGAINIDX_R     0x10
#define DSP_MIX_OUTGAINIDX_L    0x11
#define DSP_MIX_OUTGAINIDX_R    0x12
#define DSP_MIX_AGCIDX          0x13
#define DSP_MIX_TREBLEIDX_L     0x14
#define DSP_MIX_TREBLEIDX_R     0x15
#define DSP_MIX_BASSIDX_L       0x16
#define DSP_MIX_BASSIDX_R       0x17

#define DSP_MIX_BASEIDX         0x30
#define DSP_MIX_MAXREGS         (DSP_MIX_BASSIDX_R + 1)

#define DSP_MIX_IRQCONFIG       0x80
#define DSP_MIX_DMACONFIG       0x81

//
// Bit layout for DSP_MIX_OUTMIXIDX.
//
#define MIXBIT_MIC_LINEOUT      0
#define MIXBIT_CD_LINEOUT_R     1
#define MIXBIT_CD_LINEOUT_L     2
#define MIXBIT_LINEIN_LINEOUT_R 3
#define MIXBIT_LINEIN_LINEOUT_L 4

//
// Bit layout for DSP_MIX_ADCMIXIDX_L and DSP_MIX_ADCMIXIDX_R.
//
#define MIXBIT_MIC_WAVEIN       0
#define MIXBIT_CD_WAVEIN_R      1
#define MIXBIT_CD_WAVEIN_L      2
#define MIXBIT_LINEIN_WAVEIN_R  3
#define MIXBIT_LINEIN_WAVEIN_L  4
#define MIXBIT_SYNTH_WAVEIN_R   5
#define MIXBIT_SYNTH_WAVEIN_L   6

//
// Bit layout for MIXREG_MIC_AGC
//
#define MIXBIT_MIC_AGC          0

//
// MPU401 ports
//
#define MPU401_REG_STATUS   0x01    // Status register
#define MPU401_DRR          0x40    // Output ready (for command or data)
#define MPU401_DSR          0x80    // Input ready (for data)

#define MPU401_REG_DATA     0x00    // Data in
#define MPU401_REG_COMMAND  0x01    // Commands
#define MPU401_CMD_RESET    0xFF    // Reset command
#define MPU401_CMD_UART     0x3F    // Switch to UART mod

typedef struct
{
    PWCHAR   KeyName;
    BYTE     RegisterIndex;
    BYTE     RegisterSetting;
} MIXERSETTING,*PMIXERSETTING;

// {9B564276-A9B8-49a9-8456-3341CF46F9FC}
DEFINE_GUID(IID_IWaveMiniportSB16, 
0x9b564276, 0xa9b8, 0x49a9, 0x84, 0x56, 0x33, 0x41, 0xcf, 0x46, 0xf9, 0xfc);

/*****************************************************************************
 * IWaveMiniportSB16
 *****************************************************************************
 * Interface for wave miniport.
 */
DECLARE_INTERFACE_(IWaveMiniportSB16, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    STDMETHOD_(void,ServiceWaveISR)
    (   THIS
    )   PURE;
};

typedef IWaveMiniportSB16 *PWAVEMINIPORTSB16;


#ifdef EVENT_SUPPORT
// {885D00D1-E5E1-44c2-834B-64C4E1A79093}
DEFINE_GUID(IID_ITopoMiniportSB16, 
0x885d00d1, 0xe5e1, 0x44c2, 0x83, 0x4b, 0x64, 0xc4, 0xe1, 0xa7, 0x90, 0x93);

/*****************************************************************************
 * ITopoMiniportSB16
 *****************************************************************************
 * Interface for topology miniport.
 */
DECLARE_INTERFACE_(ITopoMiniportSB16, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    STDMETHOD_(void,ServiceEvent)
    (   THIS
    )   PURE;
};

typedef ITopoMiniportSB16 *PTOPOMINIPORTSB16;
#endif

DEFINE_GUID(IID_IAdapterCommon,
0x7eda2950, 0xbf9f, 0x11d0, 0x87, 0x1f, 0x0, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

/*****************************************************************************
 * IAdapterCommon
 *****************************************************************************
 * Interface for adapter common object.
 */
DECLARE_INTERFACE_(IAdapterCommon,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()           // For IUnknown

    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PRESOURCELIST   ResourceList,
        IN      PDEVICE_OBJECT  DeviceObject
    )   PURE;
    
    STDMETHOD_(PINTERRUPTSYNC,GetInterruptSync)
    (   THIS
    )   PURE;

    STDMETHOD_(void,SetWaveMiniport)
    (   THIS_
        IN      PWAVEMINIPORTSB16   Miniport
    )   PURE;

    STDMETHOD_(BYTE,ReadController)
    (   THIS
    )   PURE;

    STDMETHOD_(BOOLEAN,WriteController)
    (   THIS_
        IN      BYTE    Value
    )   PURE;

    STDMETHOD_(NTSTATUS,ResetController)
    (   THIS
    )   PURE;

    STDMETHOD_(void,MixerRegWrite)
    (   THIS_
        IN      BYTE    Index,
        IN      BYTE    Value
    )   PURE;
    
    STDMETHOD_(BYTE,MixerRegRead)
    (   THIS_
        IN      BYTE    Index
    )   PURE;

    STDMETHOD_(void,MixerReset)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,RestoreMixerSettingsFromRegistry)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,SaveMixerSettingsToRegistry)
    (   THIS
    )   PURE;

#ifdef EVENT_SUPPORT
    STDMETHOD_(void,SetTopologyMiniport)
    (   THIS_
        IN      PTOPOMINIPORTSB16   Miniport
    )   PURE;
#endif
};

typedef IAdapterCommon *PADAPTERCOMMON;


/*****************************************************************************
 * NewAdapterCommon()
 *****************************************************************************
 * Create a new adapter common object.
 */
NTSTATUS
NewAdapterCommon
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

#endif  //_COMMON_H_


=== sb16/makefile ===
#############################################################################
#
#       Copyright (c) 1998-2000 Microsoft Corporation
#       All Rights Reserved.
#
#       Makefile for wdm\audio\sb16
#
#############################################################################

## Define WIN95_BUILD to build in the memphis
## build enviroment

!IFDEF WIN95_BUILD

ROOT = ..\..\..\..\..

IS_32   = TRUE
IS_OEM  = TRUE
DEVICEDIR = sb16
COMMONMKFILE = $(DEVICEDIR).mk
DEPENDTARGETS = debug

!include $(ROOT)\dev\master.mk

## NT BUILD ENVIROMENT
!ELSE

#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT.
#
!INCLUDE $(NTMAKEENV)\makefile.def

!ENDIF


=== sb16/mintopo.cpp ===
/*****************************************************************************
 * mintopo.cpp - SB16 topology miniport implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation. All Rights Reserved.
 */

#include "limits.h"
#include "mintopo.h"

#define STR_MODULENAME "sb16topo: "

#define CHAN_LEFT       0
#define CHAN_RIGHT      1
#define CHAN_MASTER     (-1)


#pragma code_seg("PAGE")


/*****************************************************************************
 * CreateMiniportTopologySB16()
 *****************************************************************************
 * Creates a topology miniport object for the SB16 adapter.  This uses a
 * macro from STDUNK.H to do all the work.
 */
NTSTATUS
CreateMiniportTopologySB16
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportTopologySB16,Unknown,UnknownOuter,PoolType);
}

/*****************************************************************************
 * CMiniportTopologySB16::ProcessResources()
 *****************************************************************************
 * Processes the resource list.
 */
NTSTATUS
CMiniportTopologySB16::
ProcessResources
(
    IN  PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();

    ASSERT(ResourceList);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::ProcessResources]"));

    //
    // Get counts for the types of resources.
    //
    ULONG       countIO     = ResourceList->NumberOfPorts();
    ULONG       countIRQ    = ResourceList->NumberOfInterrupts();
    ULONG       countDMA    = ResourceList->NumberOfDmas();

    NTSTATUS    ntStatus    = STATUS_SUCCESS;

    //
    // Make sure we have the expected number of resources.
    //
    if  (   (countIO != 1)
        ||  (countIRQ != 0)
        ||  (countDMA != 0)
        )
    {
        _DbgPrintF(DEBUGLVL_TERSE,("unknown configuraton; check your code!"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportTopologySB16::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CMiniportTopologySB16::
NonDelegatingQueryInterface
(
    IN      REFIID  Interface,
    OUT     PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::NonDelegatingQueryInterface]"));

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportTopology))
    {
        *Object = PVOID(PMINIPORTTOPOLOGY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CMiniportTopologySB16::~CMiniportTopologySB16()
 *****************************************************************************
 * Destructor.
 */
CMiniportTopologySB16::
~CMiniportTopologySB16
(   void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::~CMiniportTopologySB16]"));

    if (AdapterCommon)
    {
#ifdef EVENT_SUPPORT
        AdapterCommon->SetTopologyMiniport (NULL);
#endif
        AdapterCommon->SaveMixerSettingsToRegistry();
        AdapterCommon->Release();
    }
#ifdef EVENT_SUPPORT
    if (PortEvents)
    {
        PortEvents->Release ();
        PortEvents = NULL;
    }
#endif
}

/*****************************************************************************
 * CMiniportTopologySB16::Init()
 *****************************************************************************
 * Initializes a the miniport.
 */
STDMETHODIMP
CMiniportTopologySB16::
Init
(
    IN      PUNKNOWN        UnknownAdapter,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTTOPOLOGY   Port
)
{
    PAGED_CODE();

    ASSERT(UnknownAdapter);
    ASSERT(ResourceList);
    ASSERT(Port);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::Init]"));

    NTSTATUS ntStatus =
        UnknownAdapter->QueryInterface
        (
            IID_IAdapterCommon,
            (PVOID *) &AdapterCommon
        );

    if (NT_SUCCESS(ntStatus))
    {
#ifdef EVENT_SUPPORT
        //
        // Get the port event interface.
        //
        Port->QueryInterface (IID_IPortEvents, (PVOID *)&PortEvents);
        
        //
        // We need to notify AdapterCommon of the miniport interface.
        // AdapterCommon needs this in his ISR to fire the event.
        //
        AdapterCommon->SetTopologyMiniport ((PTOPOMINIPORTSB16)this);
    
        //
        // Enable external volume control interrupt.
        //
        BYTE bIntrMask = AdapterCommon->MixerRegRead (0x83);
        bIntrMask |= 0x10;
        AdapterCommon->MixerRegWrite (0x83, bIntrMask);
#endif    
        ntStatus = ProcessResources(ResourceList);

        if (NT_SUCCESS(ntStatus))
        {
            AdapterCommon->MixerReset();
        }
    }

    if( !NT_SUCCESS(ntStatus) )
    {
        //
        // clean up our mess
        //

        // clean up AdapterCommon
        if( AdapterCommon )
        {
            AdapterCommon->Release();
            AdapterCommon = NULL;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportTopologySB16::GetDescription()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP
CMiniportTopologySB16::
GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::GetDescription]"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * PropertyHandler_OnOff()
 *****************************************************************************
 * Accesses a KSAUDIO_ONOFF value property.
 */
static
NTSTATUS
PropertyHandler_OnOff
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::PropertyHandler_OnOff]"));

    CMiniportTopologySB16 *that =
        (CMiniportTopologySB16 *) PropertyRequest->MajorTarget;

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    BYTE            data;
    LONG            channel;

    // validate node
    if (PropertyRequest->Node != ULONG(-1))
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            // get the instance channel parameter
            if(PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));

                // validate and get the output parameter
                if (PropertyRequest->ValueSize >= sizeof(BOOL))
                {
                    PBOOL OnOff = PBOOL(PropertyRequest->Value);
    
                    // switch on node id
                    switch(PropertyRequest->Node)
                    {
                        case MIC_AGC:   // Microphone AGC Control (mono)
                            // check if AGC property request on mono/left channel
                            if( ( PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_AGC ) &&
                                ( channel == CHAN_LEFT ) )
                            {
                                data = that->ReadBitsFromMixer( DSP_MIX_AGCIDX,
                                                          1,
                                                          MIXBIT_MIC_AGC );
                                *OnOff = data ? FALSE : TRUE;
                                PropertyRequest->ValueSize = sizeof(BOOL);
                                ntStatus = STATUS_SUCCESS;
                            }
                            break;
    
                        case MIC_LINEOUT_MUTE:  // Microphone Lineout Mute Control (mono)
                            // check if MUTE property request on mono/left channel
                            if( ( PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_MUTE ) &&
                                ( channel == CHAN_LEFT ) )
                            {
                                data = that->ReadBitsFromMixer( DSP_MIX_OUTMIXIDX,
                                                          1,
                                                          MIXBIT_MIC_LINEOUT );
                                *OnOff = data ? FALSE : TRUE;
                                PropertyRequest->ValueSize = sizeof(BOOL);
                                ntStatus = STATUS_SUCCESS;
                            }
                            break;
                    }
                }
            }

        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
        {
            // get the instance channel parameter
            if(PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));
                
                // validate and get the input parameter
                if (PropertyRequest->ValueSize == sizeof(BOOL))
                {
                    BYTE value = *(PBOOL(PropertyRequest->Value)) ? 0 : 1;
    
                    // switch on the node id
                    switch(PropertyRequest->Node)
                    {
                        case MIC_AGC:   // Microphone AGC Control (mono)
                            // check if AGC property request on mono/left channel
                            if( ( PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_AGC ) &&
                                ( channel == CHAN_LEFT ) )
                            {
                                that->WriteBitsToMixer( DSP_MIX_AGCIDX,
                                                  1,
                                                  MIXBIT_MIC_AGC,
                                                  value );
                                ntStatus = STATUS_SUCCESS;
                            }
                            break;
    
                        case MIC_LINEOUT_MUTE:  // Microphone Lineout Mute Control (mono)
                            // check if MUTE property request on mono/left channel
                            if( ( PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_MUTE ) &&
                                ( channel == CHAN_LEFT ) )
                            {
                                that->WriteBitsToMixer( DSP_MIX_OUTMIXIDX,
                                                  1,
                                                  MIXBIT_MIC_LINEOUT,
                                                  value );
                                ntStatus = STATUS_SUCCESS;
                            }
                            break;
                    }
                }
            }
        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            if ( ( (PropertyRequest->Node == MIC_AGC) && (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_AGC) ) ||
                 ( (PropertyRequest->Node == MIC_LINEOUT_MUTE) && (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_MUTE) ) )
            {
                if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
                {
                    // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
                    PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);

                    PropDesc->AccessFlags       = KSPROPERTY_TYPE_BASICSUPPORT |
                                                  KSPROPERTY_TYPE_GET |
                                                  KSPROPERTY_TYPE_SET;
                    PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION);
                    PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
                    PropDesc->PropTypeSet.Id    = VT_BOOL;
                    PropDesc->PropTypeSet.Flags = 0;
                    PropDesc->MembersListCount  = 0;
                    PropDesc->Reserved          = 0;

                    // set the return value size
                    PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
                    ntStatus = STATUS_SUCCESS;
                } else if(PropertyRequest->ValueSize >= sizeof(ULONG))
                {
                    // if return buffer can hold a ULONG, return the access flags
                    PULONG AccessFlags = PULONG(PropertyRequest->Value);
            
                    *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                   KSPROPERTY_TYPE_GET |
                                   KSPROPERTY_TYPE_SET;
            
                    // set the return value size
                    PropertyRequest->ValueSize = sizeof(ULONG);
                    ntStatus = STATUS_SUCCESS;                    
                }
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * BasicSupportHandler()
 *****************************************************************************
 * Assists in BASICSUPPORT accesses on level properties
 */
static
NTSTATUS
BasicSupportHandler
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[BasicSupportHandler]"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
    {
        // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
        PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);

        PropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                KSPROPERTY_TYPE_GET |
                                KSPROPERTY_TYPE_SET;
        PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION) +
                                      sizeof(KSPROPERTY_MEMBERSHEADER) +
                                      sizeof(KSPROPERTY_STEPPING_LONG);
        PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        PropDesc->PropTypeSet.Id    = VT_I4;
        PropDesc->PropTypeSet.Flags = 0;
        PropDesc->MembersListCount  = 1;
        PropDesc->Reserved          = 0;

        // if return buffer cn also hold a range description, return it too
        if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION) +
                                      sizeof(KSPROPERTY_MEMBERSHEADER) +
                                      sizeof(KSPROPERTY_STEPPING_LONG)))
        {
            // fill in the members header
            PKSPROPERTY_MEMBERSHEADER Members = PKSPROPERTY_MEMBERSHEADER(PropDesc + 1);

            Members->MembersFlags   = KSPROPERTY_MEMBER_STEPPEDRANGES;
            Members->MembersSize    = sizeof(KSPROPERTY_STEPPING_LONG);
            Members->MembersCount   = 1;
            Members->Flags          = 0;

            // fill in the stepped range
            PKSPROPERTY_STEPPING_LONG Range = PKSPROPERTY_STEPPING_LONG(Members + 1);

            switch(PropertyRequest->Node)
            {
                case WAVEOUT_VOLUME:
                case SYNTH_VOLUME:
                case CD_VOLUME:
                case LINEIN_VOLUME:
                case MIC_VOLUME:
                case LINEOUT_VOL:
                    Range->Bounds.SignedMaximum = 0;            // 0   (dB) * 0x10000
                    Range->Bounds.SignedMinimum = 0xFFC20000;   // -62 (dB) * 0x10000
                    Range->SteppingDelta        = 0x20000;      // 2   (dB) * 0x10000
                    break;

                case LINEOUT_GAIN:
                case WAVEIN_GAIN:
                    Range->Bounds.SignedMaximum = 0x120000;     // 18  (dB) * 0x10000
                    Range->Bounds.SignedMinimum = 0;            // 0   (dB) * 0x10000
                    Range->SteppingDelta        = 0x60000;      // 6   (dB) * 0x10000
                    break;

                case LINEOUT_BASS:
                case LINEOUT_TREBLE:
                    Range->Bounds.SignedMaximum = 0xE0000;      // 14  (dB) * 0x10000
                    Range->Bounds.SignedMinimum = 0xFFF20000;   // -14 (dB) * 0x10000
                    Range->SteppingDelta        = 0x20000;      // 2   (dB) * 0x10000
                    break;

            }
            Range->Reserved         = 0;

            _DbgPrintF(DEBUGLVL_BLAB, ("---Node: %d  Max: 0x%X  Min: 0x%X  Step: 0x%X",PropertyRequest->Node,
                                                                                       Range->Bounds.SignedMaximum,
                                                                                       Range->Bounds.SignedMinimum,
                                                                                       Range->SteppingDelta));

            // set the return value size
            PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION) +
                                         sizeof(KSPROPERTY_MEMBERSHEADER) +
                                         sizeof(KSPROPERTY_STEPPING_LONG);
        } else
        {
            // set the return value size
            PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
        }
        ntStatus = STATUS_SUCCESS;

    } else if(PropertyRequest->ValueSize >= sizeof(ULONG))
    {
        // if return buffer can hold a ULONG, return the access flags
        PULONG AccessFlags = PULONG(PropertyRequest->Value);

        *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                       KSPROPERTY_TYPE_GET |
                       KSPROPERTY_TYPE_SET;

        // set the return value size
        PropertyRequest->ValueSize = sizeof(ULONG);
        ntStatus = STATUS_SUCCESS;

    }

    return ntStatus;
}

/*****************************************************************************
 * PropertyHandler_Level()
 *****************************************************************************
 * Accesses a KSAUDIO_LEVEL property.
 */
static
NTSTATUS
PropertyHandler_Level
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::PropertyHandler_Level]"));

    CMiniportTopologySB16 *that =
        (CMiniportTopologySB16 *) PropertyRequest->MajorTarget;

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    ULONG           count;
    LONG            channel;

    // validate node
    if(PropertyRequest->Node != ULONG(-1))
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            // get the instance channel parameter
            if(PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));

                // only support get requests on either mono/left (0) or right (1) channels
                if ( (channel == CHAN_LEFT) || (channel == CHAN_RIGHT) )
                {
                    // validate and get the output parameter
                    if (PropertyRequest->ValueSize >= sizeof(LONG))
                    {
                        PLONG Level = (PLONG)PropertyRequest->Value;

                        // switch on node if
                        switch(PropertyRequest->Node)
                        {
                            case WAVEOUT_VOLUME:
                            case SYNTH_VOLUME:
                            case CD_VOLUME:
                            case LINEIN_VOLUME:
                            case MIC_VOLUME:
                            case LINEOUT_VOL:
                                // check if volume property request
                                if(PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                                {
                                    // bail out if a right channel request on the mono mic volume
                                    if( (PropertyRequest->Node == MIC_VOLUME) && (channel != CHAN_LEFT) )
                                    {
                                        break;
                                    }
                                    *Level = ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + channel ];

#ifdef EVENT_SUPPORT
                                    //
                                    // see if there is a volume changed, update if neccessary.
                                    //
                                    BYTE data = that->ReadBitsFromMixer (
                                            BYTE(AccessParams[PropertyRequest->Node].BaseRegister
                                                 +channel+DSP_MIX_BASEIDX),
                                            5, 3);

                                    //
                                    // Convert the dB value into a register value. No boundary check.
                                    // Register is 0 - 31 representing -62dB - 0dB.
                                    //
                                    if (data != ((*Level >> 17) + 31))
                                    {
                                        //
                                        // Convert the register into dB value.
                                        // Register is 0 - 31 representing -62dB - 0dB.
                                        //
                                        *Level = (data - 31) << 17;
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + channel] = *Level;
                                    }
#endif

                                    PropertyRequest->ValueSize = sizeof(LONG);
                                    ntStatus = STATUS_SUCCESS;
                                }
                                break;
        
                            case LINEOUT_GAIN:
                            case WAVEIN_GAIN:
                                // check if volume property request
                                if(PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                                {
                                    *Level = ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + channel ];
                                    PropertyRequest->ValueSize = sizeof(LONG);
                                    ntStatus = STATUS_SUCCESS;
                                }
                                break;

                            case LINEOUT_BASS:
                            case LINEOUT_TREBLE:
                                if( ( (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_BASS) &&
                                      (PropertyRequest->Node == LINEOUT_BASS) ) ||
                                    ( (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_TREBLE) &&
                                      (PropertyRequest->Node == LINEOUT_TREBLE) ) )
                                {
                                    *Level = ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + channel ];
                                    PropertyRequest->ValueSize = sizeof(LONG);
                                    ntStatus = STATUS_SUCCESS;
                                }
                                break;
                        }
                    }
                }
            }

        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
        {
            // get the instance channel parameter
            if(PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));

                // only support set requests on either mono/left (0), right (1), or master (-1) channels
                if ( (channel == CHAN_LEFT) || (channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
                {
                    // validate and get the input parameter
                    if (PropertyRequest->ValueSize == sizeof(LONG))
                    {
                        PLONG Level = (PLONG)PropertyRequest->Value;

                        // switch on the node id
                        switch(PropertyRequest->Node)
                        {
                            case WAVEOUT_VOLUME:
                            case SYNTH_VOLUME:
                            case CD_VOLUME:
                            case LINEIN_VOLUME:
                            case MIC_VOLUME:
                            case LINEOUT_VOL:
                                if(PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                                {
                                    // convert the level to register bits
                                    if(*Level <= (-62 << 16))
                                    {
                                        count = 0;
                                    } else if(*Level >= 0)
                                    {
                                        count = 0x1F;
                                    } else
                                    {
                                        count = ((*Level >> 17) + 31) & 0x1F;
                                    }

                                    // set right channel if channel requested is right or master
                                    // and node is not mic volume (mono)
                                    if ( ( (channel == CHAN_RIGHT) || (channel == CHAN_MASTER) ) &&
                                         ( PropertyRequest->Node != MIC_VOLUME ) )
                                    {
                                        // cache the commanded control value
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + CHAN_RIGHT ] = *Level;

                                        that->WriteBitsToMixer( AccessParams[PropertyRequest->Node].BaseRegister+1,
                                                          5,
                                                          3,
                                                          BYTE(count) );
                                        ntStatus = STATUS_SUCCESS;
                                    }
                                    // set the left channel if channel requested is left or master
                                    if ( (channel == CHAN_LEFT) || (channel == CHAN_MASTER) )
                                    {
                                        // cache the commanded control value
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + CHAN_LEFT ] = *Level;
                                        
                                        that->WriteBitsToMixer( AccessParams[PropertyRequest->Node].BaseRegister,
                                                          5,
                                                          3,
                                                          BYTE(count) );
                                        ntStatus = STATUS_SUCCESS;
                                    }
                                }
                                break;
        
                            case LINEOUT_GAIN:
                            case WAVEIN_GAIN:
                                if(PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                                {                                                                        
                                    // determine register bits
                                    if(*Level >= (18 << 16))
                                    {
                                        count = 0x3;
                                    } else if(*Level <= 0)
                                    {
                                        count = 0;
                                    } else
                                    {
                                        count = (*Level >> 17) / 3;
                                    }
    
                                    // set right channel if channel requested is right or master
                                    if ( (channel == CHAN_RIGHT) || (channel == CHAN_MASTER) )
                                    {
                                        // cache the commanded control value
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + CHAN_RIGHT ] = *Level;

                                        that->WriteBitsToMixer( AccessParams[PropertyRequest->Node].BaseRegister+1,
                                                          2,
                                                          6,
                                                          BYTE(count) );
                                        ntStatus = STATUS_SUCCESS;
                                    }
                                    // set the left channel if channel requested is left or master
                                    if ( (channel == CHAN_LEFT) || (channel == CHAN_MASTER) )
                                    {
                                        // cache the commanded control value
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + CHAN_LEFT ] = *Level;

                                        that->WriteBitsToMixer( AccessParams[PropertyRequest->Node].BaseRegister,
                                                          2,
                                                          6,
                                                          BYTE(count) );
                                        ntStatus = STATUS_SUCCESS;
                                    }
                                }
                                break;
        
                            case LINEOUT_BASS:
                            case LINEOUT_TREBLE:
                                if( ( (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_BASS) &&
                                      (PropertyRequest->Node == LINEOUT_BASS) ) ||
                                    ( (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_TREBLE) &&
                                      (PropertyRequest->Node == LINEOUT_TREBLE) ) )
                                {
                                    // determine register bits
                                    if(*Level <= (-14 << 16))
                                    {
                                        count = 0;
                                    } else if(*Level >= (14 << 16))
                                    {
                                        count = 0xF;
                                    } else
                                    {
                                        count = ((*Level >> 16) + 14) >> 1;
                                    }

                                    // set right channel if channel requested is right or master
                                    if ( (channel == CHAN_RIGHT) || (channel == CHAN_MASTER) )
                                    {
                                        // cache the commanded control value
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + CHAN_RIGHT ] = *Level;
        
                                        that->WriteBitsToMixer( AccessParams[PropertyRequest->Node].BaseRegister + 1,
                                                          4,
                                                          4,
                                                          BYTE(count) );
                                        ntStatus = STATUS_SUCCESS;
                                    }
                                    // set the left channel if channel requested is left or master
                                    if ( (channel == CHAN_LEFT) || (channel == CHAN_MASTER) )
                                    {
                                        // cache the commanded control value
                                        ControlValueCache[ AccessParams[PropertyRequest->Node].CacheOffset + CHAN_LEFT ] = *Level;
                                        
                                        that->WriteBitsToMixer( AccessParams[PropertyRequest->Node].BaseRegister,
                                                          4,
                                                          4,
                                                          BYTE(count) );
                                        ntStatus = STATUS_SUCCESS;
                                    }
                                }
                                break;
                        }
                    }
                }
            }

        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            // service basic support request
            switch(PropertyRequest->Node)
            {
                case WAVEOUT_VOLUME:
                case SYNTH_VOLUME:
                case CD_VOLUME:
                case LINEIN_VOLUME:
                case MIC_VOLUME:
                case LINEOUT_VOL:
                case LINEOUT_GAIN:
                case WAVEIN_GAIN:
                    if(PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                    {
                        ntStatus = BasicSupportHandler(PropertyRequest);
                    }
                    break;

                case LINEOUT_BASS:
                case LINEOUT_TREBLE:
                    if( ( (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_BASS) &&
                          (PropertyRequest->Node == LINEOUT_BASS) ) ||
                        ( (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_TREBLE) &&
                          (PropertyRequest->Node == LINEOUT_TREBLE) ) )
                    {
                        ntStatus = BasicSupportHandler(PropertyRequest);
                    }
                    break;
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertyHandler_SuperMixCaps()
 *****************************************************************************
 * Handles supermixer caps accesses
 */
static
NTSTATUS
PropertyHandler_SuperMixCaps
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::PropertyHandler_SuperMixCaps]"));

    CMiniportTopologySB16 *that =
        (CMiniportTopologySB16 *) PropertyRequest->MajorTarget;

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    ULONG           count;

    // validate node
    if(PropertyRequest->Node != ULONG(-1))
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            switch(PropertyRequest->Node)
            {
                // Full 2x2 Switches
                case SYNTH_WAVEIN_SUPERMIX:
                case CD_WAVEIN_SUPERMIX:
                case LINEIN_WAVEIN_SUPERMIX:
                    if(!PropertyRequest->ValueSize)
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(ULONG) + 4 * sizeof(KSAUDIO_MIX_CAPS);
                        ntStatus = STATUS_BUFFER_OVERFLOW;
                    } else if(PropertyRequest->ValueSize == 2 * sizeof(ULONG))
                    {
                        PKSAUDIO_MIXCAP_TABLE MixCaps = (PKSAUDIO_MIXCAP_TABLE)PropertyRequest->Value;
                        MixCaps->InputChannels = 2;
                        MixCaps->OutputChannels = 2;
                        ntStatus = STATUS_SUCCESS;
                    } else if(PropertyRequest->ValueSize >= 2 * sizeof(ULONG) + 4 * sizeof(KSAUDIO_MIX_CAPS))
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(ULONG) + 4 * sizeof(KSAUDIO_MIX_CAPS);

                        PKSAUDIO_MIXCAP_TABLE MixCaps = (PKSAUDIO_MIXCAP_TABLE)PropertyRequest->Value;
                        MixCaps->InputChannels = 2;
                        MixCaps->OutputChannels = 2;
                        for(count = 0; count < 4; count++)
                        {
                            MixCaps->Capabilities[count].Mute = TRUE;
                            MixCaps->Capabilities[count].Minimum = 0;
                            MixCaps->Capabilities[count].Maximum = 0;
                            MixCaps->Capabilities[count].Reset = 0;
                        }
                        ntStatus = STATUS_SUCCESS;
                    }
                    break;

                // Limited 2x2 Switches
                case CD_LINEOUT_SUPERMIX:
                case LINEIN_LINEOUT_SUPERMIX:
                    if(!PropertyRequest->ValueSize)
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(ULONG) + 4 * sizeof(KSAUDIO_MIX_CAPS);
                        ntStatus = STATUS_BUFFER_OVERFLOW;
                    } else if(PropertyRequest->ValueSize == 2 * sizeof(ULONG))
                    {
                        PKSAUDIO_MIXCAP_TABLE MixCaps = (PKSAUDIO_MIXCAP_TABLE)PropertyRequest->Value;
                        MixCaps->InputChannels = 2;
                        MixCaps->OutputChannels = 2;
                        ntStatus = STATUS_SUCCESS;
                    } else if(PropertyRequest->ValueSize >= 2 * sizeof(ULONG) + 4 * sizeof(KSAUDIO_MIX_CAPS))
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(ULONG) + 4 * sizeof(KSAUDIO_MIX_CAPS);

                        PKSAUDIO_MIXCAP_TABLE MixCaps = (PKSAUDIO_MIXCAP_TABLE)PropertyRequest->Value;
                        MixCaps->InputChannels = 2;
                        MixCaps->OutputChannels = 2;
                        for(count = 0; count < 4; count++)
                        {
                            if((count == 0) || (count == 3))
                            {
                                MixCaps->Capabilities[count].Mute = TRUE;
                                MixCaps->Capabilities[count].Minimum = 0;
                                MixCaps->Capabilities[count].Maximum = 0;
                                MixCaps->Capabilities[count].Reset = 0;
                            } else
                            {
                                MixCaps->Capabilities[count].Mute = FALSE;
                                MixCaps->Capabilities[count].Minimum = LONG_MIN;
                                MixCaps->Capabilities[count].Maximum = LONG_MIN;
                                MixCaps->Capabilities[count].Reset = LONG_MIN;
                            }
                        }
                        ntStatus = STATUS_SUCCESS;
                    }
                    break;


                // 1x2 Switch
                case MIC_WAVEIN_SUPERMIX:
                    if(!PropertyRequest->ValueSize)
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(ULONG) + 2 * sizeof(KSAUDIO_MIX_CAPS);
                        ntStatus = STATUS_BUFFER_OVERFLOW;
                    } else if(PropertyRequest->ValueSize == 2 * sizeof(ULONG))
                    {
                        PKSAUDIO_MIXCAP_TABLE MixCaps = (PKSAUDIO_MIXCAP_TABLE)PropertyRequest->Value;
                        MixCaps->InputChannels = 1;
                        MixCaps->OutputChannels = 2;
                        ntStatus = STATUS_SUCCESS;
                    } else if(PropertyRequest->ValueSize >= 2 * sizeof(ULONG) + 2 * sizeof(KSAUDIO_MIX_CAPS))
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(ULONG) + 2 * sizeof(KSAUDIO_MIX_CAPS);

                        PKSAUDIO_MIXCAP_TABLE MixCaps = (PKSAUDIO_MIXCAP_TABLE)PropertyRequest->Value;
                        MixCaps->InputChannels = 1;
                        MixCaps->OutputChannels = 2;
                        for(count = 0; count < 2; count++)
                        {
                            MixCaps->Capabilities[count].Mute = TRUE;
                            MixCaps->Capabilities[count].Minimum = 0;
                            MixCaps->Capabilities[count].Maximum = 0;
                            MixCaps->Capabilities[count].Reset = 0;
                        }
                        ntStatus = STATUS_SUCCESS;
                    }
                    break;
            }

        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            // service basic support request
            switch(PropertyRequest->Node)
            {
                case SYNTH_WAVEIN_SUPERMIX:
                case CD_WAVEIN_SUPERMIX:
                case LINEIN_WAVEIN_SUPERMIX:
                case CD_LINEOUT_SUPERMIX:
                case LINEIN_LINEOUT_SUPERMIX:
                case MIC_WAVEIN_SUPERMIX:
                    if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
                    {
                        // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
                        PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);
    
                        PropDesc->AccessFlags       = KSPROPERTY_TYPE_BASICSUPPORT |
                                                      KSPROPERTY_TYPE_GET;
                        PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION);
                        PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
                        PropDesc->PropTypeSet.Id    = VT_ARRAY;
                        PropDesc->PropTypeSet.Flags = 0;
                        PropDesc->MembersListCount  = 0;
                        PropDesc->Reserved          = 0;
    
                        // set the return value size
                        PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
                        ntStatus = STATUS_SUCCESS;
                    } else if(PropertyRequest->ValueSize >= sizeof(ULONG))
                    {
                        // if return buffer can hold a ULONG, return the access flags
                        PULONG AccessFlags = PULONG(PropertyRequest->Value);
                
                        *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                       KSPROPERTY_TYPE_GET;
                
                        // set the return value size
                        PropertyRequest->ValueSize = sizeof(ULONG);
                        ntStatus = STATUS_SUCCESS;                    
                    }
                    ntStatus = STATUS_SUCCESS;
                    break;
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertyHandler_SuperMixTable()
 *****************************************************************************
 * Handles supermixer level accesses
 */
static
NTSTATUS
PropertyHandler_SuperMixTable
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::PropertyHandler_SuperMixTable]"));

    CMiniportTopologySB16 *that =
        (CMiniportTopologySB16 *) PropertyRequest->MajorTarget;

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    BYTE            dataL,dataR;

    // validate node
    if(PropertyRequest->Node != ULONG(-1))
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            switch(PropertyRequest->Node)
            {
                // Full 2x2 Switches
                case SYNTH_WAVEIN_SUPERMIX:
                case CD_WAVEIN_SUPERMIX:
                case LINEIN_WAVEIN_SUPERMIX:
                    if(!PropertyRequest->ValueSize)
                    {
                        PropertyRequest->ValueSize = 4 * sizeof(KSAUDIO_MIXLEVEL);
                        ntStatus = STATUS_BUFFER_OVERFLOW;
                    } else if(PropertyRequest->ValueSize >= 4 * sizeof(KSAUDIO_MIXLEVEL))
                    {
                        PropertyRequest->ValueSize = 4 * sizeof(KSAUDIO_MIXLEVEL);

                        PKSAUDIO_MIXLEVEL MixLevel = (PKSAUDIO_MIXLEVEL)PropertyRequest->Value;

                        dataL = that->ReadBitsFromMixer( DSP_MIX_ADCMIXIDX_L,
                                                  2,
                                                  AccessParams[PropertyRequest->Node].BaseRegister );
                        dataR = that->ReadBitsFromMixer( DSP_MIX_ADCMIXIDX_R,
                                                  2,
                                                  AccessParams[PropertyRequest->Node].BaseRegister );

                        MixLevel[0].Mute = dataL & 0x2 ? FALSE : TRUE;          // left to left mute
                        MixLevel[0].Level = 0;

                        MixLevel[1].Mute = dataR & 0x2 ? FALSE : TRUE;          // left to right mute
                        MixLevel[1].Level = 0;

                        MixLevel[2].Mute = dataL & 0x1 ? FALSE : TRUE;          // right to left mute
                        MixLevel[2].Level = 0;

                        MixLevel[3].Mute = dataR & 0x1 ? FALSE : TRUE;          // right to right mute
                        MixLevel[3].Level = 0;

                        ntStatus = STATUS_SUCCESS;
                    }
                    break;

                // Limited 2x2 Switches
                case CD_LINEOUT_SUPERMIX:
                case LINEIN_LINEOUT_SUPERMIX:
                    if(!PropertyRequest->ValueSize)
                    {
                        PropertyRequest->ValueSize = 4 * sizeof(KSAUDIO_MIXLEVEL);
                        ntStatus = STATUS_BUFFER_OVERFLOW;
                    } else if(PropertyRequest->ValueSize >= 4 * sizeof(KSAUDIO_MIXLEVEL))
                    {
                        PropertyRequest->ValueSize = 4 * sizeof(KSAUDIO_MIXLEVEL);

                        PKSAUDIO_MIXLEVEL MixLevel = (PKSAUDIO_MIXLEVEL)PropertyRequest->Value;

                        dataL = that->ReadBitsFromMixer( DSP_MIX_OUTMIXIDX,
                                                   2,
                                                   AccessParams[PropertyRequest->Node].BaseRegister );

                        MixLevel[0].Mute = dataL & 0x2 ? FALSE : TRUE;          // left to left mute
                        MixLevel[0].Level = 0;

                        MixLevel[1].Mute = FALSE;
                        MixLevel[1].Level = LONG_MIN;

                        MixLevel[2].Mute = FALSE;
                        MixLevel[2].Level = LONG_MIN;

                        MixLevel[3].Mute = dataL & 0x1 ? FALSE : TRUE;          // right to right mute
                        MixLevel[3].Level = 0;

                        ntStatus = STATUS_SUCCESS;
                    }
                    break;


                // 1x2 Switch
                case MIC_WAVEIN_SUPERMIX:
                    if(!PropertyRequest->ValueSize)
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(KSAUDIO_MIXLEVEL);
                        ntStatus = STATUS_BUFFER_OVERFLOW;
                    } else if(PropertyRequest->ValueSize >= 2 * sizeof(KSAUDIO_MIXLEVEL))
                    {
                        PropertyRequest->ValueSize = 2 * sizeof(KSAUDIO_MIXLEVEL);

                        PKSAUDIO_MIXLEVEL MixLevel = (PKSAUDIO_MIXLEVEL)PropertyRequest->Value;

                        dataL = that->ReadBitsFromMixer( DSP_MIX_ADCMIXIDX_L,
                                                  1,
                                                  MIXBIT_MIC_WAVEIN );
                        dataR = that->ReadBitsFromMixer( DSP_MIX_ADCMIXIDX_R,
                                                  1,
                                                  MIXBIT_MIC_WAVEIN );

                        MixLevel[0].Mute = dataL & 0x1 ? FALSE : TRUE;          // mono to left mute
                        MixLevel[0].Level = 0;

                        MixLevel[1].Mute = dataR & 0x1 ? FALSE : TRUE;          // mono to right mute
                        MixLevel[1].Level = 0;

                        ntStatus = STATUS_SUCCESS;
                    }
                    break;
            }

        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
        {
            switch(PropertyRequest->Node)
            {
                // Full 2x2 Switches
                case SYNTH_WAVEIN_SUPERMIX:
                case CD_WAVEIN_SUPERMIX:
                case LINEIN_WAVEIN_SUPERMIX:
                    if(PropertyRequest->ValueSize == 4 * sizeof(KSAUDIO_MIXLEVEL))
                    {
                        PKSAUDIO_MIXLEVEL MixLevel = (PKSAUDIO_MIXLEVEL)PropertyRequest->Value;

                        dataL = MixLevel[0].Mute ? 0x0 : 0x2;
                        dataL |= MixLevel[2].Mute ? 0x0 : 0x1;

                        dataR = MixLevel[1].Mute ? 0x0 : 0x2;
                        dataR |= MixLevel[3].Mute ? 0x0 : 0x1;


                        that->WriteBitsToMixer( DSP_MIX_ADCMIXIDX_L,
                                          2,
                                          AccessParams[PropertyRequest->Node].BaseRegister,
                                          dataL );

                        that->WriteBitsToMixer( DSP_MIX_ADCMIXIDX_R,
                                          2,
                                          AccessParams[PropertyRequest->Node].BaseRegister,
                                          dataR );

                        ntStatus = STATUS_SUCCESS;
                    }
                    break;

                // Limited 2x2 Switches
                case CD_LINEOUT_SUPERMIX:
                case LINEIN_LINEOUT_SUPERMIX:
                    if(PropertyRequest->ValueSize == 4 * sizeof(KSAUDIO_MIXLEVEL))
                    {
                        PKSAUDIO_MIXLEVEL MixLevel = (PKSAUDIO_MIXLEVEL)PropertyRequest->Value;

                        dataL = MixLevel[0].Mute ? 0x0 : 0x2;
                        dataL |= MixLevel[3].Mute ? 0x0 : 0x1;

                        that->WriteBitsToMixer( DSP_MIX_OUTMIXIDX,
                                          2,
                                          AccessParams[PropertyRequest->Node].BaseRegister,
                                          dataL );

                        ntStatus = STATUS_SUCCESS;
                    }
                    break;


                // 1x2 Switch
                case MIC_WAVEIN_SUPERMIX:
                    if(PropertyRequest->ValueSize == 2 * sizeof(KSAUDIO_MIXLEVEL))
                    {
                        PKSAUDIO_MIXLEVEL MixLevel = (PKSAUDIO_MIXLEVEL)PropertyRequest->Value;

                        dataL = MixLevel[0].Mute ? 0x0 : 0x1;
                        dataR = MixLevel[1].Mute ? 0x0 : 0x1;

                        that->WriteBitsToMixer( DSP_MIX_ADCMIXIDX_L,
                                          1,
                                          MIXBIT_MIC_WAVEIN,
                                          dataL );

                        that->WriteBitsToMixer( DSP_MIX_ADCMIXIDX_R,
                                          1,
                                          MIXBIT_MIC_WAVEIN,
                                          dataR );

                        ntStatus = STATUS_SUCCESS;
                    }
                    break;
            }

        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            // service basic support request
            switch(PropertyRequest->Node)
            {
                case SYNTH_WAVEIN_SUPERMIX:
                case CD_WAVEIN_SUPERMIX:
                case LINEIN_WAVEIN_SUPERMIX:
                case CD_LINEOUT_SUPERMIX:
                case LINEIN_LINEOUT_SUPERMIX:
                case MIC_WAVEIN_SUPERMIX:
                    if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
                    {
                        // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
                        PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);
    
                        PropDesc->AccessFlags       = KSPROPERTY_TYPE_BASICSUPPORT |
                                                      KSPROPERTY_TYPE_GET |
                                                      KSPROPERTY_TYPE_SET;
                        PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION);
                        PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
                        PropDesc->PropTypeSet.Id    = VT_ARRAY;
                        PropDesc->PropTypeSet.Flags = 0;
                        PropDesc->MembersListCount  = 0;
                        PropDesc->Reserved          = 0;
    
                        // set the return value size
                        PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
                        ntStatus = STATUS_SUCCESS;
                    } else if(PropertyRequest->ValueSize >= sizeof(ULONG))
                    {
                        // if return buffer can hold a ULONG, return the access flags
                        PULONG AccessFlags = PULONG(PropertyRequest->Value);
                
                        *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                       KSPROPERTY_TYPE_GET |
                                       KSPROPERTY_TYPE_SET;
                
                        // set the return value size
                        PropertyRequest->ValueSize = sizeof(ULONG);
                        ntStatus = STATUS_SUCCESS;                    
                    }
                    break;
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertyHandler_CpuResources()
 *****************************************************************************
 * Propcesses a KSPROPERTY_AUDIO_CPU_RESOURCES request
 */
static
NTSTATUS
PropertyHandler_CpuResources
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportTopologySB16::PropertyHandler_CpuResources]"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    // validate node
    if(PropertyRequest->Node != ULONG(-1))
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            if(PropertyRequest->ValueSize >= sizeof(LONG))
            {
                *(PLONG(PropertyRequest->Value)) = KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU;
                PropertyRequest->ValueSize = sizeof(LONG);
                ntStatus = STATUS_SUCCESS;
            } else
            {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
        } else if(PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
            {
                // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
                PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);

                PropDesc->AccessFlags       = KSPROPERTY_TYPE_BASICSUPPORT |
                                              KSPROPERTY_TYPE_GET;
                PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION);
                PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
                PropDesc->PropTypeSet.Id    = VT_I4;
                PropDesc->PropTypeSet.Flags = 0;
                PropDesc->MembersListCount  = 0;
                PropDesc->Reserved          = 0;

                // set the return value size
                PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
                ntStatus = STATUS_SUCCESS;
            } else if(PropertyRequest->ValueSize >= sizeof(ULONG))
            {
                // if return buffer can hold a ULONG, return the access flags
                PULONG AccessFlags = PULONG(PropertyRequest->Value);
        
                *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                               KSPROPERTY_TYPE_GET |
                               KSPROPERTY_TYPE_SET;
        
                // set the return value size
                PropertyRequest->ValueSize = sizeof(ULONG);
                ntStatus = STATUS_SUCCESS;                    
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * ThisManyOnes()
 *****************************************************************************
 * Returns a byte with the indicated number of ones in the low end.
 */
inline
BYTE
ThisManyOnes
(
    IN      BYTE Ones
)
{
    return ~(BYTE(0xff) << Ones);
}

/*****************************************************************************
 * CMiniportTopologySB16::ReadBitsFromMixer()
 *****************************************************************************
 * Reads specified bits from a mixer register.
 */
BYTE
CMiniportTopologySB16::
ReadBitsFromMixer
(
    BYTE Reg,
    BYTE Bits,
    BYTE Shift
)
{
    BYTE data = AdapterCommon->MixerRegRead(Reg);

    return( data >> Shift) & ThisManyOnes(Bits);
}

/*****************************************************************************
 * CMiniportTopologySB16::WriteBitsToMixer()
 *****************************************************************************
 * Writes specified bits to a mixer register.
 */
void
CMiniportTopologySB16::
WriteBitsToMixer
(
    BYTE Reg,
    BYTE Bits,
    BYTE Shift,
    BYTE Value
)
{
    BYTE mask = ThisManyOnes(Bits) << Shift;
    BYTE data = AdapterCommon->MixerRegRead(Reg);

    if(Reg < DSP_MIX_MAXREGS)
    {
        AdapterCommon->MixerRegWrite( Reg,
                                      (data & ~mask) | ( (Value << Shift) & mask));
    }
}

#ifdef EVENT_SUPPORT
/*****************************************************************************
 * CMiniportTopologySB16::EventHandler
 *****************************************************************************
 * This is the generic event handler.
 */
NTSTATUS CMiniportTopologySB16::EventHandler
(
    IN      PPCEVENT_REQUEST      EventRequest
)
{
    ASSERT(EventRequest);

    _DbgPrintF (DEBUGLVL_VERBOSE, ("CMiniportTopologyICH::EventHandler"));

    // The major target is the object pointer to the topology miniport.
    CMiniportTopologySB16 *that =
        (CMiniportTopologySB16 *)(PMINIPORTTOPOLOGY(EventRequest->MajorTarget));

    ASSERT (that);

    // Validate the node.
    if (EventRequest->Node != LINEOUT_VOL)
        return STATUS_INVALID_PARAMETER;

    // What is to do?
    switch (EventRequest->Verb)
    {
        // Do we support event handling?!?
        case PCEVENT_VERB_SUPPORT:
            _DbgPrintF (DEBUGLVL_VERBOSE, ("BasicSupport Query for Event."));
            break;

        // We should add the event now!
        case PCEVENT_VERB_ADD:
            _DbgPrintF (DEBUGLVL_VERBOSE, ("Adding Event."));

            // If we have the interface and EventEntry is defined ...
            if ((EventRequest->EventEntry) && (that->PortEvents))
            {
                that->PortEvents->AddEventToEventList (EventRequest->EventEntry);
            }
            else
            {
                return STATUS_UNSUCCESSFUL;
            }
            break;

        case PCEVENT_VERB_REMOVE:
            // We cannot remove the event but we can stop generating the
            // events. However, it also doesn't hurt to always generate them ...
            _DbgPrintF (DEBUGLVL_VERBOSE, ("Removing Event."));
            break;

        default:
            return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportTopologySB16::ServiceEvent()
 *****************************************************************************
 * This routine is called by the ISR to handle the event (volume) interrupt.
 */
STDMETHODIMP_(void) CMiniportTopologySB16::ServiceEvent (void)
{
    //
    // Generate an event for the master volume (as an example)
    //
    if (PortEvents)
    {
        PortEvents->GenerateEventList (NULL, KSEVENT_CONTROL_CHANGE,
                                         FALSE, ULONG(-1), TRUE,
                                         LINEOUT_VOL);
    }
}
#endif  // EVENT_SUPPORT



=== sb16/mintopo.h ===
/*****************************************************************************
 * mintopo.h - SB16 topology miniport private definitions
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _SB16TOPO_PRIVATE_H_
#define _SB16TOPO_PRIVATE_H_

#include "common.h"


/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportTopologySB16
 *****************************************************************************
 * SB16 topology miniport.  This object is associated with the device and is
 * created when the device is started.  The class inherits IMiniportTopology
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportTopologySB16 
:   public IMiniportTopology, 
    public CUnknown
{
private:
    PADAPTERCOMMON      AdapterCommon;      // Adapter common object.
#ifdef EVENT_SUPPORT
    PPORTEVENTS         PortEvents;
#endif

    /*************************************************************************
     * CMiniportTopologySB16 methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     */
    NTSTATUS ProcessResources
    (
        IN      PRESOURCELIST   ResourceList
    );
    BYTE ReadBitsFromMixer
    (
        BYTE Reg,
        BYTE Bits,
        BYTE Shift
    );
    void WriteBitsToMixer
    (
        BYTE Reg,
        BYTE Bits,
        BYTE Shift,
        BYTE Value
    );

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportTopologySB16);

    ~CMiniportTopologySB16();

    /*************************************************************************
     * IMiniport methods
     */
    STDMETHODIMP 
    GetDescription
    (   OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );
    STDMETHODIMP 
    DataRangeIntersection
    (   IN      ULONG           PinId
    ,   IN      PKSDATARANGE    DataRange
    ,   IN      PKSDATARANGE    MatchingDataRange
    ,   IN      ULONG           OutputBufferLength
    ,   OUT     PVOID           ResultantFormat     OPTIONAL
    ,   OUT     PULONG          ResultantFormatLength
    )
    {
        return STATUS_NOT_IMPLEMENTED;
    }

    /*************************************************************************
     * IMiniportTopology methods
     */
    STDMETHODIMP Init
    (
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTTOPOLOGY   Port
    );

    /*************************************************************************
     * ITopoMiniportSB16 methods
     */
    STDMETHODIMP_(void) ServiceEvent (void);

    /*************************************************************************
     * Friends
     */
    friend
    NTSTATUS
    PropertyHandler_OnOff
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );
    friend
    NTSTATUS
    PropertyHandler_Level
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );
    friend
    NTSTATUS
    PropertyHandler_SuperMixCaps
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );
    friend
    NTSTATUS
    PropertyHandler_SuperMixTable
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );
    friend
    NTSTATUS
    PropertyHandler_CpuResources
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );
    static
    NTSTATUS
    EventHandler
    (
        IN      PPCEVENT_REQUEST      EventRequest
    );
};

#include "tables.h"

#endif


=== sb16/minwave.cpp ===
/*****************************************************************************
 * miniport.cpp - SB16 wave miniport implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#include "minwave.h"

#define STR_MODULENAME "sb16wave: "



#pragma code_seg("PAGE")

/*****************************************************************************
 * CreateMiniportWaveCyclicSB16()
 *****************************************************************************
 * Creates a cyclic wave miniport object for the SB16 adapter.  This uses a
 * macro from STDUNK.H to do all the work.
 */
NTSTATUS
CreateMiniportWaveCyclicSB16
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportWaveCyclicSB16,Unknown,UnknownOuter,PoolType);
}

/*****************************************************************************
 * MapUsingTable()
 *****************************************************************************
 * Performs a table-based mapping, returning the table index of the indicated
 * value.  -1 is returned if the value is not found.
 */
int
MapUsingTable
(
    IN      ULONG   Value,
    IN      PULONG  Map,
    IN      ULONG   MapSize
)
{
    PAGED_CODE();

    ASSERT(Map);

    for (int result = 0; result < int(MapSize); result++)
    {
        if (*Map++ == Value)
        {
            return result;
        }
    }

    return -1;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::ConfigureDevice()
 *****************************************************************************
 * Configures the hardware to use the indicated interrupt and DMA channels.
 * Returns FALSE iff the configuration is invalid.
 */
BOOLEAN
CMiniportWaveCyclicSB16::
ConfigureDevice
(
    IN      ULONG   Interrupt,
    IN      ULONG   Dma8Bit,
    IN      ULONG   Dma16Bit
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::ConfigureDevice]"));

    //
    // Tables mapping DMA and IRQ values to register bit offsets.
    //
    static ULONG validDma[] = { 0, 1, ULONG(-1), 3, ULONG(-1), 5, 6, 7 } ;
    static ULONG validIrq[] = { 9, 5, 7, 10 } ;

    //
    // Make sure we are using the right DMA channels.
    //
    if (Dma8Bit > 3)
    {
        return FALSE;
    }
    if (Dma16Bit < 5)
    {
        return FALSE;
    }

    //
    // Generate the register value for interrupts.
    //
    int bit = MapUsingTable(Interrupt,validIrq,SIZEOF_ARRAY(validIrq));
    if (bit == -1)
    {
        return FALSE;
    }

    BYTE irqConfig = BYTE(1 << bit);

    //
    // Generate the register value for DMA.
    //
    bit = MapUsingTable(Dma8Bit,validDma,SIZEOF_ARRAY(validDma));
    if (bit == -1)
    {
        return FALSE;
    }

    BYTE dmaConfig = BYTE(1 << bit);

    if (Dma16Bit != ULONG(-1))
    {
        bit = MapUsingTable(Dma16Bit,validDma,SIZEOF_ARRAY(validDma));
        if (bit == -1)
        {
            return FALSE;
        }

        dmaConfig |= BYTE(1 << bit);
    }

    //
    // Inform the hardware.
    //
    AdapterCommon->MixerRegWrite(DSP_MIX_IRQCONFIG,irqConfig);
    AdapterCommon->MixerRegWrite(DSP_MIX_DMACONFIG,dmaConfig);

    return TRUE;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::ProcessResources()
 *****************************************************************************
 * Processes the resource list, setting up helper objects accordingly.
 */
NTSTATUS
CMiniportWaveCyclicSB16::
ProcessResources
(
    IN      PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();

    ASSERT(ResourceList);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::ProcessResources]"));

    ULONG   intNumber   = ULONG(-1);
    ULONG   dma8Bit     = ULONG(-1);
    ULONG   dma16Bit    = ULONG(-1);

    //
    // Get counts for the types of resources.
    //
    ULONG   countIO     = ResourceList->NumberOfPorts();
    ULONG   countIRQ    = ResourceList->NumberOfInterrupts();
    ULONG   countDMA    = ResourceList->NumberOfDmas();

#if (DBG)
    _DbgPrintF(DEBUGLVL_VERBOSE,("Starting SB16 wave on IRQ 0x%X",
        ResourceList->FindUntranslatedInterrupt(0)->u.Interrupt.Level) );

    _DbgPrintF(DEBUGLVL_VERBOSE,("Starting SB16 wave on Port 0x%X",
        ResourceList->FindTranslatedPort(0)->u.Port.Start.LowPart) );

    for (ULONG i = 0; i < countDMA; i++)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Starting SB16 wave on DMA 0x%X",
            ResourceList->FindUntranslatedDma(i)->u.Dma.Channel) );
    }
#endif

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make sure we have the expected number of resources.
    //
    if  (   (countIO != 1)
        ||  (countIRQ < 1)
        ||  (countDMA < 1)
        )
    {
        _DbgPrintF(DEBUGLVL_TERSE,("unknown configuraton; check your code!"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Instantiate a DMA channel for 8-bit transfers.
        //
        ntStatus =
            Port->NewSlaveDmaChannel
            (
                &DmaChannel8,
                NULL,
                ResourceList,
                0,
                MAXLEN_DMA_BUFFER,
                FALSE,      // DemandMode
                Compatible
            );

        //
        // Allocate the buffer for 8-bit transfers.
        //
        if (NT_SUCCESS(ntStatus))
        {
            ULONG  lDMABufferLength = MAXLEN_DMA_BUFFER;
            
            do {
              ntStatus = DmaChannel8->AllocateBuffer(lDMABufferLength,NULL);
              lDMABufferLength >>= 1;
            } while (!NT_SUCCESS(ntStatus) && (lDMABufferLength > (PAGE_SIZE / 2)));
        }

        if (NT_SUCCESS(ntStatus))
        {
            dma8Bit = ResourceList->FindUntranslatedDma(0)->u.Dma.Channel;

            if (countDMA > 1)
            {
                //
                // Instantiate a DMA channel for 16-bit transfers.
                //
                ntStatus =
                    Port->NewSlaveDmaChannel
                    (
                        &DmaChannel16,
                        NULL,
                        ResourceList,
                        1,
                        MAXLEN_DMA_BUFFER,
                        FALSE,
                        Compatible
                    );

                //
                // Allocate the buffer for 16-bit transfers.
                //
                if (NT_SUCCESS(ntStatus))
                {
                    ULONG  lDMABufferLength = MAXLEN_DMA_BUFFER;
                     
                    do {
                        ntStatus = DmaChannel16->AllocateBuffer(lDMABufferLength,NULL);
                        lDMABufferLength >>= 1;
                    } while (!NT_SUCCESS(ntStatus) && (lDMABufferLength > (PAGE_SIZE / 2)));
                }

                if (NT_SUCCESS(ntStatus))
                {
                    dma16Bit =
                        ResourceList->FindUntranslatedDma(1)->u.Dma.Channel;
                }
            }

            if (NT_SUCCESS(ntStatus))
            {
                //
                // Get the interrupt number and configure the device.
                //
                intNumber =
                    ResourceList->
                        FindUntranslatedInterrupt(0)->u.Interrupt.Level;

                if  (!  ConfigureDevice(intNumber,dma8Bit,dma16Bit))
                {
                    _DbgPrintF(DEBUGLVL_TERSE,("ConfigureDevice Failure"));
                    ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
                }
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE,("NewSlaveDmaChannel 2 Failure %X", ntStatus ));
            }
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewSlaveDmaChannel 1 Failure %X", ntStatus ));
        }
    }

    //
    // Release instantiated objects in case of failure.
    //
    if (! NT_SUCCESS(ntStatus))
    {
        if (DmaChannel8)
        {
            DmaChannel8->Release();
            DmaChannel8 = NULL;
        }
        if (DmaChannel16)
        {
            DmaChannel16->Release();
            DmaChannel16 = NULL;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::ValidateFormat()
 *****************************************************************************
 * Validates a wave format.
 */
NTSTATUS
CMiniportWaveCyclicSB16::
ValidateFormat
(
    IN      PKSDATAFORMAT   Format
)
{
    PAGED_CODE();

    ASSERT(Format);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::ValidateFormat]"));

    NTSTATUS ntStatus;

    //
    // A WAVEFORMATEX structure should appear after the generic KSDATAFORMAT
    // if the GUIDs turn out as we expect.
    //
    PWAVEFORMATEX waveFormat = PWAVEFORMATEX(Format + 1);

    //
    // KSDATAFORMAT contains three GUIDs to support extensible format.  The
    // first two GUIDs identify the type of data.  The third indicates the
    // type of specifier used to indicate format specifics.  We are only
    // supporting PCM audio formats that use WAVEFORMATEX.
    //
    if  (   (Format->FormatSize >= sizeof(KSDATAFORMAT_WAVEFORMATEX))
        &&  IsEqualGUIDAligned(Format->MajorFormat,KSDATAFORMAT_TYPE_AUDIO)
        &&  IsEqualGUIDAligned(Format->SubFormat,KSDATAFORMAT_SUBTYPE_PCM)
        &&  IsEqualGUIDAligned
            (
                Format->Specifier,
                KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
            )
        &&  (waveFormat->wFormatTag == WAVE_FORMAT_PCM)
        &&  (   (waveFormat->wBitsPerSample == 8)
            ||  (waveFormat->wBitsPerSample == 16)
            )
        &&  (   (waveFormat->nChannels == 1)
            ||  (waveFormat->nChannels == 2)
            )
        &&  (   (waveFormat->nSamplesPerSec >= 5000)
            &&  (waveFormat->nSamplesPerSec <= 44100)
            )
        )
    {
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CMiniportWaveCyclicSB16::
NonDelegatingQueryInterface
(
    IN      REFIID  Interface,
    OUT     PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::NonDelegatingQueryInterface]"));

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportWaveCyclic))
    {
        *Object = PVOID(PMINIPORTWAVECYCLIC(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::~CMiniportWaveCyclicSB16()
 *****************************************************************************
 * Destructor.
 */
CMiniportWaveCyclicSB16::
~CMiniportWaveCyclicSB16
(   void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::~CMiniportWaveCyclicSB16]"));

    if (AdapterCommon)
    {
        AdapterCommon->SetWaveMiniport (NULL);
        AdapterCommon->Release();
        AdapterCommon = NULL;
    }
    if (Port)
    {
        Port->Release();
        Port = NULL;
    }
    if (DmaChannel8)
    {
        DmaChannel8->Release();
        DmaChannel8 = NULL;
    }
    if (DmaChannel16)
    {
        DmaChannel16->Release();
        DmaChannel16 = NULL;
    }
    if (ServiceGroup)
    {
        ServiceGroup->Release();
        ServiceGroup = NULL;
    }
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::Init()
 *****************************************************************************
 * Initializes a the miniport.
 */
STDMETHODIMP
CMiniportWaveCyclicSB16::
Init
(
    IN      PUNKNOWN        UnknownAdapter,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTWAVECYCLIC Port_
)
{
    PAGED_CODE();

    ASSERT(UnknownAdapter);
    ASSERT(ResourceList);
    ASSERT(Port_);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::init]"));

    //
    // AddRef() is required because we are keeping this pointer.
    //
    Port = Port_;
    Port->AddRef();

    //
    // We want the IAdapterCommon interface on the adapter common object,
    // which is given to us as a IUnknown.  The QueryInterface call gives us
    // an AddRefed pointer to the interface we want.
    //
    NTSTATUS ntStatus =
        UnknownAdapter->QueryInterface
        (
            IID_IAdapterCommon,
            (PVOID *) &AdapterCommon
        );

    //
    // We need a service group for notifications.  We will bind all the
    // streams that are created to this single service group.  All interrupt
    // notifications ask for service on this group, so all streams will get
    // serviced.  The PcNewServiceGroup() call returns an AddRefed pointer.
    // The adapter needs a copy of the service group since it is doing the
    // ISR.
    //
    if (NT_SUCCESS(ntStatus))
    {
        KeInitializeMutex(&SampleRateSync,1);
        ntStatus = PcNewServiceGroup(&ServiceGroup,NULL);
    }

    if (NT_SUCCESS(ntStatus))
    {
        AdapterCommon->SetWaveMiniport ((PWAVEMINIPORTSB16)this);
        ntStatus = ProcessResources(ResourceList);
    }

    if( !NT_SUCCESS(ntStatus) )
    {
        //
        // clean up our mess
        //

        // clean up AdapterCommon
        if( AdapterCommon )
        {
            // clean up the service group
            if( ServiceGroup )
            {
                ServiceGroup->Release();
                ServiceGroup = NULL;
            }

            AdapterCommon->Release();
            AdapterCommon = NULL;
        }

        AdapterCommon->SetWaveMiniport(NULL);
        
        // release the port
        Port->Release();
        Port = NULL;
    }

    return ntStatus;
}

/*****************************************************************************
 * PinDataRangesStream
 *****************************************************************************
 * Structures indicating range of valid format values for streaming pins.
 */
static
KSDATARANGE_AUDIO PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        2,      // Max number of channels.
        8,      // Minimum number of bits per sample.
        16,     // Maximum number of bits per channel.
        5000,   // Minimum rate.
        44100   // Maximum rate.
    }
};

/*****************************************************************************
 * PinDataRangePointersStream
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for streaming pins.
 */
static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

/*****************************************************************************
 * PinDataRangesBridge
 *****************************************************************************
 * Structures indicating range of valid format values for bridge pins.
 */
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

/*****************************************************************************
 * PinDataRangePointersBridge
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for bridge pins.
 */
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

/*****************************************************************************
 * MiniportPins
 *****************************************************************************
 * List of pins.
 */
static
PCPIN_DESCRIPTOR 
MiniportPins[] =
{
    // Wave In Streaming Pin (Capture)
    {
        1,1,0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_SINK,
            (GUID *) &PINNAME_CAPTURE,
            &KSAUDFNAME_RECORDING_CONTROL,  // this name shows up as the recording panel name in SoundVol.
            0
        }
    },
    // Wave In Bridge Pin (Capture - From Topology)
    {
        0,0,0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_NONE,
            (GUID *) &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
    // Wave Out Streaming Pin (Renderer)
    {
        1,1,0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SINK,
            (GUID *) &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
    // Wave Out Bridge Pin (Renderer)
    {
        0,0,0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_NONE,
            (GUID *) &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    }
};

/*****************************************************************************
 * TopologyNodes
 *****************************************************************************
 * List of nodes.
 */
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_ADC,        // Type
        NULL                    // Name
    },
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_DAC,        // Type
        NULL                    // Name
    }
};

/*****************************************************************************
 * MiniportConnections
 *****************************************************************************
 * List of connections.
 */
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    { PCFILTER_NODE,  1,  0,                1 },    // Bridge in to ADC.
    { 0,              0,  PCFILTER_NODE,    0 },    // ADC to stream pin (capture).
    { PCFILTER_NODE,  2,  1,                1 },    // Stream in to DAC.
    { 1,              0,  PCFILTER_NODE,    3 }     // DAC to Bridge.
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport description.
 */
static
PCFILTER_DESCRIPTOR 
MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories
};

/*****************************************************************************
 * CMiniportWaveCyclicSB16::GetDescription()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP
CMiniportWaveCyclicSB16::
GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::GetDescription]"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::DataRangeIntersection()
 *****************************************************************************
 * Tests a data range intersection.
 */
STDMETHODIMP 
CMiniportWaveCyclicSB16::
DataRangeIntersection
(   
    IN      ULONG           PinId,
    IN      PKSDATARANGE    ClientDataRange,
    IN      PKSDATARANGE    MyDataRange,
    IN      ULONG           OutputBufferLength,
    OUT     PVOID           ResultantFormat,
    OUT     PULONG          ResultantFormatLength
)
{
    BOOLEAN                         DigitalAudio;
    NTSTATUS                        Status;
    ULONG                           RequiredSize;
    ULONG                           SampleFrequency;
    USHORT                          BitsPerSample;
    
    //
    // Let's do the complete work here.
    //
    if (!IsEqualGUIDAligned(ClientDataRange->Specifier,KSDATAFORMAT_SPECIFIER_NONE)) 
    {
        //
        // The miniport did not resolve this format.  If the dataformat
        // is not PCM audio and requires a specifier, bail out.
        //
        if ( !IsEqualGUIDAligned(ClientDataRange->MajorFormat, KSDATAFORMAT_TYPE_AUDIO ) 
          || !IsEqualGUIDAligned(ClientDataRange->SubFormat, KSDATAFORMAT_SUBTYPE_PCM )) 
        {
            return STATUS_INVALID_PARAMETER;
        }
        DigitalAudio = TRUE;
        
        //
        // weird enough, the specifier here does not define the format of ClientDataRange
        // but the format that is expected to be returned in ResultantFormat.
        //
        if (IsEqualGUIDAligned(ClientDataRange->Specifier,KSDATAFORMAT_SPECIFIER_DSOUND)) 
        {
            RequiredSize = sizeof(KSDATAFORMAT_DSOUND);
        } 
        else 
        {
            RequiredSize = sizeof(KSDATAFORMAT_WAVEFORMATEX);
        }            
    } 
    else 
    {
        DigitalAudio = FALSE;
        RequiredSize = sizeof(KSDATAFORMAT);
    }
            
    //
    // Validate return buffer size, if the request is only for the
    // size of the resultant structure, return it now.
    //
    if (!OutputBufferLength) 
    {
        *ResultantFormatLength = RequiredSize;
        return STATUS_BUFFER_OVERFLOW;
    } 
    else if (OutputBufferLength < RequiredSize) 
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    // There was a specifier ...
    if (DigitalAudio) 
    {     
        PKSDATARANGE_AUDIO  AudioRange;
        PWAVEFORMATEX       WaveFormatEx;
        
        AudioRange = (PKSDATARANGE_AUDIO) MyDataRange;
        
        // Fill the structure
        if (IsEqualGUIDAligned(ClientDataRange->Specifier,KSDATAFORMAT_SPECIFIER_DSOUND)) 
        {
            PKSDATAFORMAT_DSOUND    DSoundFormat;
            
            DSoundFormat = (PKSDATAFORMAT_DSOUND) ResultantFormat;
            
            _DbgPrintF(DEBUGLVL_VERBOSE,("returning KSDATAFORMAT_DSOUND format intersection"));
            
            DSoundFormat->BufferDesc.Flags = 0 ;
            DSoundFormat->BufferDesc.Control = 0 ;
            DSoundFormat->DataFormat = *ClientDataRange;
            DSoundFormat->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_DSOUND;
            DSoundFormat->DataFormat.FormatSize = RequiredSize;
            WaveFormatEx = &DSoundFormat->BufferDesc.WaveFormatEx;
            *ResultantFormatLength = RequiredSize;
        } 
        else 
        {
            PKSDATAFORMAT_WAVEFORMATEX  WaveFormat;
        
            WaveFormat = (PKSDATAFORMAT_WAVEFORMATEX) ResultantFormat;
            
            _DbgPrintF(DEBUGLVL_VERBOSE,("returning KSDATAFORMAT_WAVEFORMATEX format intersection") );
        
            WaveFormat->DataFormat = *ClientDataRange;
            WaveFormat->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
            WaveFormat->DataFormat.FormatSize = RequiredSize;
            WaveFormatEx = &WaveFormat->WaveFormatEx;
            *ResultantFormatLength = RequiredSize;
        }
        
        //
        // Return a format that intersects the given audio range, 
        // using our maximum support as the "best" format.
        // 
        
        WaveFormatEx->wFormatTag = WAVE_FORMAT_PCM;
        WaveFormatEx->nChannels = 
            (USHORT) min( AudioRange->MaximumChannels, 
                          ((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumChannels );
        
        //
        // Check if the pin is still free
        //
        if (!PinId)
        {
            if (AllocatedCapture)
            {
                return STATUS_NO_MATCH;
            }
        }
        else
        {
            if (AllocatedRender)
            {
                return STATUS_NO_MATCH;
            }
        }

        //
        // Check if one pin is in use -> use same sample frequency.
        //
        if (AllocatedCapture || AllocatedRender)
        {
            SampleFrequency = SamplingFrequency;
            if ( (SampleFrequency > ((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumSampleFrequency) 
              || (SampleFrequency < ((PKSDATARANGE_AUDIO) ClientDataRange)->MinimumSampleFrequency))
            {
                return STATUS_NO_MATCH;
            }
        }
        else
        {
            SampleFrequency = 
                min( AudioRange->MaximumSampleFrequency,
                     ((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumSampleFrequency );

        }

        WaveFormatEx->nSamplesPerSec = SampleFrequency;

        //
        // Check if one pin is in use -> use other bits per sample.
        //
        if (AllocatedCapture || AllocatedRender)
        {
            if (Allocated8Bit)
            {
                BitsPerSample = 16;
            }
            else
            {
                BitsPerSample = 8;
            }

            if ((BitsPerSample > ((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumBitsPerSample) ||
                (BitsPerSample < ((PKSDATARANGE_AUDIO) ClientDataRange)->MinimumBitsPerSample))
            {
                return STATUS_NO_MATCH;
            }
        }
        else
        {
            BitsPerSample = 
                (USHORT) min( AudioRange->MaximumBitsPerSample,
                              ((PKSDATARANGE_AUDIO) ClientDataRange)->MaximumBitsPerSample );
        }

        WaveFormatEx->wBitsPerSample = BitsPerSample;
        WaveFormatEx->nBlockAlign = (WaveFormatEx->wBitsPerSample * WaveFormatEx->nChannels) / 8;
        WaveFormatEx->nAvgBytesPerSec = (WaveFormatEx->nSamplesPerSec * WaveFormatEx->nBlockAlign);
        WaveFormatEx->cbSize = 0;
        ((PKSDATAFORMAT) ResultantFormat)->SampleSize = WaveFormatEx->nBlockAlign;
        
        _DbgPrintF(DEBUGLVL_VERBOSE,("Channels = %d", WaveFormatEx->nChannels) );
        _DbgPrintF(DEBUGLVL_VERBOSE,("Samples/sec = %d", WaveFormatEx->nSamplesPerSec) );
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bits/sample = %d", WaveFormatEx->wBitsPerSample) );
        
    } 
    else 
    {    
        // There was no specifier. Return only the KSDATAFORMAT structure.
        //
        // Copy the data format structure.
        //
        _DbgPrintF(DEBUGLVL_VERBOSE,("returning default format intersection") );
            
        RtlCopyMemory(ResultantFormat, ClientDataRange, sizeof( KSDATAFORMAT ) );
        *ResultantFormatLength = sizeof( KSDATAFORMAT );
    }
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportWaveCyclicSB16::NewStream()
 *****************************************************************************
 * Creates a new stream.  This function is called when a streaming pin is
 * created.
 */
STDMETHODIMP
CMiniportWaveCyclicSB16::
NewStream
(
    OUT     PMINIPORTWAVECYCLICSTREAM * OutStream,
    IN      PUNKNOWN                    OuterUnknown,
    IN      POOL_TYPE                   PoolType,
    IN      ULONG                       Channel,
    IN      BOOLEAN                     Capture,
    IN      PKSDATAFORMAT               DataFormat,
    OUT     PDMACHANNEL *               OutDmaChannel,
    OUT     PSERVICEGROUP *             OutServiceGroup
)
{
    PAGED_CODE();

    ASSERT(OutStream);
    ASSERT(DataFormat);
    ASSERT(OutDmaChannel);
    ASSERT(OutServiceGroup);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicSB16::NewStream]"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make sure the hardware is not already in use.
    //
    if (Capture)
    {
        if (AllocatedCapture)
        {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
    }
    else
    {
        if (AllocatedRender)
        {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    //
    // Determine if the format is valid.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ValidateFormat(DataFormat);
    }

    if(NT_SUCCESS(ntStatus))
    {
        // if we're trying to start a full-duplex stream.
        if(AllocatedCapture || AllocatedRender)
        {
            // make sure the requested sampling rate is the
            // same as the currently running one...
            PWAVEFORMATEX waveFormat = PWAVEFORMATEX(DataFormat + 1);
            if( SamplingFrequency != waveFormat->nSamplesPerSec )
            {
                // Bad format....
                ntStatus = STATUS_INVALID_PARAMETER;
            }
        }
    }

    PDMACHANNELSLAVE    dmaChannel = NULL;
    PWAVEFORMATEX       waveFormat = PWAVEFORMATEX(DataFormat + 1);

    //
    // Get the required DMA channel if it's not already in use.
    //
    if (NT_SUCCESS(ntStatus))
    {
        if (waveFormat->wBitsPerSample == 8)
        {
            if (! Allocated8Bit)
            {
                dmaChannel = DmaChannel8;
            }
        }
        else
        {
            if (! Allocated16Bit)
            {
                dmaChannel = DmaChannel16;
            }
        }
    }

    if (! dmaChannel)
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
    {
        //
        // Instantiate a stream.
        //
        CMiniportWaveCyclicStreamSB16 *stream =
            new(PoolType) CMiniportWaveCyclicStreamSB16(OuterUnknown);

        if (stream)
        {
            stream->AddRef();

            ntStatus =
                stream->Init
                (
                    this,
                    Channel,
                    Capture,
                    DataFormat,
                    dmaChannel
                );

            if (NT_SUCCESS(ntStatus))
            {
                if (Capture)
                {
                    AllocatedCapture = TRUE;
                }
                else
                {
                    AllocatedRender = TRUE;
                }

                if (waveFormat->wBitsPerSample == 8)
                {
                    Allocated8Bit = TRUE;
                }
                else
                {
                    Allocated16Bit = TRUE;
                }

                *OutStream = PMINIPORTWAVECYCLICSTREAM(stream);
                stream->AddRef();

                *OutDmaChannel = dmaChannel;
                dmaChannel->AddRef();

                *OutServiceGroup = ServiceGroup;
                ServiceGroup->AddRef();

                //
                // The stream, the DMA channel, and the service group have
                // references now for the caller.  The caller expects these
                // references to be there.
                //
            }

            //
            // This is our private reference to the stream.  The caller has
            // its own, so we can release in any case.
            //
            stream->Release();
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CMiniportWaveCyclicStreamSB16::
NonDelegatingQueryInterface
(
    IN      REFIID  Interface,
    OUT     PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::NonDelegatingQueryInterface]"));

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportWaveCyclicStream))
    {
        *Object = PVOID(PMINIPORTWAVECYCLICSTREAM(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::~CMiniportWaveCyclicStreamSB16()
 *****************************************************************************
 * Destructor.
 */
CMiniportWaveCyclicStreamSB16::
~CMiniportWaveCyclicStreamSB16
(   void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::~CMiniportWaveCyclicStreamSB16]"));

    if (DmaChannel)
    {
        DmaChannel->Release();
    }

    if (Miniport)
    {
        //
        // Clear allocation flags in the miniport.
        //
        if (Capture)
        {
            Miniport->AllocatedCapture = FALSE;
        }
        else
        {
            Miniport->AllocatedRender = FALSE;
        }

        if (Format16Bit)
        {
            Miniport->Allocated16Bit = FALSE;
        }
        else
        {
            Miniport->Allocated8Bit = FALSE;
        }

        Miniport->AdapterCommon->SaveMixerSettingsToRegistry();
        Miniport->Release();
    }
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::Init()
 *****************************************************************************
 * Initializes a stream.
 */
NTSTATUS
CMiniportWaveCyclicStreamSB16::
Init
(
    IN      CMiniportWaveCyclicSB16 *   Miniport_,
    IN      ULONG                       Channel_,
    IN      BOOLEAN                     Capture_,
    IN      PKSDATAFORMAT               DataFormat,
    IN      PDMACHANNELSLAVE            DmaChannel_
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::Init]"));

    ASSERT(Miniport_);
    ASSERT(DataFormat);
    ASSERT(NT_SUCCESS(Miniport_->ValidateFormat(DataFormat)));
    ASSERT(DmaChannel_);

    PWAVEFORMATEX waveFormat = PWAVEFORMATEX(DataFormat + 1);

    //
    // We must add references because the caller will not do it for us.
    //
    Miniport = Miniport_;
    Miniport->AddRef();

    DmaChannel = DmaChannel_;
    DmaChannel->AddRef();

    Channel         = Channel_;
    Capture         = Capture_;
    FormatStereo    = (waveFormat->nChannels == 2);
    Format16Bit     = (waveFormat->wBitsPerSample == 16);
    State           = KSSTATE_STOP;

    RestoreInputMixer = FALSE;

    KeWaitForSingleObject
    (
        &Miniport->SampleRateSync,
        Executive,
        KernelMode,
        FALSE,
        NULL
    );
    Miniport->SamplingFrequency = waveFormat->nSamplesPerSec;
    KeReleaseMutex(&Miniport->SampleRateSync,FALSE);
    
    SetFormat( DataFormat );

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::SetNotificationFreq()
 *****************************************************************************
 * Sets the notification frequency.
 */
STDMETHODIMP_(ULONG)
CMiniportWaveCyclicStreamSB16::
SetNotificationFreq
(
    IN      ULONG   Interval,
    OUT     PULONG  FramingSize    
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::SetNotificationFreq]"));

    Miniport->NotificationInterval = Interval;
    //
    //  This value needs to be sample block aligned for DMA to work correctly.
    //
    *FramingSize = 
        (1 << (FormatStereo + Format16Bit)) * 
            (Miniport->SamplingFrequency * Interval / 1000);

    return Miniport->NotificationInterval;
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::SetFormat()
 *****************************************************************************
 * Sets the wave format.
 */
STDMETHODIMP
CMiniportWaveCyclicStreamSB16::
SetFormat
(
    IN      PKSDATAFORMAT   Format
)
{
    PAGED_CODE();

    ASSERT(Format);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::SetFormat]"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    if(State != KSSTATE_RUN)
    {
        ntStatus = Miniport->ValidateFormat(Format);
    
        PWAVEFORMATEX waveFormat = PWAVEFORMATEX(Format + 1);

        KeWaitForSingleObject
        (
            &Miniport->SampleRateSync,
            Executive,
            KernelMode,
            FALSE,
            NULL
        );
    
        // check for full-duplex stuff
        if( NT_SUCCESS(ntStatus)
            && Miniport->AllocatedCapture
            && Miniport->AllocatedRender
        )
        {
            // no new formats.... bad...
            if( Miniport->SamplingFrequency != waveFormat->nSamplesPerSec )
            {
                // Bad format....
                ntStatus = STATUS_INVALID_PARAMETER;
            }
        }
    
        // TODO:  Validate sample size.
    
        if (NT_SUCCESS(ntStatus))
        {
            PWAVEFORMATEX waveFormat = PWAVEFORMATEX(Format + 1);

            Miniport->SamplingFrequency = waveFormat->nSamplesPerSec;
    
            BYTE command =
                (   Capture
                ?   DSP_CMD_SETADCRATE
                :   DSP_CMD_SETDACRATE
                );
    
            Miniport->AdapterCommon->WriteController
            (
                command
            );
    
            Miniport->AdapterCommon->WriteController
            (
                (BYTE)(waveFormat->nSamplesPerSec >> 8)
            );
    
            Miniport->AdapterCommon->WriteController
            (
                (BYTE) waveFormat->nSamplesPerSec
            );

            _DbgPrintF(DEBUGLVL_VERBOSE,("  SampleRate: %d",waveFormat->nSamplesPerSec));
        }

        KeReleaseMutex(&Miniport->SampleRateSync,FALSE);
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::SetState()
 *****************************************************************************
 * Sets the state of the channel.
 */
STDMETHODIMP
CMiniportWaveCyclicStreamSB16::
SetState
(
    IN      KSSTATE     NewState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CMiniportWaveCyclicStreamSB16::SetState]"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // The acquire state is not distinguishable from the pause state for our
    // purposes.
    //
    if (NewState == KSSTATE_ACQUIRE)
    {
        NewState = KSSTATE_PAUSE;
    }

    if (State != NewState)
    {
        switch (NewState)
        {
        case KSSTATE_PAUSE:
            if (State == KSSTATE_RUN)
            {
                if (Capture)
                {
                    // restore if previously setup for mono recording
                    // (this should really be done via the topology miniport)
                    if(RestoreInputMixer)
                    {
                        Miniport->AdapterCommon->MixerRegWrite( DSP_MIX_ADCMIXIDX_L,
                                                                InputMixerLeft );
                        RestoreInputMixer = FALSE;
                    }
                }
                // TODO:  Wait for DMA to complete

                if (Format16Bit)
                {
                    Miniport->AdapterCommon->WriteController(DSP_CMD_HALTAUTODMA16);
                    // TODO:  wait...
                    Miniport->AdapterCommon->WriteController(DSP_CMD_PAUSEDMA16);
                }
                else
                {
                    Miniport->AdapterCommon->WriteController(DSP_CMD_HALTAUTODMA);
                    // TODO:  wait...
                    Miniport->AdapterCommon->WriteController(DSP_CMD_PAUSEDMA);
                }

                if ( !(Miniport->AllocatedRender &&
                       Miniport->AllocatedCapture))
                {
                    Miniport->AdapterCommon->ResetController();
                }

                Miniport->AdapterCommon->WriteController(DSP_CMD_SPKROFF);


                DmaChannel->Stop();

            }
            break;

        case KSSTATE_RUN:
            {
                BYTE mode;

                if (Capture)
                {
                    // setup for mono recording
                    // (this should really be done via the topology miniport)
                    if(! FormatStereo)
                    {
                        InputMixerLeft  = Miniport->AdapterCommon->MixerRegRead( DSP_MIX_ADCMIXIDX_L );
                        UCHAR InputMixerRight = Miniport->AdapterCommon->MixerRegRead( DSP_MIX_ADCMIXIDX_R );
                        
                        UCHAR TempMixerValue = InputMixerLeft | (InputMixerRight & 0x2A);

                        Miniport->AdapterCommon->MixerRegWrite( DSP_MIX_ADCMIXIDX_L,
                                                                TempMixerValue );
                        
                        RestoreInputMixer = TRUE;
                    }

                    //
                    // Turn on capture.
                    //
                    Miniport->AdapterCommon->WriteController(DSP_CMD_SPKROFF);

                    if (Format16Bit)
                    {
                        Miniport->AdapterCommon->WriteController(DSP_CMD_STARTADC16);
                        mode = 0x10;
                    }
                    else
                    {
                        Miniport->AdapterCommon->WriteController(DSP_CMD_STARTADC8);
                        mode = 0x00;
                    }
                }
                else
                {
                    Miniport->AdapterCommon->WriteController(DSP_CMD_SPKRON);

                    if (Format16Bit)
                    {
                        Miniport->AdapterCommon->WriteController(DSP_CMD_STARTDAC16);
                        mode = 0x10;
                    }
                    else
                    {
                        Miniport->AdapterCommon->WriteController(DSP_CMD_STARTDAC8);
                        mode = 0x00;
                    }
                }

                if (FormatStereo)
                {
                    mode |= 0x20;
                }

                //
                // Start DMA.
                //
                DmaChannel->Start(DmaChannel->BufferSize(),!Capture);

                Miniport->AdapterCommon->WriteController(mode) ;

                //
                // Calculate sample count for interrupts.
                //
                ULONG bufferSizeInFrames = DmaChannel->BufferSize();
                if( Format16Bit )
                {
                    bufferSizeInFrames /= 2;
                }
                if( FormatStereo )
                {
                    bufferSizeInFrames /= 2;
                }

                ULONG frameCount =
                    (   (   Miniport->SamplingFrequency
                        *   Miniport->NotificationInterval
                        )
                    /   1000
                    );

                if (frameCount > bufferSizeInFrames)
                {
                    frameCount = bufferSizeInFrames;
                }

                frameCount--;

                _DbgPrintF( DEBUGLVL_VERBOSE, ("Run. Setting frame count to %X",frameCount));
                Miniport->AdapterCommon->WriteController((BYTE) frameCount) ;
                Miniport->AdapterCommon->WriteController((BYTE) (frameCount >> 8));
            }
            break;

        case KSSTATE_STOP:
            break;
        }

        State = NewState;
    }

    return ntStatus;
}

#pragma code_seg()

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::GetPosition()
 *****************************************************************************
 * Gets the current position.  May be called at dispatch level.
 */
STDMETHODIMP
CMiniportWaveCyclicStreamSB16::
GetPosition
(
    OUT     PULONG  Position
)
{
    ASSERT(Position);

    ULONG transferCount = DmaChannel->TransferCount();

    if (DmaChannel && transferCount)
    {
        *Position = DmaChannel->ReadCounter();

        ASSERT(*Position <= transferCount);

        if (*Position != 0)
        {
            *Position = transferCount - *Position;
        }
    }
    else
    {
        *Position = 0;
    }

   return STATUS_SUCCESS;
}

STDMETHODIMP
CMiniportWaveCyclicStreamSB16::NormalizePhysicalPosition(
    IN OUT PLONGLONG PhysicalPosition
)

/*++

Routine Description:
    Given a physical position based on the actual number of bytes transferred,
    this function converts the position to a time-based value of 100ns units.

Arguments:
    IN OUT PLONGLONG PhysicalPosition -
        value to convert.

Return:
    STATUS_SUCCESS or an appropriate error code.

--*/

{                           
    *PhysicalPosition =
            (_100NS_UNITS_PER_SECOND / 
                (1 << (FormatStereo + Format16Bit)) * *PhysicalPosition) / 
                    Miniport->SamplingFrequency;
    return STATUS_SUCCESS;
}
    
/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::Silence()
 *****************************************************************************
 * Fills a buffer with silence.
 */
STDMETHODIMP_(void)
CMiniportWaveCyclicStreamSB16::
Silence
(
    IN      PVOID   Buffer,
    IN      ULONG   ByteCount
)
{
    RtlFillMemory(Buffer,ByteCount,Format16Bit ? 0 : 0x80);
}

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16::ServiceWaveISR()
 *****************************************************************************
 * Service the ISR - Notify the port.
 */
STDMETHODIMP_(void) CMiniportWaveCyclicSB16::ServiceWaveISR (void)
{
    if (Port && ServiceGroup)
    {
        Port->Notify (ServiceGroup);
    }
}



=== sb16/minwave.h ===
/*****************************************************************************
 * minwave.h - SB16 wave miniport private definitions
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _SB16WAVE_PRIVATE_H_
#define _SB16WAVE_PRIVATE_H_

#include "common.h"




 
/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportWaveCyclicSB16
 *****************************************************************************
 * SB16 wave miniport.  This object is associated with the device and is
 * created when the device is started.  The class inherits IMiniportWaveCyclic
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportWaveCyclicSB16
:   public IMiniportWaveCyclic,
    public CUnknown
{
private:
    PADAPTERCOMMON      AdapterCommon;              // Adapter common object.
    PPORTWAVECYCLIC     Port;                       // Callback interface.

    ULONG               NotificationInterval;       // In milliseconds.
    ULONG               SamplingFrequency;          // Frames per second.

    BOOLEAN             AllocatedCapture;           // Capture in use.
    BOOLEAN             AllocatedRender;            // Render in use.
    BOOLEAN             Allocated8Bit;              // 8-bit DMA in use.
    BOOLEAN             Allocated16Bit;             // 16-bit DMA in use.

    PDMACHANNELSLAVE    DmaChannel8;                // Abstracted channel.
    PDMACHANNELSLAVE    DmaChannel16;               // Abstracted channel.

    PSERVICEGROUP       ServiceGroup;               // For notification.
    KMUTEX              SampleRateSync;             // Sync for sample rate changes.

    /*************************************************************************
     * CMiniportWaveCyclicSB16 methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     */
    BOOLEAN ConfigureDevice
    (
        IN      ULONG   Interrupt,
        IN      ULONG   DMA8Bit,
        IN      ULONG   DMA16Bit
    );
    NTSTATUS ProcessResources
    (
        IN      PRESOURCELIST   ResourceList
    );
    NTSTATUS ValidateFormat
    (
        IN      PKSDATAFORMAT   Format
    );

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclicSB16);

    ~CMiniportWaveCyclicSB16();

    /*************************************************************************
     * This macro is from PORTCLS.H.  It lists all the interface's functions.
     */
    IMP_IMiniportWaveCyclic;

    /*************************************************************************
     * IWaveMiniportSB16 methods
     */
    STDMETHODIMP_(void) ServiceWaveISR (void);
    
    /*************************************************************************
     * Friends
     *
     * The miniport stream class is a friend because it needs to access the
     * private member variables of this class.
     */
    friend class CMiniportWaveCyclicStreamSB16;
};

/*****************************************************************************
 * CMiniportWaveCyclicStreamSB16
 *****************************************************************************
 * SB16 wave miniport stream.  This object is associated with a streaming pin
 * and is created when a pin is created on the filter.  The class inherits
 * IMiniportWaveCyclicStream so it can expose this interface and CUnknown so
 * it automatically gets reference counting and aggregation support.
 */
class CMiniportWaveCyclicStreamSB16
:   public IMiniportWaveCyclicStream,
    public CUnknown
{
private:
    CMiniportWaveCyclicSB16 *   Miniport;       // Miniport that created us.
    ULONG                       Channel;        // Index into channel list.
    BOOLEAN                     Capture;        // Capture or render.
    BOOLEAN                     Format16Bit;    // 16- or 8-bit samples.
    BOOLEAN                     FormatStereo;   // Two or one channel.
    KSSTATE                     State;          // Stop, pause, run.
    PDMACHANNELSLAVE            DmaChannel;     // DMA channel to use.
    BOOLEAN                     RestoreInputMixer;  // Restore input mixer.
    UCHAR                       InputMixerLeft; // Cache for left input mixer.

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclicStreamSB16);

    ~CMiniportWaveCyclicStreamSB16();

    /*************************************************************************
     * This macro is from PORTCLS.H.  It lists all the interface's functions.
     */
    IMP_IMiniportWaveCyclicStream;

    NTSTATUS 
    Init
    (
        IN      CMiniportWaveCyclicSB16 *   Miniport,
        IN      ULONG                       Channel,
        IN      BOOLEAN                     Capture,
        IN      PKSDATAFORMAT               DataFormat,
        OUT     PDMACHANNELSLAVE            DmaChannel
    );
};

#endif

=== sb16/mssb16.inf ===
;
; Copyright (c) 1990-2000 Microsoft Corporation.  All rights reserved.
;
; Module Name:
;    mssb16.INF
;
; Abstract:
;    INF file for installing MSSB16 Sample Driver

[Version]
Signature="$CHICAGO$"
Class=MEDIA
ClassGUID={4d36e96c-e325-11ce-bfc1-08002be10318}
provider=%MSFT%
DriverVer=08/02/1999,5.00.2089.1

;You must specify which platform is supported by each SourceDisksNames section
;Valid platform identifiers include .x86, .ia64, .alpha, .axp64
[SourceDisksNames.x86]
222=%DiskDescription%,,,

;You must also specify which platform is supported by each SourceDisksFiles section
;Valid platform identifiers include .x86, .ia64, .alpha, .axp64
[SourceDisksFiles.x86]
mssb16.sys=222

[Manufacturer]
%CLMfgName%=Creative

;;
;; Mechanism for excluding drivers from the "Add New Hardware" list.
;;
[ControlFlags]
;;ExcludeFromSelect = *CTL0001
;;ExcludeFromSelect = *CTL0031
;;ExcludeFromSelect = *CTL0041
;;ExcludeFromSelect = *CTL0042
;;ExcludeFromSelect = *CTL0043
;;ExcludeFromSelect = *CTL0044
;;ExcludeFromSelect = *CTL0045
;;ExcludeFromSelect = *CTL0046
;;ExcludeFromSelect = *CTL0047
ExcludeFromSelect = *CTL0051
ExcludeFromSelect = *CTL7FFF

;; *EXCLUDE is a made up ID to prevent rank 1 drivers from showing in list.
ExcludeFromSelect = *EXCLUDE

;; MSSB16 miniport
[Creative]
%*WDMPNPB003.DeviceDesc%=WDMPNPB003_Device, , *PNPB003
%*WDM_SB16.DeviceDesc%=WDM_SB16,            , *CTL0001
%*WDM_SB16.DeviceDesc%=WDM_SB16,            , *CTL0031
%*WDM_SB16.DeviceDesc%=WDM_SB16,            , *CTL0041
%*WDM_SB16.DeviceDesc%=WDM_SB16,            , *CTL0042
%*WDM_SB16.DeviceDesc%=WDM_SB16_FDMA,       , *CTL0043
%*WDM_SB16.DeviceDesc%=WDM_SB16,            , *CTL0044
%*WDM_SB16.DeviceDesc%=WDM_SB16,            , *CTL0045
%*WDM_SB16.DeviceDesc%=WDM_SB16,            , *CTL0046
%*WDM_SB16.DeviceDesc%=WDM_SB16,            , *CTL0047
%*CTL0051.DeviceDesc%=STUB_DEVICE,          , *CTL0051
%*CTL7FFF.DeviceDesc%=STUB_DEVICE,          , *CTL7FFF
%SBAWE_Virtual_Mpu.DeviceDesc%=STUB_DEVICE, , VIRTUAL\SBAWE-MPUEmulation

[*PNPB003.Det]
AddReg=PreCopySection

[PreCopySection]
HKR,,NoSetupUI,,1

[STUB_DEVICE]

;; All the Creative PnP IDs, except CTL0043
[WDM_SB16]
AlsoInstall=ks.registration(ks.inf),wdmaudio.registration(wdmaudio.inf)
CopyFiles=MSSB16.CopyList
AddReg=WDM_SB16.AddReg

;; CTL0043 has FDMA enabled
[WDM_SB16_FDMA]
AlsoInstall=ks.registration(ks.inf),wdmaudio.registration(wdmaudio.inf),wdmaudio.fdma(wdmaudio.inf)
CopyFiles=MSSB16.CopyList
AddReg=WDM_SB16.AddReg

;; Non PnP SB16 Device!
[WDMPNPB003_Device]
AlsoInstall=ks.registration(ks.inf),wdmaudio.registration(wdmaudio.inf)
LogConfig=SB16.LC1,SB16.LC2,SB16.LC3,SB16.LC4,SB16.LC5,SB16.LC6,SB16.LC7,SB16.LC8
CopyFiles=MSSB16.CopyList
AddReg=WDM_SB16.AddReg

[WDM_SB16.Interfaces]
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_CAPTURE%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_Topology%,WDM_SB16.Interface.Topology
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_CAPTURE%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_FMSynth%,WDM.Interface.FMSynth
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_FMSynth%,WDM.Interface.FMSynth

[WDMPNPB003_Device.Interfaces]
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_CAPTURE%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_Topology%,WDM_SB16.Interface.Topology
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_CAPTURE%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_FMSynth%,WDM.Interface.FMSynth
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_FMSynth%,WDM.Interface.FMSynth

[WDM_SB16.Interface.Wave]
AddReg=WDM_SB16.Interface.Wave.AddReg
[WDM_SB16.Interface.Wave.AddReg]
HKR,,CLSID,,%Proxy.CLSID%
HKR,,FriendlyName,,%WDM_SB16.Wave.szPname%

[WDM_SB16.Interface.Topology]
AddReg=WDM_SB16.Interface.Topo.AddReg
;; warning!! must be "Topo" because "Topology" is too long
[WDM_SB16.Interface.Topo.AddReg]
HKR,,CLSID,,%Proxy.CLSID%
HKR,,FriendlyName,,%WDM_SB16.Topology.szPname%

[WDM.Interface.UART]
AddReg=WDM.Interface.UART.AddReg
[WDM.Interface.UART.AddReg]
HKR,,CLSID,,%Proxy.CLSID%
HKR,,FriendlyName,,%WDM.UART.szPname%

[WDM.Interface.FMSynth]
AddReg=WDM.Interface.FMSynth.AddReg
[WDM.Interface.FMSynth.AddReg]
HKR,,CLSID,,%Proxy.CLSID%
HKR,,FriendlyName,,%WDM.FMSynth.szPname%

[WDM_SB16.AddReg]
HKR,,AssociatedFilters,,"wdmaud,swmidi,redbook"
HKR,,Driver,,msSB16.SYS
HKR,,NTMPDriver,,"msSB16.sys,sbemul.sys"

HKR,Drivers,SubClasses,,"wave,midi,mixer"

HKR,Drivers\wave\wdmaud.drv, Driver,,wdmaud.drv
HKR,Drivers\midi\wdmaud.drv, Driver,,wdmaud.drv
HKR,Drivers\mixer\wdmaud.drv,Driver,,wdmaud.drv

HKR,Drivers\wave\wdmaud.drv,Description,,%*WDMPNPB003.DeviceDesc%
HKR,Drivers\midi\wdmaud.drv,Description,,%WDM_MIDI%
HKR,Drivers\mixer\wdmaud.drv,Description,,%*WDMPNPB003.DeviceDesc%

[DestinationDirs]
MSSB16.CopyList      = 10,system32\drivers ; %SystemRoot%\system32\drivers

[MSSB16.CopyList]
mssb16.sys

[WDMPNPB003_Device.FactDef]
ConfigPriority=NORMAL
IOConfig=220-22F
IOConfig=330-331
IOConfig=388-38B
IRQConfig=5
DMAConfig=1
DMAConfig=5


[SB16.LC1]
ConfigPriority=NORMAL
IOConfig=220-22F , 240-24F , 260-26F , 280-28F
IRQConfig=5 , 7 , 9 , 10
DMAConfig=0 , 1 , 3
DMAConfig=5 , 6 , 7

[SB16.LC2]
ConfigPriority=NORMAL
IOConfig=220-22F , 240-24F , 260-26F , 280-28F
IRQConfig=5 , 7 , 9 , 10
DMAConfig=0 , 1 , 3

[SB16.LC3]
ConfigPriority=NORMAL
IOConfig=220-22F , 240-24F , 260-26F , 280-28F
IOConfig=388-38B
IRQConfig=5 , 7 , 9 , 10
DMAConfig=0 , 1 , 3
DMAConfig=5 , 6 , 7

[SB16.LC4]
ConfigPriority=NORMAL
IOConfig=220-22F , 240-24F , 260-26F , 280-28F
IOConfig=388-38B
IRQConfig=5 , 7 , 9 , 10
DMAConfig=0 , 1 , 3

[SB16.LC5]
ConfigPriority=NORMAL
IOConfig=220-22F , 240-24F , 260-26F , 280-28F
IOConfig=330-331, 300-301
IRQConfig=5 , 7 , 9 , 10
DMAConfig=0 , 1 , 3
DMAConfig=5 , 6 , 7

[SB16.LC6]
ConfigPriority=NORMAL
IOConfig=220-22F , 240-24F , 260-26F , 280-28F
IOConfig=330-331, 300-301
IRQConfig=5 , 7 , 9 , 10
DMAConfig=0 , 1 , 3

[SB16.LC7]
ConfigPriority=NORMAL
IOConfig=220-22F , 240-24F , 260-26F , 280-28F
IOConfig=330-331, 300-301
IOConfig=388-38B
IRQConfig=5 , 7 , 9 , 10
DMAConfig=0 , 1 , 3
DMAConfig=5 , 6 , 7

[SB16.LC8]
ConfigPriority=NORMAL
IOConfig=220-22F , 240-24F , 260-26F , 280-28F
IOConfig=330-331, 300-301
IOConfig=388-38B
IRQConfig=5 , 7 , 9 , 10
DMAConfig=0 , 1 , 3

;;**************** NT Install ****************

[STUB_DEVICE.NT]
[STUB_DEVICE.NT.SERVICES]
AddService=,0x2

[WDM_SB16.NT]
Include=ks.inf, wdmaudio.inf
Needs=KS.Registration, WDMAUDIO.Registration
CopyFiles=MSSB16.CopyList
AddReg=WDM_SB16.AddReg

[WDM_SB16.NT.Interfaces]
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_CAPTURE%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_Topology%,WDM_SB16.Interface.Topology
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_CAPTURE%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_FMSynth%,WDM.Interface.FMSynth
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_FMSynth%,WDM.Interface.FMSynth

[WDM_SB16.NT.Services]
AddService = sb16,    0x00000002, sndblst_Service_Inst

[WDM_SB16_FDMA.NT]
Include=ks.inf, wdmaudio.inf
Needs=KS.Registration, WDMAUDIO.Registration, WDMAUDIO.FDMA
CopyFiles=MSSB16.CopyList
AddReg=WDM_SB16.AddReg

[WDM_SB16_FDMA.NT.Interfaces]
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_CAPTURE%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_Topology%,WDM_SB16.Interface.Topology
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_CAPTURE%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_FMSynth%,WDM.Interface.FMSynth
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_FMSynth%,WDM.Interface.FMSynth

[WDM_SB16_FDMA.NT.Services]
AddService = sb16,    0x00000002, sndblst_Service_Inst

[WDMPNPB003_Device.NT]
Include=ks.inf, wdmaudio.inf
Needs=KS.Registration, WDMAUDIO.Registration
LogConfig=SB16.LC1,SB16.LC2,SB16.LC3,SB16.LC4,SB16.LC5,SB16.LC6,SB16.LC7,SB16.LC8
CopyFiles=MSSB16.CopyList
AddReg=WDM_SB16.AddReg

[WDMPNPB003_Device.NT.FactDef]
ConfigPriority=NORMAL
IOConfig=220-22F
IOConfig=330-331
IOConfig=388-38B
IRQConfig=5
DMAConfig=1
DMAConfig=5

[WDMPNPB003_Device.NT.Interfaces]
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_CAPTURE%,%KSNAME_Wave%,WDM_SB16.Interface.Wave
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_Topology%,WDM_SB16.Interface.Topology
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_CAPTURE%,%KSNAME_UART%,WDM.Interface.UART
AddInterface=%KSCATEGORY_AUDIO%,%KSNAME_FMSynth%,WDM.Interface.FMSynth
AddInterface=%KSCATEGORY_RENDER%,%KSNAME_FMSynth%,WDM.Interface.FMSynth

[WDMPNPB003_Device.NT.Services]
AddService = sb16,    0x00000002, sndblst_Service_Inst

[sndblst_Service_Inst]
DisplayName    = %sndblst.SvcDesc%
ServiceType    = 1                  ; SERVICE_KERNEL_DRIVER
StartType      = 3                  ; SERVICE_DEMAND_START
ErrorControl   = 1                  ; SERVICE_ERROR_NORMAL
ServiceBinary  = %10%\system32\drivers\mssb16.sys

[Strings]
MSFT="Microsoft"
CLMfgName="Creative Technology Ltd."
DiskDescription="SoundBlaster WDM Sample Driver Disk"
*WDMPNPB003.DeviceDesc="WDM Sample Driver for SB16, AWE32, or compatible"
*WDM_SB16.DeviceDesc="WDM Sample Driver for SB16, AWE32, or AWE64 PnP"
*CTL0051.DeviceDesc = "WDM Sample Driver for Creative 3D Stereo Enhancement Technology (inactive)"
*CTL7FFF.DeviceDesc = "WDM Sample Driver for Creative Plug and Play Device (Reserved) (inactive)"
SBAWE_Virtual_Mpu.DeviceDesc="WDM Sample Driver for Creative SBAWE MPU401 Emulation (inactive)"
WDM_SB16.Wave.szPname="Sound Blaster 16"
WDM_SB16.Topology.szPname="Sound Blaster 16"

MediaCategories="SYSTEM\CurrentControlSet\Control\MediaCategories"
WDM_MIDI="WDM-based Device"

Proxy.CLSID=        "{17CCA71B-ECD7-11D0-B908-00A0C9223196}"
KSCATEGORY_AUDIO="{6994AD04-93EF-11D0-A3CC-00A0C9223196}"
KSCATEGORY_RENDER="{65E8773E-8F56-11D0-A3B9-00A0C9223196}"
KSCATEGORY_CAPTURE="{65E8773D-8F56-11D0-A3B9-00A0C9223196}"
KSNAME_Wave="Wave"
KSNAME_UART="UART"
KSNAME_FMSynth="FMSynth"
KSNAME_Topology="Topology"

WDM.UART.szPname="SB16 MPU-401"
WDM.FMSynth.szPname="SB16 FM Synthesizer"

sndblst.SvcDesc = "WDM Sample Driver for SB16"



=== sb16/readme.htm ===
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-
1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>SoundBlaster16</TITLE>
</HEAD>
<BODY LINK="#0000ff">

<FONT FACE="Verdana" SIZE=5><H2>SoundBlaster16</H2>
</FONT><FONT FACE="Verdana" SIZE=2>
<P><span style="color:#FF0000;font-size:10pt;font-family:Arial">[This is preliminary 
documentation and subject to change.]</span></P>

<H3>SUMMARY</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
This sample driver demonstrates the basics of writing a
WDM audio driver, and can be used to write your own WDM driver. It will work with any SoundBlaster 16-compatible audio card, but may not use all of the functionality. Please see both the "Driver Issues" section below and the comments in the driver, which will help you add functionality like Power Management to your driver.

<H3>BUILDING THE SAMPLE</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>
To build this sample, enter the free or checked build environment and run <B>build</B> from the \\Ntddk\Src\Audio directory, rather than the Sb16 subdirectory. This sample links with Stdunk.lib, which is also built if you run </B>build</B> from \\Ntddk\Src\Audio.<P>

The .inf included in the \\98ddk\Src\Audio\Sb16 directory (Mssb16.inf) can be used to install the sample driver after it has been built.  Simply copy the .inf and the driver binary to a floppy disk. Then install the sample from the floppy.  Once the driver has been installed successfully with the .inf, simply drop updated driver binaries into \Windows\System32\Drivers on the target machine and reboot to test the new driver.  <P>

<H3>DRIVER ISSUES</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>
Developers should be aware of the following issues when testing or otherwise using this sample driver.<p>

1. This sample driver shows how to implement event callbacks. However, this code will not run properly on SB hardware. Only the Vibra class devices with C16X mixer on it (CT4170) support this functionality but the sample driver doesn't support Vibra class devices (see point 4). It would be a mayor change to support Vibra class devices.<p>

2.  This driver does not support the AWE portion of AWE-capable devices such as the AWE32 or AWE64.  Since the sample driver does not service the AWE devnode, it does not initialize the AWE devnode. As a result, MIDI played back using the FM synth will not be audible. This is <I>not</I> a bug with the FMSynth miniport or other aspect of the sample driver.  It is simply a result of not initializing the AWE devnode.<p>

3.  Under some circumstances, wave audio may hang up when the rendering stream is frequently stopped and started.  This intermittent problem is specific to the SB hardware.<p>

4.  This sample driver does not properly support Vibra class devices.<p>

<H3>CODE TOUR</H3>
<H4>File Manifest</H4>
</FONT><U><PRE>File&#9;&#9;Description
</U>
Adapter.cpp&#9;Connects the driver with the system
Common.cpp&#9;Common object used by all miniports
Common.h &#9;Header file for the common object
Makefile&#9;Standard Windows NT makefile
Mintopo.cpp&#9;Implementation of the topology miniport
Mintopo.h&#9;Header file for the topology miniport
Minwave.cpp&#9;Implementation of the wave cyclic miniport and the stream object
Minwave.h&#9;Header file for the wave cyclic miniport and the stream object
Mssb16.inf&#9;Setup information
Readme.htm&#9;The documentation for this driver (this file)
Sb16.rc&#9;	Resource file containing version information
Sources&#9;	Dependency information for compiling
Tables.h&#9;Topology and property tables

</FONT><P ALIGN="CENTER"><A HREF="#top"><FONT FACE="Verdana" SIZE=2>Top of page</FONT></A><FONT FACE="Verdana" SIZE=2> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 WIDTH=624>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff" HEIGHT=2>
<P></TD>
</TR>
</TABLE>

<FONT FACE="MS Sans Serif" SIZE=1><P>&copy; Microsoft Corporation 1999-2000</FONT><FONT FACE="Verdana" SIZE=2> </P></FONT></BODY>
</HTML>


=== sb16/sb16.def ===
LIBRARY         sb16.sys



=== sb16/sb16.rc ===
/* Copyright (c) 1997,1998 Microsoft Corporation.  All Rights Reserved. */

#include <windows.h>

#include <ntverp.h>

#define VER_FILETYPE                VFT_DRV
#define VER_FILESUBTYPE             VFT2_DRV_SOUND
#define VER_FILEDESCRIPTION_STR     "Sound Blaster 16 Adapter Driver"
#define VER_INTERNALNAME_STR        "sb16.sys"
#define VER_ORIGINALFILENAME_STR    "sb16.sys"

#include "common.ver"




=== sb16/sources ===

# Copyright (c) 1995-2000 Microsoft Corporation.  All rights reserved.

TARGETNAME=mssb16
TARGETTYPE=DRIVER
TARGETPATH=obj

TARGETLIBS= \
        $(SDK_LIB_PATH)\portcls.lib\
        $(SDK_LIB_PATH)\libcntpr.lib\
        ..\lib\*\stdunk.lib

INCLUDES=..\inc

MSC_WARNING_LEVEL=-W3 -WX

C_DEFINES= $(C_DEFINES) -D_WIN32 -DUNICODE -D_UNICODE

#
# Different levels of debug printage.  First is nothing but
# catastrophic errors, last is everything under the sun.
#
#C_DEFINES= $(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_ERROR
C_DEFINES= $(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_TERSE
#C_DEFINES= $(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_VERBOSE
#C_DEFINES= $(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_BLAB

LINKER_FLAGS=-map

SOURCES=\
        adapter.cpp     \
        common.cpp      \
        mintopo.cpp     \
        minwave.cpp     \
        sb16.rc


=== sb16/tables.h ===
/*****************************************************************************
 * tables.h - SB16 topology miniport tables
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 */

#ifndef _SB16TOPO_TABLES_H_
#define _SB16TOPO_TABLES_H_

/*****************************************************************************
 * The topology
 *****************************************************************************
 *
 *  wave>-------VOL---------------------+
 *                                      |
 * synth>-------VOL--+------------------+
 *                   |                  |
 *                   +--SWITCH_2X2--+   |
 *                                  |   |
 *    cd>-------VOL--+--SWITCH----------+
 *                   |              |   |
 *                   +--SWITCH_2X2--+   |
 *                                  |   |
 *   aux>-------VOL--+--SWITCH----------+
 *                   |              |   |
 *                   +--SWITCH_2X2--+   |
 *                                  |   |
 *   mic>--AGC--VOL--+--SWITCH----------+--VOL--BASS--TREBLE--GAIN-->lineout
 *                   |              |
 *                   +--SWITCH_1X2--+-------------------------GAIN-->wavein
 *
 */
 
/*****************************************************************************
 * PinDataRangesBridge
 *****************************************************************************
 * Structures indicating range of valid format values for bridge pins.
 */
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

/*****************************************************************************
 * PinDataRangePointersBridge
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for audio bridge pins.
 */
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

/*****************************************************************************
 * MiniportPins
 *****************************************************************************
 * List of pins.
 */
static
PCPIN_DESCRIPTOR 
MiniportPins[] =
{
    // WAVEOUT_SOURCE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSNODETYPE_LEGACY_AUDIO_CONNECTOR,         // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },

    // SYNTH_SOURCE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSNODETYPE_SYNTHESIZER,                    // Category
            &KSAUDFNAME_MIDI,                           // Name
            0                                           // Reserved
        }
    },

    // CD_SOURCE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSNODETYPE_CD_PLAYER,                      // Category
            &KSAUDFNAME_CD_AUDIO,                       // Name
            0                                           // Reserved
        }
    },

    // LINEIN_SOURCE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSNODETYPE_LINE_CONNECTOR,                 // Category
            &KSAUDFNAME_LINE_IN,                        // Name
            0                                           // Reserved
        }
    },

    // MIC_SOURCE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSNODETYPE_MICROPHONE,                     // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },

    // LINEOUT_DEST
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSNODETYPE_SPEAKER,                        // Category
            &KSAUDFNAME_VOLUME_CONTROL,                 // Name (this name shows up as
                                                        // the playback panel name in SoundVol)
            0                                           // Reserved
        }
    },

    // WAVEIN_DEST
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            &KSCATEGORY_AUDIO,                          // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
};

enum
{
    WAVEOUT_SOURCE = 0,
    SYNTH_SOURCE,
    CD_SOURCE,
    LINEIN_SOURCE,
    MIC_SOURCE,
    LINEOUT_DEST,
    WAVEIN_DEST
};

/*****************************************************************************
 * PropertiesVolume
 *****************************************************************************
 * Properties for volume controls.
 */
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_VOLUMELEVEL,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Level
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationVolume
 *****************************************************************************
 * Automation table for volume controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume,PropertiesVolume);

/*****************************************************************************
 * PropertiesAgc
 *****************************************************************************
 * Properties for AGC controls.
 */
static
PCPROPERTY_ITEM PropertiesAgc[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_AGC,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_OnOff
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationAgc
 *****************************************************************************
 * Automation table for Agc controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationAgc,PropertiesAgc);

/*****************************************************************************
 * PropertiesMute
 *****************************************************************************
 * Properties for mute controls.
 */
static
PCPROPERTY_ITEM PropertiesMute[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_MUTE,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_OnOff
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationMute
 *****************************************************************************
 * Automation table for mute controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationMute,PropertiesMute);

/*****************************************************************************
 * PropertiesTone
 *****************************************************************************
 * Properties for tone controls.
 */
static
PCPROPERTY_ITEM PropertiesTone[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_BASS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Level
    },
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_TREBLE,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Level
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationTone
 *****************************************************************************
 * Automation table for tone controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationTone,PropertiesTone);

/*****************************************************************************
 * PropertiesSupermix
 *****************************************************************************
 * Properties for supermix controls.
 */
static
PCPROPERTY_ITEM PropertiesSupermix[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SuperMixCaps
    },
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SuperMixTable
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationSupermix
 *****************************************************************************
 * Automation table for supermix controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSupermix,PropertiesSupermix);

#ifdef EVENT_SUPPORT
/*****************************************************************************
 * The Event for the Master Volume (or other nodes)
 *****************************************************************************
 * Generic event for nodes.
 */
static PCEVENT_ITEM NodeEvent[] =
{
    // This is a generic event for nearly every node property.
    {
        &KSEVENTSETID_AudioControlChange,   // Something changed!
        KSEVENT_CONTROL_CHANGE,             // The only event-property defined.
        KSEVENT_TYPE_ENABLE | KSEVENT_TYPE_BASICSUPPORT,
        CMiniportTopologySB16::EventHandler
    }
};

/*****************************************************************************
 * AutomationVolumeWithEvent
 *****************************************************************************
 * This is the automation table for Volume events.
 * You can create Automation tables with event support for any type of nodes
 * (e.g. mutes) with just adding the generic event above. The automation table
 * then gets added to every node that should have event support.
 */
DEFINE_PCAUTOMATION_TABLE_PROP_EVENT (AutomationVolumeWithEvent, PropertiesVolume, NodeEvent);
#endif

/*****************************************************************************
 * TopologyNodes
 *****************************************************************************
 * List of node identifiers.
 */
static
PCNODE_DESCRIPTOR TopologyNodes[] =
{
    // WAVEOUT_VOLUME
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_WAVE_VOLUME // Name
    },

    // SYNTH_VOLUME
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_MIDI_VOLUME // Name
    },

    // SYNTH_WAVEIN_SUPERMIX
    {
        0,                      // Flags
        &AutomationSupermix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        &KSAUDFNAME_MIDI_MUTE   // Name
    },

    // CD_VOLUME
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_CD_VOLUME   // Name
    },

    // CD_LINEOUT_SUPERMIX
    {
        0,                      // Flags
        &AutomationSupermix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        &KSAUDFNAME_CD_MUTE     // Name
    },

    // CD_WAVEIN_SUPERMIX
    {
        0,                      // Flags
        &AutomationSupermix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        &KSAUDFNAME_CD_MUTE     // Name
    },

    // LINEIN_VOLUME
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_LINE_VOLUME // Name
    },

    // LINEIN_LINEOUT_SUPERMIX
    {
        0,                      // Flags
        &AutomationSupermix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        &KSAUDFNAME_LINE_MUTE   // Name
    },

    // LINEIN_WAVEIN_SUPERMIX
    {
        0,                      // Flags
        &AutomationSupermix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        &KSAUDFNAME_LINE_MUTE   // Name
    },

    // MIC_AGC
    {
        0,                      // Flags
        &AutomationAgc,         // AutomationTable
        &KSNODETYPE_AGC,        // Type
        NULL                    // Name
    },

    // MIC_VOLUME
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_MIC_VOLUME  // Name
    },

    // MIC_LINEOUT_MUTE
    {
        0,                      // Flags
        &AutomationMute,        // AutomationTable
        &KSNODETYPE_MUTE,       // Type
        &KSAUDFNAME_MIC_MUTE    // Name
    },

    // MIC_WAVEIN_SUPERMIX
    {
        0,                      // Flags
        &AutomationSupermix,    // AutomationTable
        &KSNODETYPE_SUPERMIX,   // Type
        &KSAUDFNAME_MIC_MUTE    // Name
    },

    // LINEOUT_MIX
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_SUM,        // Type
        NULL                    // Name
    },

    // LINEOUT_VOL
    {
        0,                      // Flags
#ifdef EVENT_SUPPORT
        &AutomationVolumeWithEvent, // AutomationTable with event support
#else
        &AutomationVolume,      // AutomationTable
#endif
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_MASTER_VOLUME // Name
    },

    // LINEOUT_BASS
    {
        0,                      // Flags
        &AutomationTone,        // AutomationTable
        &KSNODETYPE_TONE,       // Type
        &KSAUDFNAME_BASS        // Name
    },

    // LINEOUT_TREBLE
    {
        0,                      // Flags
        &AutomationTone,        // AutomationTable
        &KSNODETYPE_TONE,       // Type
        &KSAUDFNAME_TREBLE      // Name
    },

    // LINEOUT_GAIN
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        NULL                    // Name
    },

    // WAVEIN_MIX
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_SUM,        // Type
        &KSAUDFNAME_RECORDING_SOURCE // Name
    },

    // WAVEIN_GAIN
    {
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        &KSAUDFNAME_WAVE_IN_VOLUME // Name
    }
};

/*****************************************************************************
 * ControlValueCache
 *****************************************************************************
 */
static
LONG ControlValueCache[] =
{   // Left         // Right
    0xFFF9F203,     0xFFF9F203,     // WAVEOUT_VOLUME
    0xFFF9F203,     0xFFF9F203,     // SYNTH_VOLUME
    0xFFF9F203,     0xFFF9F203,     // CD_VOLUME
    0xFFF9F203,     0xFFF9F203,     // LINEIN_VOLUME
    0xFFF9F203,     0,              // MIC_VOLUME
    0xFFF9F203,     0xFFF9F203,     // LINEOUT_VOL
    0x000242A0,     0x000242A0,     // LINEOUT_BASS
    0x000242A0,     0x000242A0,     // LINEOUT_TREBLE
    0x000C0000,     0x000C0000,     // LINEOUT_GAIN
    0x00000000,     0x00000000      // WAVEIN_GAIN
};

typedef struct
{
    BYTE    BaseRegister;           // H/W access parameter
    ULONG   CacheOffset;            // ControlValueCache offset
} ACCESS_PARM,*PACCESS_PARM;

/*****************************************************************************
 * AccessParams
 *****************************************************************************
 * Table of H/W access parameters
 */
static
ACCESS_PARM AccessParams[] =
{
    { DSP_MIX_VOICEVOLIDX_L,        0           },      // WAVEOUT_VOLUME

    { DSP_MIX_FMVOLIDX_L,           2           },      // SYNTH_VOLUME
    { MIXBIT_SYNTH_WAVEIN_R,        ULONG(-1)   },      // SYNTH_WAVEIN_SUPERMIX

    { DSP_MIX_CDVOLIDX_L,           4           },      // CD_VOLUME
    { MIXBIT_CD_LINEOUT_R,          ULONG(-1)   },      // CD_LINEOUT_SUPERMIX
    { MIXBIT_CD_WAVEIN_R,           ULONG(-1)   },      // CD_WAVEIN_SUPERMIX

    { DSP_MIX_LINEVOLIDX_L,         6           },      // LINEIN_VOLUME
    { MIXBIT_LINEIN_LINEOUT_R,      ULONG(-1)   },      // LINEIN_LINEOUT_SUPERMIX
    { MIXBIT_LINEIN_WAVEIN_R,       ULONG(-1)   },      // LINEIN_WAVEIN_SUPERMIX

    { 0,                            ULONG(-1)   },      // MIC_AGC
    { DSP_MIX_MICVOLIDX,            8           },      // MIC_VOLUME
    { 0,                            ULONG(-1)   },      // MIC_LINEOUT_MUTE
    { 0,                            ULONG(-1)   },      // MIC_WAVEIN_SUPERMIX

    { 0,                            ULONG(-1)   },      // LINEOUT_MIX
    { DSP_MIX_MASTERVOLIDX_L,       10          },      // LINEOUT_VOL
    { DSP_MIX_BASSIDX_L,            12          },      // LINEOUT_BASS
    { DSP_MIX_TREBLEIDX_L,          14          },      // LINEOUT_TREBLE
    { DSP_MIX_OUTGAINIDX_L,         16          },      // LINEOUT_GAIN

    { 0,                            ULONG(-1)   },      // WAVEIN_MIX
    { DSP_MIX_INGAINIDX_L,          18          }       // WAVEIN_GAIN
};

enum
{
    WAVEOUT_VOLUME = 0,
    SYNTH_VOLUME,
    SYNTH_WAVEIN_SUPERMIX,
    CD_VOLUME,
    CD_LINEOUT_SUPERMIX,
    CD_WAVEIN_SUPERMIX,
    LINEIN_VOLUME,
    LINEIN_LINEOUT_SUPERMIX,
    LINEIN_WAVEIN_SUPERMIX,
    MIC_AGC,
    MIC_VOLUME,
    MIC_LINEOUT_MUTE,
    MIC_WAVEIN_SUPERMIX,
    LINEOUT_MIX,
    LINEOUT_VOL,
    LINEOUT_BASS,
    LINEOUT_TREBLE,
    LINEOUT_GAIN,
    WAVEIN_MIX,
    WAVEIN_GAIN
};

/*****************************************************************************
 * ConnectionTable
 *****************************************************************************
 * Table of topology unit connections.
 *
 * Pin numbering is technically arbitrary, but the convention established here
 * is to number a solitary output pin 0 (looks like an 'o') and a solitary
 * input pin 1 (looks like an 'i').  Even destinations, which have no output,
 * have an input pin numbered 1 and no pin 0.
 *
 * Nodes are more likely to have multiple ins than multiple outs, so the more
 * general rule would be that inputs are numbered >=1.  If a node has multiple
 * outs, none of these conventions apply.
 *
 * Nodes have at most one control value.  Mixers are therefore simple summing
 * nodes with no per-pin levels.  Rather than assigning a unique pin to each
 * input to a mixer, all inputs are connected to pin 1.  This is acceptable
 * because there is no functional distinction between the inputs.
 *
 * There are no multiplexers in this topology, so there is no opportunity to
 * give an example of a multiplexer.  A multiplexer should have a single
 * output pin (0) and multiple input pins (1..n).  Its control value is an
 * integer in the range 1..n indicating which input is connected to the
 * output.
 *
 * In the case of connections to pins, as opposed to connections to nodes, the
 * node is identified as PCFILTER_NODE and the pin number identifies the
 * particular filter pin.
 */
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{   //  FromNode,               FromPin,          ToNode,                 ToPin
    {   PCFILTER_NODE,          WAVEOUT_SOURCE,   WAVEOUT_VOLUME,         1             },
    {   WAVEOUT_VOLUME,         0,                LINEOUT_MIX,            1             },

    {   PCFILTER_NODE,          SYNTH_SOURCE,     SYNTH_VOLUME,           1             },
    {   SYNTH_VOLUME,           0,                LINEOUT_MIX,            2             },
    {   SYNTH_VOLUME,           0,                SYNTH_WAVEIN_SUPERMIX,  1             },
    {   SYNTH_WAVEIN_SUPERMIX,  0,                WAVEIN_MIX,             1             },

    {   PCFILTER_NODE,          CD_SOURCE,        CD_VOLUME,              1             },
    {   CD_VOLUME,              0,                CD_LINEOUT_SUPERMIX,    1             },
    {   CD_LINEOUT_SUPERMIX,    0,                LINEOUT_MIX,            3             },
    {   CD_VOLUME,              0,                CD_WAVEIN_SUPERMIX,     1             },
    {   CD_WAVEIN_SUPERMIX,     0,                WAVEIN_MIX,             2             },

    {   PCFILTER_NODE,          LINEIN_SOURCE,    LINEIN_VOLUME,          1             },
    {   LINEIN_VOLUME,          0,                LINEIN_LINEOUT_SUPERMIX,1             },
    {   LINEIN_LINEOUT_SUPERMIX,0,                LINEOUT_MIX,            4             },
    {   LINEIN_VOLUME,          0,                LINEIN_WAVEIN_SUPERMIX, 1             },
    {   LINEIN_WAVEIN_SUPERMIX, 0,                WAVEIN_MIX,             3             },

    {   PCFILTER_NODE,          MIC_SOURCE,       MIC_AGC,                1             },
    {   MIC_AGC,                0,                MIC_VOLUME,             1             },
    {   MIC_VOLUME,             0,                MIC_LINEOUT_MUTE,       1             },
    {   MIC_LINEOUT_MUTE,       0,                LINEOUT_MIX,            5             },
    {   MIC_VOLUME,             0,                MIC_WAVEIN_SUPERMIX,    1             },
    {   MIC_WAVEIN_SUPERMIX,    0,                WAVEIN_MIX,             4             },

    {   LINEOUT_MIX,            0,                LINEOUT_VOL,            1             },
    {   LINEOUT_VOL,            0,                LINEOUT_BASS,           1             },
    {   LINEOUT_BASS,           0,                LINEOUT_TREBLE,         1             },
    {   LINEOUT_TREBLE,         0,                LINEOUT_GAIN,           1             },
    {   LINEOUT_GAIN,           0,                PCFILTER_NODE,          LINEOUT_DEST  },

    {   WAVEIN_MIX,             0,                WAVEIN_GAIN,            1             },
    {   WAVEIN_GAIN,            0,                PCFILTER_NODE,          WAVEIN_DEST   }
};

/*****************************************************************************
 * MiniportFilterDescription
 *****************************************************************************
 * Complete miniport description.
 */
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(TopologyNodes),        // NodeCount
    TopologyNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories
};

#endif


=== stdunk/makefile ===
#############################################################################
#
#       Copyright (C) Microsoft Corporation 1997-1999
#       All Rights Reserved.
#
#       Makefile for wdm\audio\backpln\stdunk directory
#
#############################################################################

## Define WIN95_BUILD to build in the memphis
## build enviroment

!IFDEF WIN95_BUILD

ROOT = ..\..\..\..

IS_32   = TRUE
IS_OEM  = TRUE
DEVICEDIR = STDUNK
COMMONMKFILE = $(DEVICEDIR).mk
DEPENDTARGETS = debug

!include $(ROOT)\dev\master.mk

## NT BUILD ENVIROMENT
!ELSE

#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT.
#
!INCLUDE $(NTMAKEENV)\makefile.def

!ENDIF

=== stdunk/sources ===
#    Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.

TARGETNAME=stdunk
TARGETTYPE=LIBRARY
TARGETPATH=..\lib

INCLUDES=..\inc

MSC_WARNING_LEVEL=-W3 -WX

C_DEFINES=-D_WIN32 -DUNICODE -D_UNICODE
LINKER_FLAGS=-map

SOURCES=\
        stdunk.cpp

=== stdunk/stdunk.cpp ===
/*****************************************************************************
 * stdunk.cpp - standard unknown implementation
 *****************************************************************************
 * Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 */

#include "portcls.h"
#include "stdunk.h"





/*****************************************************************************
 * CUnknown implementation
 */

/*****************************************************************************
 * CUnknown::CUnknown()
 *****************************************************************************
 * Constructor.
 */
CUnknown::CUnknown(PUNKNOWN pUnknownOuter)
:   m_lRefCount(0)
{
    if (pUnknownOuter)
    {
        m_pUnknownOuter = pUnknownOuter;
    }
    else
    {
        m_pUnknownOuter = PUNKNOWN(dynamic_cast<PNONDELEGATINGUNKNOWN>(this));
    }
}

/*****************************************************************************
 * CUnknown::~CUnknown()
 *****************************************************************************
 * Destructor.
 */
CUnknown::~CUnknown(void)
{
}




/*****************************************************************************
 * INonDelegatingUnknown implementation
 */

/*****************************************************************************
 * CUnknown::NonDelegatingAddRef()
 *****************************************************************************
 * Register a new reference to the object without delegating to the outer
 * unknown.
 */
STDMETHODIMP_(ULONG) CUnknown::NonDelegatingAddRef(void)
{
    ASSERT(m_lRefCount >= 0);

    InterlockedIncrement(&m_lRefCount);

    return ULONG(m_lRefCount);
}

/*****************************************************************************
 * CUnknown::NonDelegatingRelease()
 *****************************************************************************
 * Release a reference to the object without delegating to the outer unknown.
 */
STDMETHODIMP_(ULONG) CUnknown::NonDelegatingRelease(void)
{
    ASSERT(m_lRefCount > 0);

    if (InterlockedDecrement(&m_lRefCount) == 0)
	{
        m_lRefCount++;
        delete this;
        return 0;
	}

    return ULONG(m_lRefCount); 
}

/*****************************************************************************
 * CUnknown::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.
 */
STDMETHODIMP CUnknown::NonDelegatingQueryInterface
(
    REFIID  rIID,
    PVOID * ppVoid
)
{
    ASSERT(ppVoid);

    if (IsEqualGUIDAligned(rIID,IID_IUnknown))
    {
        *ppVoid = PVOID(PUNKNOWN(this));
    }
    else
    {
        *ppVoid = NULL;
    }
    
    if (*ppVoid)
    {
        PUNKNOWN(*ppVoid)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

=== stdunk/stdunk.htm ===
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Stdunk</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type>
<META content="MSHTML 5.00.2516.1900" name=GENERATOR></HEAD>
<BODY link=#0000ff><FONT face=Verdana size=5>
<H2>Stdunk</H2></FONT><FONT face=Verdana size=2>
<P><SPAN style="COLOR: #ff0000; FONT-FAMILY: Arial; FONT-SIZE: 10pt">[This is 
preliminary documentation and subject to change.]</SPAN></P>
<H3>SUMMARY</H3></FONT><FONT face=Verdana size=2>
<P>Stdunk is the implementation of the CUnknown class and the IUnknown 
interface. Stdunk is required in order to build the normal WDM audio samples. It 
is not included as an example to be changed, as the other DDK samples, but 
simply as required code for building any WDM audio driver. 
<H3>BUILDING THE SAMPLE</H3></FONT><FONT face=Verdana size=2>
<P>It is recommended that you build the WDM audio drivers together with this 
library from the \\Ntddk\Src\Wdm\Audio directory. Just type <B>build</B> in this 
directory and it will compile and link any WDM audio driver with the libraries 
that are needed. 
<H3>CODE TOUR</H3>
<H4>File Manifest</H4></FONT><U><PRE>File		Description
</U>
Stdunk.cpp	Standard unknown implementation
Sources		Sources for build
Makefile	Makefile for Stdunk
</FONT><P align=center><A href="file:///D:/Documents%20and%20Settings/fberreth/Local%20Settings/Temp/stdunk1.htm#top"><FONT face=Verdana size=2>Top of page</FONT></A><FONT face=Verdana size=2> </P></FONT>
<TABLE border=0 cellSpacing=0 width=624><TBODY><TR><TD bgColor=#00ffff height=2 vAlign=center><P></P></TD></TR></TBODY></TABLE>

<FONT face="MS Sans Serif" size=1><P> 1999 Microsoft Corporation</FONT><FONT face=Verdana size=2> </P></FONT>

</PRE></BODY></HTML>

=== uart/makefile ===
#############################################################################
#
#       Copyright (C) Microsoft Corporation 1998-1999
#       All Rights Reserved.
#
#       Makefile for wdm\audio\backpln\miniport\UART
#
#       1/6/98  MartinP
#
#############################################################################

## Define WIN95_BUILD to build in the memphis
## build enviroment

!IFDEF WIN95_BUILD

ROOT = ..\..\..\..\..

IS_32   = TRUE
IS_OEM  = TRUE
DEVICEDIR = UART
COMMONMKFILE = $(DEVICEDIR).mk
DEPENDTARGETS = debug

!include $(ROOT)\dev\master.mk

## NT BUILD ENVIROMENT
!ELSE

#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT.
#
!INCLUDE $(NTMAKEENV)\makefile.def

!ENDIF

=== uart/miniport.cpp ===
/*****************************************************************************
 * miniport.cpp - UART miniport implementation
 *****************************************************************************
 * Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 */

#include "private.h"
#include "ksdebug.h"

#define STR_MODULENAME "UartMini: "


#pragma code_seg("PAGE")
/*****************************************************************************
 * PinDataRangesStream
 *****************************************************************************
 * Structures indicating range of valid format values for streaming pins.
 */
static
KSDATARANGE_MUSIC PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_MUSIC),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
        },
        STATICGUIDOF(KSMUSIC_TECHNOLOGY_PORT),
        0,
        0,
        0xFFFF
    }
};

/*****************************************************************************
 * PinDataRangePointersStream
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for live pins.
 */
static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

/*****************************************************************************
 * PinDataRangesBridge
 *****************************************************************************
 * Structures indicating range of valid format values for bridge pins.
 */
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI_BUS),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

/*****************************************************************************
 * PinDataRangePointersBridge
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for bridge pins.
 */
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

#define kMaxNumCaptureStreams       1
#define kMaxNumRenderStreams        1

/*****************************************************************************
 * MiniportPins
 *****************************************************************************
 * List of pins.
 */
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    {
        kMaxNumRenderStreams,kMaxNumRenderStreams,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStream),   // DataRangesCount
            PinDataRangePointersStream,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            &KSAUDFNAME_MIDI,                           // Name
            0                                           // Reserved
        }
    },
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
    {
        kMaxNumCaptureStreams,kMaxNumCaptureStreams,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStream),   // DataRangesCount
            PinDataRangePointersStream,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            &KSAUDFNAME_MIDI,                           // Name
            0                                           // Reserved
        }
    },
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
};

/*****************************************************************************
 * MiniportConnections
 *****************************************************************************
 * List of connections.
 */
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    { PCFILTER_NODE,  0,  PCFILTER_NODE,    1 },
    { PCFILTER_NODE,  3,  PCFILTER_NODE,    2 }    
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport filter description.
 */
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    0,                                  // NodeCount
    NULL,                               // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories
};

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::GetDescription()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP
CMiniportMidiUart::
GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE,("GetDescription"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;

    return STATUS_SUCCESS;
}


#pragma code_seg("PAGE")
/*****************************************************************************
 * CreateMiniportMidiUart()
 *****************************************************************************
 * Creates a MPU-401 miniport driver for the adapter.  This uses a
 * macro from STDUNK.H to do all the work.
 */
NTSTATUS
CreateMiniportMidiUart
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("CreateMiniportDMusUART"));
    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportMidiUart,Unknown,UnknownOuter,PoolType);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::ProcessResources()
 *****************************************************************************
 * Processes the resource list, setting up helper objects accordingly.
 */
NTSTATUS
CMiniportMidiUart::
ProcessResources
(
    IN      PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_BLAB,("ProcessResources"));
    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    //
    // Get counts for the types of resources.
    //
    ULONG   countIO     = ResourceList->NumberOfPorts();
    ULONG   countIRQ    = ResourceList->NumberOfInterrupts();
    ULONG   countDMA    = ResourceList->NumberOfDmas();
    ULONG   lengthIO    = ResourceList->FindTranslatedPort(0)->u.Port.Length;

#if (DBG)
    _DbgPrintF(DEBUGLVL_VERBOSE,("Starting MPU401 Port 0x%X",
        ResourceList->FindTranslatedPort(0)->u.Port.Start.LowPart) );
#endif

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make sure we have the expected number of resources.
    //
    if  (   (countIO != 1)
        ||  (countIRQ  > 1)
        ||  (countDMA != 0)
        ||  (lengthIO == 0)
        )
    {
        _DbgPrintF(DEBUGLVL_TERSE,("Unknown ResourceList configuraton"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Get the port address.
        //
        m_pPortBase =
            PUCHAR(ResourceList->FindTranslatedPort(0)->u.Port.Start.LowPart);

        ntStatus = InitializeHardware(m_pInterruptSync,m_pPortBase);
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CMiniportMidiUart::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("Miniport::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportMidi))
    {
        *Object = PVOID(PMINIPORTMIDI(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::~CMiniportMidiUart()
 *****************************************************************************
 * Destructor.
 */
CMiniportMidiUart::~CMiniportMidiUart(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("~CMiniportMidiUart"));

    ASSERT(0 == m_NumCaptureStreams);
    ASSERT(0 == m_NumRenderStreams);
    
    //  reset the HW so we don't get any more interrupts
    if (m_UseIRQ && m_pInterruptSync)
    {
        (void) m_pInterruptSync->CallSynchronizedRoutine(InitLegacyMPU,PVOID(m_pPortBase));
    }
    else
    {
        (void) InitLegacyMPU(NULL,PVOID(m_pPortBase));
    }

    if (m_pInterruptSync)
    {
//        m_pInterruptSync->Disconnect();
        m_pInterruptSync->Release();
        m_pInterruptSync = NULL;
    }
    if (m_pServiceGroup)
    {
        m_pServiceGroup->Release();
        m_pServiceGroup = NULL;
    }
    if (m_pPort)
    {
        m_pPort->Release();
        m_pPort = NULL;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::Init()
 *****************************************************************************
 * Initializes a the miniport.
 */
STDMETHODIMP
CMiniportMidiUart::
Init
(
    IN	    PUNKNOWN	    UnknownInterruptSync    OPTIONAL,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTMIDI       Port_,
    OUT     PSERVICEGROUP * ServiceGroup
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }
    ASSERT(Port_);
    ASSERT(ServiceGroup);

    _DbgPrintF(DEBUGLVL_BLAB,("Init"));

    m_pPortBase = 0;
    //
    // AddRef() is required because we are keeping this pointer.
    //
    m_pPort = Port_;
    m_pPort->AddRef();

    for (ULONG bufferCount = 0;bufferCount < kMPUInputBufferSize;bufferCount++)
    {
        m_MPUInputBuffer[bufferCount] = 0;
    }
    m_MPUInputBufferHead = 0;
    m_MPUInputBufferTail = 0;
    m_KSStateInput = KSSTATE_STOP;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    m_NumRenderStreams = 0;
    m_NumCaptureStreams = 0;
    _DbgPrintF(DEBUGLVL_VERBOSE,("Init: resetting m_NumRenderStreams and m_NumCaptureStreams"));

    m_UseIRQ = TRUE;
    if (ResourceList->NumberOfInterrupts() == 0)
    {
        m_UseIRQ = FALSE;
    }

    ntStatus = PcNewServiceGroup(&m_pServiceGroup,NULL);
    if (NT_SUCCESS(ntStatus) && !m_pServiceGroup)   //  keep any error
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus))
    {
        *ServiceGroup = m_pServiceGroup;
        m_pServiceGroup->AddRef();

		//
		// Register the service group with the port early so the port is
		// prepared to handle interrupts.
		//
		m_pPort->RegisterServiceGroup(m_pServiceGroup);
    }

    if (NT_SUCCESS(ntStatus) && m_UseIRQ)
    {
/*
        //
        //  Due to a bug in the InterruptSync design, we shouldn't share
        //  the interrupt sync object.  Whoever goes away first 
        //  will disconnect it, and the other points off into nowhere.
        //  
        //  Instead we generate our own interrupt sync object.
        //
        UnknownInterruptSync = NULL;
*/
        if (UnknownInterruptSync)
        {
            ntStatus = 
                UnknownInterruptSync->QueryInterface
                (
                    IID_IInterruptSync,
                    (PVOID *) &m_pInterruptSync
                );

            if (!m_pInterruptSync && NT_SUCCESS(ntStatus))  //  keep any error
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            if (NT_SUCCESS(ntStatus))
            {                                                                           //  run this ISR first
                ntStatus = m_pInterruptSync->
                    RegisterServiceRoutine(MPUInterruptServiceRoutine,PVOID(this),TRUE);
            }
        }
        else
        {   // create our own interruptsync mechanism.
            ntStatus = 
                PcNewInterruptSync
                (
                    &m_pInterruptSync,
                    NULL,
                    ResourceList,
                    0,                          // Resource Index
                    InterruptSyncModeNormal     // Run ISRs once until we get SUCCESS
                );

            if (!m_pInterruptSync && NT_SUCCESS(ntStatus))  //  keep any error
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_pInterruptSync->RegisterServiceRoutine(
                    MPUInterruptServiceRoutine,
                    PVOID(this),
                    TRUE);                //  run this ISR first
            }
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_pInterruptSync->Connect();
            }
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ProcessResources(ResourceList);
    }

    if (!NT_SUCCESS(ntStatus))
    {
        //
        // clean up our mess
        //

        // clean up the interrupt sync
        if( m_pInterruptSync )
        {
//            m_pInterruptSync->Disconnect();
            m_pInterruptSync->Release();
            m_pInterruptSync = NULL;
        }

        // clean up the service group
        if( m_pServiceGroup )
        {
            m_pServiceGroup->Release();
            m_pServiceGroup = NULL;
        }
        (*ServiceGroup) = NULL;

        // release the port
        m_pPort->Release();
        m_pPort = NULL;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiUart::NewStream()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP 
CMiniportMidiUart::
NewStream
(
    OUT     PMINIPORTMIDISTREAM *   Stream,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   PinID,
    IN      BOOLEAN                 Capture,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP *         ServiceGroup
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("NewStream"));
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // if we don't have any streams already open, get the hardware ready.
    if ((!m_NumCaptureStreams) && (!m_NumRenderStreams))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("NewStream: m_NumRenderStreams and m_NumCaptureStreams are both 0, so ResetMPUHardware"));
        (void) ResetMPUHardware(m_pPortBase);
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("NewStream: m_NumRenderStreams %d, m_NumCaptureStreams %d, no ResetMPUHardware",
                                     m_NumRenderStreams,m_NumCaptureStreams));
    }

    if  (   (   (m_NumCaptureStreams < kMaxNumCaptureStreams)
            &&  (Capture)  )
        ||  (   (m_NumRenderStreams < kMaxNumRenderStreams) 
            &&  (!Capture) )
        )
    {
        CMiniportMidiStreamUart *pStream =
            new(PoolType) CMiniportMidiStreamUart(OuterUnknown);

        if (pStream)
        {
            pStream->AddRef();

            ntStatus = 
                pStream->Init(this,m_pPortBase,Capture);

            if (NT_SUCCESS(ntStatus))
            {
                *Stream = PMINIPORTMIDISTREAM(pStream);
                (*Stream)->AddRef();

                if (Capture)
                {
                    m_NumCaptureStreams++;
                    *ServiceGroup = m_pServiceGroup;
                    (*ServiceGroup)->AddRef();
                }
                else
                {
                    m_NumRenderStreams++;
                    *ServiceGroup = NULL;
                }
                _DbgPrintF(DEBUGLVL_VERBOSE,("NewStream: succeeded, m_NumRenderStreams %d, m_NumCaptureStreams %d",
                                              m_NumRenderStreams,m_NumCaptureStreams));
            }

            pStream->Release();
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        if (Capture)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream failed, too many capture streams"));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream failed, too many render streams"));
        }
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiStreamUart::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CMiniportMidiStreamUart::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("Stream::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportMidiStream))
    {
        *Object = PVOID(PMINIPORTMIDISTREAM(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiStreamUart::SetFormat()
 *****************************************************************************
 * Sets the format.
 */
STDMETHODIMP
CMiniportMidiStreamUart::
SetFormat
(
    IN      PKSDATAFORMAT   Format
)
{
    PAGED_CODE();

    ASSERT(Format);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamUart::SetFormat"));

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiStreamUart::~CMiniportMidiStreamUart()
 *****************************************************************************
 * Destructs a stream.
 */
CMiniportMidiStreamUart::~CMiniportMidiStreamUart(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("~CMiniportMidiStreamUart"));

    if (m_pMiniport)
    {
        if (m_fCapture)
        {
            m_pMiniport->m_NumCaptureStreams--;
        }
        else
        {
            m_pMiniport->m_NumRenderStreams--;
        }
        _DbgPrintF(DEBUGLVL_VERBOSE,("~CMiniportMidiStreamUart: m_NumRenderStreams %d, m_NumCaptureStreams %d",
                                      m_pMiniport->m_NumRenderStreams,m_pMiniport->m_NumCaptureStreams));

        m_pMiniport->Release();
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("~CMiniportMidiStreamUart, no miniport!!!: m_NumRenderStreams %d, m_NumCaptureStreams %d",
                                      m_pMiniport->m_NumRenderStreams,m_pMiniport->m_NumCaptureStreams));
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportMidiStreamUart::Init()
 *****************************************************************************
 * Initializes a stream.
 */
STDMETHODIMP 
CMiniportMidiStreamUart::
Init
(
    IN      CMiniportMidiUart * pMiniport,
    IN      PUCHAR              pPortBase,
    IN      BOOLEAN             fCapture
)
{
    PAGED_CODE();

    ASSERT(pMiniport);
    ASSERT(pPortBase);

    _DbgPrintF(DEBUGLVL_VERBOSE,("Init"));

    m_NumFailedMPUTries = 0;
    m_pMiniport = pMiniport;
    m_pMiniport->AddRef();

    m_pPortBase = pPortBase;
    m_fCapture = fCapture;

    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportMidiStreamUart::SetState()
 *****************************************************************************
 * Sets the state of the channel.
 */
STDMETHODIMP
CMiniportMidiStreamUart::
SetState
(
    IN      KSSTATE     NewState
)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("SetState %d",NewState));

    if (m_fCapture)
    {
        m_pMiniport->m_KSStateInput = NewState;
        if (NewState == KSSTATE_STOP)   // STOPping
        {
            m_pMiniport->m_MPUInputBufferHead = 0;   // Previously read bytes are discarded.
            m_pMiniport->m_MPUInputBufferTail = 0;   // The entire FIFO is available.
        }
    }
    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportMidiUart::Service()
 *****************************************************************************
 * DPC-mode service call from the port.
 */
STDMETHODIMP_(void) 
CMiniportMidiUart::
Service
(   void
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("Service"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("Service: m_NumRenderStreams %d, m_NumCaptureStreams %d",
                                  m_NumRenderStreams,m_NumCaptureStreams));
    if (!m_NumCaptureStreams)
    {
        //  we should never get here....
        //  if we do, we must have read some trash,
        //  so just reset the input FIFO
        m_MPUInputBufferTail = m_MPUInputBufferHead = 0;
    }
}

#pragma code_seg()
=== uart/mpu.cpp ===
/*****************************************************************************
 * MPU.cpp - UART miniport implementation
 *****************************************************************************
 * Copyright (c) Microsoft Corporation 1998-1999.  All rights reserved.
 *
 *      Sept 98    MartinP .
 */

#include "private.h"
#include "ksdebug.h"

#define STR_MODULENAME "UART:MPU: "

//
// MPU401 ports
//
#define MPU401_REG_DATA     0x00    // Data I/O
#define MPU401_REG_COMMAND  0x01    // Command Register (w/o)
#define MPU401_REG_STATUS   0x01    // Status Register (r/o)

#define MPU401_CMD_RESET    0xFF    // Reset command
#define MPU401_CMD_UART     0x3F    // Switch to UART mode
#define MPU401_DRR          0x40    // Output ready (for command or data)
#define MPU401_DSR          0x80    // Input ready (for data)



#define UartFifoOkForWrite(status)  ((status & MPU401_DRR) == 0)
#define UartFifoOkForRead(status)   ((status & MPU401_DSR) == 0)

typedef struct
{
    CMiniportMidiUart  *Miniport;
    PUCHAR              PortBase;
    PVOID               BufferAddress;
    ULONG               Length;
    PULONG              BytesRead;
}
SYNCWRITECONTEXT, *PSYNCWRITECONTEXT;

typedef struct
{
    PVOID               BufferAddress;
    ULONG               Length;
    PULONG              BytesRead;
    PULONG              pMPUInputBufferHead;
    ULONG               MPUInputBufferTail;
    PUCHAR              MPUInputBuffer;
}
DEFERREDREADCONTEXT, *PDEFERREDREADCONTEXT;

NTSTATUS DeferredLegacyRead(IN PINTERRUPTSYNC InterruptSync,IN PVOID DynamicContext);
BOOLEAN  TryLegacyMPU(IN PUCHAR PortBase);
NTSTATUS WriteLegacyMPU(IN PUCHAR PortBase,IN BOOLEAN IsCommand,IN UCHAR Value);

#pragma code_seg("PAGE")
//  make sure we're in UART mode
NTSTATUS ResetMPUHardware(PUCHAR portBase)
{
    PAGED_CODE();

    return (WriteLegacyMPU(portBase,COMMAND,MPU401_CMD_UART));
}

#pragma code_seg("PAGE")
//
// We initialize the UART with interrupts suppressed so we don't
// try to service the chip prematurely.
//
NTSTATUS CMiniportMidiUart::InitializeHardware(PINTERRUPTSYNC interruptSync,PUCHAR portBase)
{
    PAGED_CODE();

    NTSTATUS ntStatus;
    if (m_UseIRQ)
    {
        ntStatus = interruptSync->CallSynchronizedRoutine(InitLegacyMPU,PVOID(portBase));
    }
    else
    {
        ntStatus = InitLegacyMPU(NULL,PVOID(portBase));
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Start the UART (this should trigger an interrupt).
        //
        ntStatus = ResetMPUHardware(portBase);
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("*** InitLegacyMPU returned with ntStatus 0x%08x ***",ntStatus));
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * InitLegacyMPU()
 *****************************************************************************
 * Synchronized routine to initialize the MPU401.
 */
NTSTATUS
InitLegacyMPU
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("InitLegacyMPU"));
    
    if (!DynamicContext)
    {
        return STATUS_INVALID_PARAMETER_2;
    }
    
    PUCHAR      portBase = PUCHAR(DynamicContext);
    UCHAR       status;
    ULONGLONG   startTime;
    BOOLEAN     success;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    
    //
    // Reset the card (puts it into "smart mode")
    //
    ntStatus = WriteLegacyMPU(portBase,COMMAND,MPU401_CMD_RESET);

    // wait for the acknowledgement
    // NOTE: When the Ack arrives, it will trigger an interrupt.  
    //       Normally the DPC routine would read in the ack byte and we
    //       would never see it, however since we have the hardware locked (HwEnter),
    //       we can read the port before the DPC can and thus we receive the Ack.
    startTime = PcGetTimeInterval(0);
    success = FALSE;
    while(PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        status = READ_PORT_UCHAR(portBase + MPU401_REG_STATUS);
        
        if (UartFifoOkForRead(status))                      // Is data waiting?
        {
            READ_PORT_UCHAR(portBase + MPU401_REG_DATA);    // yep.. read ACK 
            success = TRUE;                                 // don't need to do more 
            break;
        }
        KeStallExecutionProcessor(25);  //  microseconds
    }
#if (DBG)
    if (!success)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("First attempt to reset the MPU didn't get ACKed.\n"));
    }
#endif  //  (DBG)

    // NOTE: We cannot check the ACK byte because if the card was already in
    // UART mode it will not send an ACK but it will reset.

    // reset the card again
    (void) WriteLegacyMPU(portBase,COMMAND,MPU401_CMD_RESET);

                                    // wait for ack (again)
    startTime = PcGetTimeInterval(0); // This might take a while
    BYTE dataByte = 0;
    success = FALSE;
    while (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        status = READ_PORT_UCHAR(portBase + MPU401_REG_STATUS);
        if (UartFifoOkForRead(status))                                  // Is data waiting?
        {
            dataByte = READ_PORT_UCHAR(portBase + MPU401_REG_DATA);     // yep.. read ACK
            success = TRUE;                                             // don't need to do more
            break;
        }
        KeStallExecutionProcessor(25);
    }

    if ((0xFE != dataByte) || !success)   // Did we succeed? If no second ACK, something is hosed  
    {                       
        _DbgPrintF(DEBUGLVL_TERSE,("Second attempt to reset the MPU didn't get ACKed.\n"));
        _DbgPrintF(DEBUGLVL_TERSE,("Init Reset failure error. Ack = %X", ULONG(dataByte) ) );
        ntStatus = STATUS_IO_DEVICE_ERROR;
    }
    
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportMidiStreamUart::Write()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
STDMETHODIMP
CMiniportMidiStreamUart::
Write
(
    IN      PVOID       BufferAddress,
    IN      ULONG       Length,
    OUT     PULONG      BytesWritten
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("Write"));
    ASSERT(BytesWritten);
    if (!BufferAddress)
    {
        Length = 0;
    }

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (!m_fCapture)
    {
        PUCHAR  pMidiData;
        ULONG   count;

        count = 0;
        pMidiData = PUCHAR(BufferAddress);

        if (Length)
        {
            SYNCWRITECONTEXT context;
            context.Miniport        = (m_pMiniport);
            context.PortBase        = m_pPortBase;
            context.BufferAddress   = pMidiData;
            context.Length          = Length;
            context.BytesRead       = &count;

            if (m_pMiniport->m_UseIRQ)
            {
                ntStatus = m_pMiniport->m_pInterruptSync->
                                CallSynchronizedRoutine(SynchronizedMPUWrite,PVOID(&context));
            }
            else    //  !m_UseIRQ
            {
                ntStatus = SynchronizedMPUWrite(NULL,PVOID(&context));
            }       //  !m_UseIRQ

            if (count == 0)
            {
                m_NumFailedMPUTries++;
                if (m_NumFailedMPUTries >= 100)
                {
                    ntStatus = STATUS_IO_DEVICE_ERROR;
                    m_NumFailedMPUTries = 0;
                }
            }
            else
            {
                m_NumFailedMPUTries = 0;
            }
        }           //  if we have data at all
        *BytesWritten = count;
    }
    else    //  called write on the read stream
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * SynchronizedMPUWrite()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
NTSTATUS
SynchronizedMPUWrite
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           syncWriteContext
)
{
    PSYNCWRITECONTEXT context;
    context = (PSYNCWRITECONTEXT)syncWriteContext;
    ASSERT(context->Miniport);
    ASSERT(context->PortBase);
    ASSERT(context->BufferAddress);
    ASSERT(context->Length);
    ASSERT(context->BytesRead);

    PUCHAR  pChar = PUCHAR(context->BufferAddress);
    NTSTATUS ntStatus,readStatus;
    ntStatus = STATUS_SUCCESS;
    //
    // while we're not there yet, and
    // while we don't have to wait on an aligned byte (including 0)
    // (we never wait on an aligned byte.  Better to come back later)
//    if (context->Miniport->m_NumCaptureStreams)
    {
        readStatus = MPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
    }
    while (  (*(context->BytesRead) < context->Length)
          && (TryLegacyMPU(context->PortBase) 
             || (*(context->BytesRead)%4)
          )  )
    {
        ntStatus = WriteLegacyMPU(context->PortBase,DATA,*pChar);
        if (NT_SUCCESS(ntStatus))
        {
            pChar++;
            *(context->BytesRead) = *(context->BytesRead) + 1;
            readStatus = MPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("SynchronizedMPUWrite failed (0x%08x)",ntStatus));
            break;
        }
    }
//    if (context->Miniport->m_NumCaptureStreams)
    {
            readStatus = MPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
    }
    return ntStatus;
}

#define kMPUPollTimeout 2

#pragma code_seg()
/*****************************************************************************
 * TryLegacyMPU()
 *****************************************************************************
 * See if the MPU401 is free.
 */
BOOLEAN
TryLegacyMPU
(
    IN      PUCHAR      PortBase
)
{
    BOOLEAN success;
    USHORT  numPolls;
    UCHAR   status;

    _DbgPrintF(DEBUGLVL_BLAB, ("TryLegacyMPU"));
    numPolls = 0;

    while (numPolls < kMPUPollTimeout)
    {
        status = READ_PORT_UCHAR(PortBase + MPU401_REG_STATUS);
                                       
        if (UartFifoOkForWrite(status)) // Is this a good time to write data?
        {
            break;
        }
        numPolls++;
    }
    if (numPolls >= kMPUPollTimeout)
    {
        success = FALSE;
        _DbgPrintF(DEBUGLVL_BLAB, ("TryLegacyMPU failed"));
    }
    else
    {
        success = TRUE;
    }

    return success;
}

#pragma code_seg()
/*****************************************************************************
 * WriteLegacyMPU()
 *****************************************************************************
 * Write a byte out to the MPU401.
 */
NTSTATUS
WriteLegacyMPU
(
    IN      PUCHAR      PortBase,
    IN      BOOLEAN     IsCommand,
    IN      UCHAR       Value
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("WriteLegacyMPU"));
    NTSTATUS ntStatus = STATUS_IO_DEVICE_ERROR;

    if (!PortBase)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("O: PortBase is zero\n"));
        return ntStatus;
    }
    PUCHAR deviceAddr = PortBase + MPU401_REG_DATA;

    if (IsCommand)
    {
        deviceAddr = PortBase + MPU401_REG_COMMAND;
    }

    ULONGLONG startTime = PcGetTimeInterval(0);
    
    while (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        UCHAR status
        = READ_PORT_UCHAR(PortBase + MPU401_REG_STATUS);

        if (UartFifoOkForWrite(status)) // Is this a good time to write data?
        {                               // yep (Jon comment)
            WRITE_PORT_UCHAR(deviceAddr,Value);
#if kTurnOnKdPrint
            KdPrint(("'Mi:O: %02X\n",Value));
#endif //   kTurnOnKdPrint
            _DbgPrintF(DEBUGLVL_BLAB, ("WriteLegacyMPU emitted 0x%02x",Value));
            ntStatus = STATUS_SUCCESS;
            break;
        }
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportMidiStreamUart::Read()
 *****************************************************************************
 * Reads incoming MIDI data.
 */
STDMETHODIMP
CMiniportMidiStreamUart::
Read
(
    IN      PVOID   BufferAddress,
    IN      ULONG   Length,
    OUT     PULONG  BytesRead
)
{
    ASSERT(BufferAddress);
    ASSERT(BytesRead);

    *BytesRead = 0;
    if (m_fCapture)
    {
        DEFERREDREADCONTEXT context;
        context.BufferAddress   = BufferAddress;
        context.Length          = Length;
        context.BytesRead       = BytesRead;
        context.pMPUInputBufferHead = &(m_pMiniport->m_MPUInputBufferHead);
        context.MPUInputBufferTail = m_pMiniport->m_MPUInputBufferTail;
        context.MPUInputBuffer     = m_pMiniport->m_MPUInputBuffer;

        if (*(context.pMPUInputBufferHead) != context.MPUInputBufferTail)
        {
            //
            //  More data is available.
            //  No need to touch the hardware, just read from our SW FIFO.
            //
            return (DeferredLegacyRead(m_pMiniport->m_pInterruptSync,PVOID(&context)));
        }
        else
        {
            return STATUS_SUCCESS;
        }
    }
    else
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
}

#pragma code_seg()
/*****************************************************************************
 * DeferredLegacyRead()
 *****************************************************************************
 * Synchronized routine to read incoming MIDI data.
 * We have already read the bytes in, and now the Port wants them.
 */
NTSTATUS
DeferredLegacyRead
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    ASSERT(InterruptSync);
    ASSERT(DynamicContext);

    PDEFERREDREADCONTEXT context = PDEFERREDREADCONTEXT(DynamicContext);

    ASSERT(context->BufferAddress);
    ASSERT(context->BytesRead);


    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUCHAR  pDest = PUCHAR(context->BufferAddress);
    PULONG  pMPUInputBufferHead = context->pMPUInputBufferHead;
    ULONG   MPUInputBufferTail = context->MPUInputBufferTail;
    ULONG   bytesRead = 0;

    ASSERT(pMPUInputBufferHead);
    ASSERT(context->MPUInputBuffer);

    while  (    (*pMPUInputBufferHead != MPUInputBufferTail)
            &&  (bytesRead < context->Length) )
    {
        *pDest = context->MPUInputBuffer[*pMPUInputBufferHead];

        pDest++;
        bytesRead++;
        *pMPUInputBufferHead = *pMPUInputBufferHead + 1;
        //
        //  Wrap FIFO position when reaching the buffer size.
        //
        if (*pMPUInputBufferHead >= kMPUInputBufferSize)
        {
            *pMPUInputBufferHead = 0;
        }
    }
    *context->BytesRead = bytesRead;

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * MPUInterruptServiceRoutine()
 *****************************************************************************
 * ISR.
 */
NTSTATUS
MPUInterruptServiceRoutine
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("MPUInterruptServiceRoutine"));
    ULONGLONG   startTime;

    ASSERT(DynamicContext);

    NTSTATUS            ntStatus;
    BOOL                newBytesAvailable;
    CMiniportMidiUart   *that;

    that = (CMiniportMidiUart *) DynamicContext;
    newBytesAvailable = FALSE;
    ntStatus = STATUS_UNSUCCESSFUL;

    UCHAR portStatus = 0xff;

    //
    // Read the MPU status byte.
    //
    if (that->m_pPortBase)
    {
        portStatus =
            READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_STATUS);

        //
        // If there is outstanding work to do and there is a port-driver for
        // the MPU miniport...
        //
        if (UartFifoOkForRead(portStatus) && that->m_pPort)
        {
            startTime = PcGetTimeInterval(0);
            while ( (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50)) 
                &&  (UartFifoOkForRead(portStatus)) )
            {
                UCHAR uDest = READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_DATA);
                if (    (that->m_KSStateInput == KSSTATE_RUN)
                   &&   (that->m_NumCaptureStreams)
                   )
                {
#if kTurnOnKdPrint
                    KdPrint(("'Mi:\t\tI: %02X\n",uDest));
#endif //   kTurnOnKdPrint
                    ULONG buffHead = that->m_MPUInputBufferHead;
                    if (   (that->m_MPUInputBufferTail + 1 == buffHead)
                        || (that->m_MPUInputBufferTail + 1 - kMPUInputBufferSize == buffHead))
                    {
                        _DbgPrintF(DEBUGLVL_TERSE,("*****MPU Input Buffer Overflow*****"));
                    }
                    else
                    {
                        newBytesAvailable = TRUE;
                        //  ...place the data in our FIFO...
                        that->m_MPUInputBuffer[that->m_MPUInputBufferTail] = uDest;
                        ASSERT(that->m_MPUInputBufferTail < kMPUInputBufferSize);
                        
                        that->m_MPUInputBufferTail++;
                        if (that->m_MPUInputBufferTail >= kMPUInputBufferSize)
                        {
                            that->m_MPUInputBufferTail = 0;
                        }
                    }
                }
#if kTurnOnKdPrint
                else
                {
                    KdPrint(("'Mi:\t\tI: %02X XXX\n",uDest));
                }
#endif //   kTurnOnKdPrint
                //
                // Look for more MIDI data.
                //
                portStatus =
                    READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_STATUS);
            }   //  either there's no data or we ran too long
            if (newBytesAvailable)
            {
                //
                // ...notify the MPU port driver that we have bytes.
                //
                that->m_pPort->Notify(that->m_pServiceGroup);
            }
            ntStatus = STATUS_SUCCESS;
        }
    }

    return ntStatus;
}

=== uart/private.h ===
/*****************************************************************************
 * private.h - MPU-401 miniport private definitions
 *****************************************************************************
 * Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 */

#ifndef _MIDIUART_PRIVATE_H_
#define _MIDIUART_PRIVATE_H_

#include "portcls.h"
#include "stdunk.h"

#ifdef  UNDER_NT
#define kTurnOnKdPrint  (0)
#else   //  UNDER_NT
#define kTurnOnKdPrint  (1)
#endif  //  UNDER_NT

/*****************************************************************************
 * References forward
 */

class timeout;


/*****************************************************************************
 * Prototypes
 */

NTSTATUS InitLegacyMPU(IN PINTERRUPTSYNC InterruptSync,IN PVOID DynamicContext);
NTSTATUS ResetMPUHardware(PUCHAR portBase);


/*****************************************************************************
 * Constants
 */

const BOOLEAN COMMAND   = TRUE;
const BOOLEAN DATA      = FALSE;

const ULONG kMPUInputBufferSize = 128;


/*****************************************************************************
 * Globals
 */



/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportMidiUart
 *****************************************************************************
 * MPU-401 miniport.  This object is associated with the device and is
 * created when the device is started.  The class inherits IMiniportMidi
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportMidiUart
:   public IMiniportMidi,
    public CUnknown
{
private:
    KSSTATE         m_KSStateInput;         // Miniport input stream state (RUN/PAUSE/ACQUIRE/STOP)
    PPORTMIDI       m_pPort;                // Callback interface.
    PUCHAR          m_pPortBase;            // Base port address.
    PINTERRUPTSYNC  m_pInterruptSync;       // Interrupt synchronization object.
    PSERVICEGROUP   m_pServiceGroup;        // Service group for capture.
    USHORT          m_NumRenderStreams;     // Num active render streams.
    USHORT          m_NumCaptureStreams;    // Num active capture streams.
    ULONG           m_MPUInputBufferHead;   // Index of the newest byte in the FIFO.
    ULONG           m_MPUInputBufferTail;   // Index of the oldest empty space in the FIFO.
    BOOLEAN         m_UseIRQ;               //  FALSE if no IRQ is used for MIDI.
    UCHAR           m_MPUInputBuffer[kMPUInputBufferSize];  // Internal SW FIFO.

    /*************************************************************************
     * CMiniportMidiUart methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     */
    NTSTATUS ProcessResources
    (
        IN      PRESOURCELIST   ResourceList
    );
    NTSTATUS InitializeHardware(PINTERRUPTSYNC interruptSync,PUCHAR portBase);

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportMidiUart);

    ~CMiniportMidiUart();

    /*************************************************************************
     * IMiniport methods
     */
    STDMETHODIMP 
    GetDescription
    (   OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );
    STDMETHODIMP 
    DataRangeIntersection
    (   IN      ULONG           PinId
    ,   IN      PKSDATARANGE    DataRange
    ,   IN      PKSDATARANGE    MatchingDataRange
    ,   IN      ULONG           OutputBufferLength
    ,   OUT     PVOID           ResultantFormat
    ,   OUT     PULONG          ResultantFormatLength
    )
    {
        return STATUS_NOT_IMPLEMENTED;
    }

    /*************************************************************************
     * IMiniportMidi methods
     */
    STDMETHODIMP Init
    (
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTMIDI       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    );
    STDMETHODIMP NewStream
    (
        OUT     PMINIPORTMIDISTREAM   * Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   Pin,
        IN      BOOLEAN                 Capture,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP         * ServiceGroup
    );
    STDMETHODIMP_(void) Service
    (   void
    );

    /*************************************************************************
     * Friends 
     */
    friend class CMiniportMidiStreamUart;
    friend NTSTATUS 
        MPUInterruptServiceRoutine(PINTERRUPTSYNC InterruptSync,PVOID DynamicContext);
    friend NTSTATUS 
        SynchronizedMPUWrite(PINTERRUPTSYNC InterruptSync,PVOID syncWriteContext);
};

/*****************************************************************************
 * CMiniportMidiStreamUart
 *****************************************************************************
 * MPU-401 miniport stream.  This object is associated with the pin and is
 * created when the pin is instantiated.  It inherits IMiniportMidiStream
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportMidiStreamUart
:   public IMiniportMidiStream,
    public CUnknown
{
private:
    CMiniportMidiUart * m_pMiniport;            // Parent.
    PUCHAR              m_pPortBase;            // Base port address.
    long                m_NumFailedMPUTries;    // Deadman timeout for MPU hardware.
    BOOLEAN             m_fCapture;             // Whether this is capture.

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportMidiStreamUart);

    ~CMiniportMidiStreamUart();

    STDMETHODIMP Init
    (
        IN      CMiniportMidiUart * pMiniport,
        IN      PUCHAR              pPortBase,
        IN      BOOLEAN             fCapture
    );

    /*************************************************************************
     * IMiniportMidiStream methods
     */
    STDMETHODIMP SetFormat
    (
        IN      PKSDATAFORMAT   DataFormat
    );
    STDMETHODIMP SetState
    (
        IN      KSSTATE     State
    );
    STDMETHODIMP Read
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BufferLength,
        OUT     PULONG      BytesRead
    );
    STDMETHODIMP Write
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BytesToWrite,
        OUT     PULONG      BytesWritten
    );
};
#endif  //  _MIDIUART_PRIVATE_H_
=== uart/sources ===
# Copyright (c) 1997-1999 Microsoft Corporation.  All rights reserved.
 
TARGETNAME=UART
TARGETTYPE=LIBRARY
TARGETPATH=..\lib

C_DEFINES=-D_WIN32 -DUNICODE -D_UNICODE -DUNDER_NT -DDEBUG_LEVEL=DEBUGLVL_TERSE

LINKER_FLAGS=-map

INCLUDES=..\inc

MSC_WARNING_LEVEL=-W3 -WX

SOURCES=\
        miniport.cpp \
        MPU.cpp

=== uart/uart.htm ===
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-
1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>UART</TITLE>
</HEAD>
<BODY LINK="#0000ff">

<FONT FACE="Verdana" SIZE=5><H2>UART</H2>
</FONT><FONT FACE="Verdana" SIZE=2>
<P><span style="color:#FF0000;font-size:10pt;font-family:Arial">[This is preliminary 
documentation and subject to change.]</span></P>

<H3>SUMMARY</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
This sample is a MIDI UART miniport driver which provides an interface to the MPU-401 chip. <P>
The MIDI port driver, which is built into PortCls.sys, insulates the miniport and connects it to the rest of the system. The sample handles
one input stream and one output stream.  It compiles in the 64-bit environment and is compatible with both Alpha and x86 platforms.<P>
Plug and Play and Power Management are handled automatically on the miniport's behalf by PortCls.<P>

<H3>BUILDING THE SAMPLE</H3></FONT><FONT FACE="Verdana" 
SIZE=2><P>

Type <B>build</B> in the \\Ntddk\Src\Wdm\Audio\Miniport\Uart directory.  A 
successful build produces Uart.lib, which can be linked into an adapter driver along with Stdunk.lib.<P>


<H3>RESOURCES</H3></FONT><FONT FACE="Verdana" SIZE=2><P>
This exact miniport is already included in PortCls. We have provided the source code as a starting point for those that need to augment it, as well as those that need to create completely new miniports. 
This miniport interfaces to the port driver of type MIDI. A new port, type DMUS, was introduced in Microsoft Windows 98 Second Edition (SE) and Microsoft Windows 2000.  The DMUS port provides higher functionality than the MIDI port, so if you are creating your own miniport, consider interfacing to DMUS instead of MIDI. The advantage of DMUS miniport drivers is that they are visible to DirectMusic APIs, unlike MIDI miniport drivers. Additionally, DMUS miniports are still visible to the older MIDI APIs. In short, DirectMusic miniports have the benefits of both backward compatibility and advanced functionality. 
<p>
Please refer to the SB16 sample to learn how to use the built-in miniport.<p>


DirectMusic kernel support is not available in Windows 98, only in Windows 98SE and Windows 2000 and later.




<H3>CODE TOUR</H3>
<H4>File Manifest</H4>
</FONT><U><PRE>File&#9;&#9;Description
</U>
miniport.cpp&#9;Miniport driver implementation
mpu.cpp&#9; 	MPU device-specific implementation
private.h&#9;Interface for the CPP files
sources&#9;	Sources for build
</FONT><P ALIGN="CENTER"><A HREF="#top"><FONT FACE="Verdana" SIZE=2>Top of page</FONT></A><FONT FACE="Verdana" SIZE=2> </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 WIDTH=624>
<TR><TD VALIGN="MIDDLE" BGCOLOR="#00ffff" HEIGHT=2>
<P></TD>
</TR>
</TABLE>

<FONT FACE="MS Sans Serif" SIZE=1><P>&copy; 1999 Microsoft Corporation</FONT><FONT FACE="Verdana" SIZE=2> </P></FONT></BODY>
</HTML>

